{"version":3,"sources":["bin/fable-library.2.4.13/Util.js","bin/fable-library.2.4.13/Types.js","bin/fable-library.2.4.13/Reflection.js","bin/Model.js","bin/fable-library.2.4.13/Option.js","bin/lib/big.js","bin/fable-library.2.4.13/Decimal.js","bin/fable-library.2.4.13/Int32.js","bin/lib/long.js","bin/fable-library.2.4.13/Long.js","bin/fable-library.2.4.13/Seq.js","bin/fable-library.2.4.13/String.js","bin/fable-library.2.4.13/MutableMap.js","bin/fable-library.2.4.13/Map.js","bin/fable-library.2.4.13/MutableSet.js","bin/fable-library.2.4.13/Set.js","bin/fable-library.2.4.13/List.js","bin/fable-library.2.4.13/AsyncBuilder.js","bin/fable-library.2.4.13/Async.js","bin/Fable.Elmish.3.0.6/prelude.js","bin/Fable.Elmish.3.0.6/cmd.js","bin/State.js","bin/js/jwt.js","bin/Fable.Elmish.3.0.6/ring.js","bin/fable-library.2.4.13/Array.js","bin/Fable.Elmish.3.0.6/program.js","bin/Fable.React.5.3.6/Fable.React.Props.js","bin/Fable.React.5.3.6/Fable.React.Helpers.js","bin/Fable.React.5.3.6/Fable.React.FunctionComponent.js","bin/View.js","bin/Hooks.js","Pages/Home.jsx","Pages/NotFound.jsx","Pages/AddLocation.jsx","Auth/config.js","Auth/react-auth0-wrapper.js","Auth/index.js","Pages/TokenPage.js","Routes/index.js","Components/Navigation.jsx","Components/Loading.jsx","Components/Layout.jsx","App.js","serviceWorker.js","index.js"],"names":["isArrayLike","x","Array","isArray","ArrayBuffer","isView","isDisposable","Dispose","tryGetValue","map","key","defaultValue","has","get","dateOffset","date","date1","offset","kind","getTimezoneOffset","ObjectRef","o","idMap","set","count","stringHash","s","i","h","len","length","charCodeAt","numberHash","combineHashCodes","hashes","reduce","h1","h2","structuralHash","GetHashCode","isHashable","String","equalArraysWith","y","eq","equalArrays","equals","Equals","isEquatable","Date","compareDates","xtime","ytime","getTime","comparePrimitives","compareArraysWith","comp","j","compareArrays","compare","CompareTo","isComparable","max","comparer","WeakMap","uncurry","arity","f","uncurriedFn","a1","a2","a3","a4","a5","a6","a7","a8","Error","curry","partialApply","args","apply","concat","getItemFromDict","sameType","Object","getPrototypeOf","constructor","declare","cons","superClass","subClass","prototype","create","value","enumerable","writable","configurable","inherits","SystemObject","compareList","self","other","tail","res","head","List","this","Union","tag","name","fields","recordToJson","record","getFieldNames","keys","recordEquals","thisNames","recordCompare","result","Record","toString","k","join","id","identityHash","from","toJSON","Symbol","iterator","cur","next","tmp","done","splice","FSharpRef","contents","Exception","message","stack","getFSharpExceptionFieldNames","filter","FSharpException","call","fieldNames","arg1","arg2","arg3","TypeInfo","fullname","generics","cases","enumCases","fullName","t","gen","getGenerics","t1","t2","getRecordElements","k1","v1","k2","v2","endsWith","Role","Model","Events","AuthorizationToken","Msg","Some","some","undefined","acceptNull","field","P","e","c","cmp","NAME","INVALID","INVALID_DP","NUMERIC","parse","n","nl","test","charAt","slice","indexOf","replace","search","substring","round","Big","DP","RM","dp","rm","more","xc","unshift","pop","stringify","z","push","NE","PE","abs","isneg","yc","l","Math","div","a","b","bl","bt","ri","bz","ai","al","r","rl","q","qc","qi","d","shift","gt","gte","lt","lte","minus","sub","xlty","plus","xe","ye","reverse","mod","ygtx","times","add","pow","one","sqrt","half","toExponential","mul","toFixed","toPrecision","sd","valueOf","_Big_","findIndex","normalize","version","Decimal","NumberStyles","Long","wasm","WebAssembly","Instance","Module","Uint8Array","exports","low","high","unsigned","isLong","obj","radix","__isLong__","defineProperty","INT_CACHE","UINT_CACHE","fromInt","cachedObj","cache","fromBits","fromNumber","isNaN","UZERO","ZERO","TWO_PWR_64_DBL","MAX_UNSIGNED_VALUE","TWO_PWR_63_DBL","MIN_VALUE","MAX_VALUE","negate","TWO_PWR_32_DBL","lowBits","highBits","pow_dbl","fromString","str","RangeError","p","radixToPower","size","min","parseInt","multiply","fromValue","val","TWO_PWR_16_DBL","TWO_PWR_24","ONE","UONE","NEG_ONE","toInt","$this","toNumber","isZero","isNegative","radixLong","divide","rem1","subtract","rem","remDiv","digits","isOdd","lessThan","greaterThan","greaterThanOrEqual","thisNeg","otherNeg","not","addend","a48","a32","a16","a00","b48","b32","b16","c48","c32","c16","c00","subtrahend","multiplier","get_high","b00","divisor","approx","div_u","div_s","toUnsigned","shiftRightUnsigned","shiftLeft","shiftRight","floor","log2","ceil","log","LN2","delta","approxRes","approxRem","numBits","op_Multiply","fromBytes","bytes","le","fromBytesLE","fromBytesBE","toBytes","hi","lo","toBytesLE","toBytesBE","Enumerator","iter","current","getEnumerator","toIterator","en","MoveNext","Current","append","xs","ys","delay","firstDone","iters","unfold","_a","_b","output","innerIter","hasFinished","collect","fold","acc","iterate","_","iterateIndexed","singleton","skip","sumBy","adder","Add","GetZero","take","truncate","fst","v","fsFormatRegExp","isNumeric","isLessThan","_Long","substr","toHex","Number","printf","input","cont","createPrinter","strCopy","arg","formatOnce","toText","str2","rep","prefix","flags","padLength","precision","format","sign","toLowerCase","toUpperCase","zeroFlag","minusFlag","ch","padLeft","delimiter","isRight","MutableMap$00602","pairs","this$","hashMap","Map","pair","MutableMap$00602$$Add$$5BDDA1","MutableMap$00602$$TryFindIndex$$2B595","this$$$1","matchValue","pair$$1","MutableMap$00602$$TryFind$$2B595","this$$$2","k$$1","matchValue$$1","MutableMap$00602$$Clear","this$$$4","clear","MutableMap$00602$$get_Count","this$$$5","pairs$$2","values","$x$$2","$y$$3","this$$$8","k$$4","v$$1","matchValue$$4","msg","clo1","MutableMap$00602$$Remove$$2B595","this$$$10","k$$6","matchValue$$6","this$$$11","pairs$$3","pair$$3","item","Clear","Contains","item$$1","matchValue$$7","CopyTo","array","arrayIndex","i$$10","Remove","item$$2","matchValue$$8","delete","k$$7","entries","k$$8","this$$$6","k$$2","matchValue$$2","MutableMap$00602$$get_Item$$2B595","k$$9","this$$$9","k$$5","matchValue$$5","MutableMap$00602$$ContainsKey$$2B595","pair$$5","k$$10","v$$2","this$$$7","k$$3","matchValue$$3","MutableMap$00602$$set_Item$$5BDDA1","pair$$6","MapTree$00602","MapTreeModule$$$size","MapTreeModule$$$sizeAux","$acc$$5","$m$$6","m","MapTreeModule$$$find","$comparer$$1$$23","$k$$3$$24","$m$$4$$25","comparer$$1","m$$4","Compare","c$$3","MapTreeModule$$$mem","$comparer$$10$$59","$k$$12$$60","$m$$8$$61","comparer$$10","k$$12","m$$8","c$$8","MapTreeModule$002EMapIterator$00602","started","MapTreeModule$$$collapseLHS","$stack$$111","MapTreeModule$$$mkIterator","s$$5","MapTreeModule$$$current","i$$2","MapTreeModule$$$alreadyFinished","MapTreeModule$$$notStarted","MapTreeModule$002EmkIEnumerator$0027$00602","s$$6","MapTreeModule$$$mkIEnumerator","s$$7","MapTreeModule$002EmkIEnumerator$0027$00602$$$$002Ector$$Z26BC498C","MapTreeModule$$$toSeq","s$$8","en$$1","i$$3","MapTreeModule$$$moveNext","Reset","FSharpMap","comparer$$17","tree","FSharpMap$$get_Tree","__$$5","FSharpMap$$get_Item$$2B595","__$$8","k$$29","FSharpMap$$get_Count","__$$20","FSharpMap$$ContainsKey$$2B595","__$$21","k$$31","map$$2","kv","clo2","combineHash","x$$16","y$$3","res$$3","e$$1","activePatternResult3703","that","res$$4","finished","e1","e2","kvp1","kvp2","c$$10","_arg1$$1","k$$34","k$$35","kv$$1","k$$36","v$$26","kv$$2","MutableSet$00601","items","MutableSet$00601$$Add$$2B595","MutableSet$00601$$TryFindIndex$$2B595","MutableSet$00601$$Clear","MutableSet$00601$$get_Count","MutableSet$00601$$Contains$$2B595","MutableSet$00601$$Remove$$2B595","values$$1","value$$2","i$$8","item$$3","add_","x$$1","SetTree$00601","SetTreeModule$$$SetOne","SetTreeModule$$$SetNode","l$$1","r$$1","SetTreeModule$002ESetIterator$00601","SetTreeModule$$$collapseLHS","$stack$$104","SetTreeModule$$$mkIterator","s$$13","SetTreeModule$$$current","SetTreeModule$$$alreadyFinished","SetTreeModule$$$notStarted","SetTreeModule$002EmkIEnumerator$00601","s$$14","SetTreeModule$$$mkIEnumerator","s$$15","SetTreeModule$002EmkIEnumerator$00601$$$$002Ector$$Z5B395D56","SetTreeModule$$$compare","comparer$$18","s1","s2","$comparer$$17$$112","$l1$$113","$l2$$114","SetTreeModule$$$compareStacks","$target$$115","t1$$6","t2$$6","n1k","n2k","t1$$7","t2$$7","n1k$$1","n2k$$1","n2r","t1$$8","t2$$8","emp","n1k$$2","n1r","n2k$$2","t1$$9","t2$$9","n1k$$3","n1r$$1","n2k$$3","n2r$$1","t1$$10","t2$$10","n1k$$4","t1$$11","n1k$$5","n1l","n1r$$2","t1$$12","n2k$$4","t2$$11","n2k$$5","n2l","n2r$$2","t2$$12","l1","l2","c$$7","c$$9","i$$1","SetTreeModule$$$moveNext","FSharpSet","comparer$$22","FSharpSet$$get_Comparer","__$$4","FSharpSet$$get_Tree","map$$1","x$$21","that$$1","$f$$2$$19","$state$$1$$20","$xs$$8$$21","f$$2","state$$1","xs$$8","xs$$9","acc$$1","x$$6","f$$24","xs$$46","unitVar0","x$$24","CancellationToken","cancelled","_id","_cancelled","_listeners","listener","state","$","addListener","removeListener","OperationCanceledError","setPrototypeOf","protectedCont","ctx","cancelToken","isCancelled","onCancel","trampoline","incrementAndCheck","hijack","err","onError","protectedBind","computation","binder","onSuccess","ex","protectedReturn","computation1","computation2","Bind","generator","sequence","body","While","Delay","compensation","catchHandler","ex2","resource","TryFinally","guard","Return","Log$$$onError","text","console","error","Cmd$$$exec","dispatch","cmd","Cmd$$$none","initialState","Role$$1","getPermissions","jwtToken","token","base64","split","jsonPayload","decodeURIComponent","atob","JSON","parseJwt","permissions","getRole","token$$1","hasPermission","update","model","Cmd$0024$0024$0024none","RingState$00601","RingBuffer$00601","target","targetIndex","fill","RingBuffer$00601$$Pop","__","rix$0027","RingBuffer$00601$$Push$$2B595","__$$1","wix$0027","ix$$1","items$$4","source$$6","first","step","last","rangeNumber","cons$$31","RingBuffer$00601$$doubleSize","wix$$1","Program$00604","arg4","arg5","arg6","arg7","init","subscribe","view","setState","syncDispatch","ProgramModule$$$runWith","arg$$1","program$$11","sub$$1","patternInput$$3","rb","RingBuffer$002400601$0024$0024$0024$0024002Ector$0024$0024Z524259A4","reentered","state$$3","syncDispatch$$1","msg$$3","RingBuffer$002400601$0024$0024Push$0024$00242B595","nextMsg","msg$$4","patternInput$$4","Cmd$0024$0024$0024exec","ex$$2","RingBuffer$002400601$0024$0024Pop","ex$$3","xs$$28","cmd$$5","acc$$10","x$$15","__html","ReactElementTypeModule$$$memoWith","areEqual","render$$1","react","AppContext","Dispatch","appContext","ElmishCapture","render","displayName","memoizeWith","withKey","elemType","memoElement","ReactElementTypeModule$0024$0024$0024memoWith","name$$1","props","props$$1","f$$1","FunctionComponent$0024$0024$0024Of$0024$0024Z603636D8","program","_arg1","$arg$$1","tupledArg","Log$0024$0024$0024onError","value$$1","children","Provider","y$$1","keys$$1","length$$1","result$$1","key$$1","xValue$$1","useSetToken","g","dispatch$$1","delegateArg0","useDump","model$$1","Home","NotFound","AddLocation","useForm","location","price","isDraft","remark","register","handleSubmit","errors","watch","className","Form","onSubmit","FormGroup","Label","for","Input","type","autoComplete","innerRef","invalid","placeholder","Button","color","currentDomain","protocol","host","auth0Config","domain","process","client_id","audience","redirect_uri","scope","onRedirectCallback","navigate","DEFAULT_REDIRECT_CALLBACK","window","history","replaceState","document","title","pathname","Auth0Context","React","createContext","useAuth0","useContext","Auth0Provider","initOptions","useState","isAuthenticated","setIsAuthenticated","user","setUser","auth0Client","setAuth0","loading","setLoading","popupOpen","setPopupOpen","useEffect","createAuth0Client","auth0FromHook","includes","handleRedirectCallback","appState","getUser","initAuth0","loginWithPopup","params","getIdTokenClaims","loginWithRedirect","getTokenSilently","getTokenWithPopup","logout","config","redirectUri","TokenPage","setToken","then","Navigation","role","collapsed","setCollapsed","path","usePath","loginButton","NavItem","onClick","ev","preventDefault","NavLink","href","userElement","src","picture","alt","nickname","navLink","link","isActive","A","active","extraMenuItems","Navbar","dark","expand","NavbarBrand","NavbarToggler","Collapse","isOpen","navbar","Nav","Loading","info","Layout","routeResult","useRoutes","routes","localStorage","getItem","removeItem","App","Boolean","hostname","match","ReactDOM","getElementById","navigator","serviceWorker","ready","registration","unregister","catch"],"mappings":"2OAmBO,SAASA,EAAYC,GAC1B,OAAY,MAALA,IAAcC,MAAMC,QAAQF,IAAMG,YAAYC,OAAOJ,IAcvD,SAASK,EAAaL,GAC3B,OAAY,MAALA,GAAkC,oBAAdA,EAAEM,QAmCxB,SAASC,EAAYC,EAAKC,EAAKC,GACpC,OAAOF,EAAIG,IAAIF,GAAO,EAAC,EAAMD,EAAII,IAAIH,IAAQ,EAAC,EAAOC,GAuEhD,SAASG,EAAWC,GACzB,IAAMC,EAAQD,EACd,MAA+B,kBAAjBC,EAAMC,OAAsBD,EAAMC,OAAuB,IAAdF,EAAKG,KAE5D,GAAgC,IAA5BH,EAAKI,oBAUN,IAAMC,EAAb,gGACYC,GAKR,OAJKD,EAAUE,MAAMV,IAAIS,IACvBD,EAAUE,MAAMC,IAAIF,IAAKD,EAAUI,OAG9BJ,EAAUE,MAAMT,IAAIQ,OAN/B,KAYO,SAASI,EAAWC,GAKzB,IAJA,IAAIC,EAAI,EACJC,EAAI,KACFC,EAAMH,EAAEI,OAEPH,EAAIE,GACTD,EAAQ,GAAJA,EAASF,EAAEK,WAAWJ,KAG5B,OAAOC,EAEF,SAASI,EAAW/B,GACzB,OAAW,WAAJA,EAAiB,EAGnB,SAASgC,EAAiBC,GAC/B,OAAsB,IAAlBA,EAAOJ,OACF,EAGFI,EAAOC,QAAO,SAACC,EAAIC,GACxB,OAAQD,GAAM,GAAKA,EAAKC,KAsBrB,SAASC,EAAerC,GAC7B,GAAS,MAALA,EACF,OAAO,EAGT,cAAeA,GACb,IAAK,UACH,OAAOA,EAAI,EAAI,EAEjB,IAAK,SACH,OAAO+B,EAAW/B,GAEpB,IAAK,SACH,OAAOwB,EAAWxB,GAEpB,QAEI,GArMD,SAAoBA,GACzB,OAAY,MAALA,GAAsC,oBAAlBA,EAAEsC,YAoMnBC,CAAWvC,GACb,OAAOA,EAAEsC,cACJ,GAAIvC,EAAYC,GAAI,CAIzB,IAHA,IAAM4B,EAAM5B,EAAE6B,OACRI,EAAS,IAAIhC,MAAM2B,GAEhBF,EAAI,EAAGA,EAAIE,EAAKF,IACvBO,EAAOP,GAAKW,EAAerC,EAAE0B,IAG/B,OAAOM,EAAiBC,GAExB,OAAOT,EAAWgB,OAAOxC,KAK5B,SAASyC,EAAgBzC,EAAG0C,EAAGC,GACpC,GAAS,MAAL3C,EACF,OAAY,MAAL0C,EAGT,GAAS,MAALA,EACF,OAAO,EAGT,GAAI1C,EAAE6B,SAAWa,EAAEb,OACjB,OAAO,EAGT,IAAK,IAAIH,EAAI,EAAGA,EAAI1B,EAAE6B,OAAQH,IAC5B,IAAKiB,EAAG3C,EAAE0B,GAAIgB,EAAEhB,IACd,OAAO,EAIX,OAAO,EAEF,SAASkB,EAAY5C,EAAG0C,GAC7B,OAAOD,EAAgBzC,EAAG0C,EAAGG,GAmBxB,SAASA,EAAO7C,EAAG0C,GACxB,OAAI1C,IAAM0C,IAEM,MAAL1C,EACG,MAAL0C,EACO,MAALA,IAEa,kBAAN1C,IAzQb,SAAqBA,GAC1B,OAAY,MAALA,GAAiC,oBAAbA,EAAE8C,OA0QlBC,CAAY/C,GACdA,EAAE8C,OAAOJ,GACP3C,EAAYC,GACdD,EAAY2C,IAAME,EAAY5C,EAAG0C,GAC/B1C,aAAagD,OACfN,aAAaM,MAA+B,IAAvBC,EAAajD,EAAG0C,OAKzC,SAASO,EAAajD,EAAG0C,GAC9B,IAAIQ,EACAC,EAUJ,MARI,WAAYnD,GAAK,WAAY0C,GAC/BQ,EAAQlD,EAAEoD,UACVD,EAAQT,EAAEU,YAEVF,EAAQlD,EAAEoD,UAAYvC,EAAWb,GACjCmD,EAAQT,EAAEU,UAAYvC,EAAW6B,IAG5BQ,IAAUC,EAAQ,EAAID,EAAQC,GAAS,EAAI,EAE7C,SAASE,EAAkBrD,EAAG0C,GACnC,OAAO1C,IAAM0C,EAAI,EAAI1C,EAAI0C,GAAK,EAAI,EAE7B,SAASY,EAAkBtD,EAAG0C,EAAGa,GACtC,GAAS,MAALvD,EACF,OAAY,MAAL0C,EAAY,EAAI,EAGzB,GAAS,MAALA,EACF,OAAQ,EAGV,GAAI1C,EAAE6B,SAAWa,EAAEb,OACjB,OAAO7B,EAAE6B,OAASa,EAAEb,QAAU,EAAI,EAGpC,IAAK,IAAIH,EAAI,EAAG8B,EAAI,EAAG9B,EAAI1B,EAAE6B,OAAQH,IAGnC,GAAU,KAFV8B,EAAID,EAAKvD,EAAE0B,GAAIgB,EAAEhB,KAGf,OAAO8B,EAIX,OAAO,EAEF,SAASC,EAAczD,EAAG0C,GAC/B,OAAOY,EAAkBtD,EAAG0C,EAAGgB,GAqC1B,SAASA,EAAQ1D,EAAG0C,GACzB,OAAI1C,IAAM0C,EACD,EACO,MAAL1C,EACG,MAAL0C,EAAY,GAAK,EACV,MAALA,EACF,EACe,kBAAN1C,EACTA,EAAI0C,GAAK,EAAI,EA9WjB,SAAsB1C,GAC3B,OAAY,MAALA,GAAoC,oBAAhBA,EAAE2D,UA8WlBC,CAAa5D,GACfA,EAAE2D,UAAUjB,GACV3C,EAAYC,IAAMD,EAAY2C,GAChCe,EAAczD,EAAG0C,GACf1C,aAAagD,MAAQN,aAAaM,KACpCC,EAAajD,EAAG0C,GAEhB,EAMJ,SAASmB,EAAIC,EAAU9D,EAAG0C,GAC/B,OAAOoB,EAAS9D,EAAG0C,GAAK,EAAI1C,EAAI0C,EAhPlCvB,EAAUE,MAAQ,IAAI0C,QACtB5C,EAAUI,MAAQ,EAsZX,SAASyC,EAAQC,EAAOC,GAE7B,GAAS,MAALA,EACF,OAAO,KAIT,GAAIA,EAAErC,OAAS,EAEb,OAAOqC,EAGT,IAAIC,EAEJ,OAAQF,GACN,KAAK,EACHE,EAAc,SAACC,EAAIC,GAAL,OAAYH,EAAEE,EAAFF,CAAMG,IAEhC,MAEF,KAAK,EACHF,EAAc,SAACC,EAAIC,EAAIC,GAAT,OAAgBJ,EAAEE,EAAFF,CAAMG,EAANH,CAAUI,IAExC,MAEF,KAAK,EACHH,EAAc,SAACC,EAAIC,EAAIC,EAAIC,GAAb,OAAoBL,EAAEE,EAAFF,CAAMG,EAANH,CAAUI,EAAVJ,CAAcK,IAEhD,MAEF,KAAK,EACHJ,EAAc,SAACC,EAAIC,EAAIC,EAAIC,EAAIC,GAAjB,OAAwBN,EAAEE,EAAFF,CAAMG,EAANH,CAAUI,EAAVJ,CAAcK,EAAdL,CAAkBM,IAExD,MAEF,KAAK,EACHL,EAAc,SAACC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,GAArB,OAA4BP,EAAEE,EAAFF,CAAMG,EAANH,CAAUI,EAAVJ,CAAcK,EAAdL,CAAkBM,EAAlBN,CAAsBO,IAEhE,MAEF,KAAK,EACHN,EAAc,SAACC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,GAAzB,OAAgCR,EAAEE,EAAFF,CAAMG,EAANH,CAAUI,EAAVJ,CAAcK,EAAdL,CAAkBM,EAAlBN,CAAsBO,EAAtBP,CAA0BQ,IAExE,MAEF,KAAK,EACHP,EAAc,SAACC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,GAA7B,OAAoCT,EAAEE,EAAFF,CAAMG,EAANH,CAAUI,EAAVJ,CAAcK,EAAdL,CAAkBM,EAAlBN,CAAsBO,EAAtBP,CAA0BQ,EAA1BR,CAA8BS,IAEhF,MAEF,QACE,MAAM,IAAIC,MAAM,qDAAuDX,GAI3E,OADAE,EAAW,YAAgBD,EACpBC,EAEF,SAASU,EAAMZ,EAAOC,GAC3B,GAAS,MAALA,EAAJ,CAIA,GA/DkB,gBA+DCA,EACjB,OAAOA,EAAC,YAGV,OAAQD,GACN,KAAK,EACH,OAAO,SAAAG,GAAE,OAAI,SAAAC,GAAE,OAAIH,EAAEE,EAAIC,KAE3B,KAAK,EACH,OAAO,SAAAD,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAIJ,EAAEE,EAAIC,EAAIC,MAErC,KAAK,EACH,OAAO,SAAAF,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAIL,EAAEE,EAAIC,EAAIC,EAAIC,OAE/C,KAAK,EACH,OAAO,SAAAH,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAIN,EAAEE,EAAIC,EAAIC,EAAIC,EAAIC,QAEzD,KAAK,EACH,OAAO,SAAAJ,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAIP,EAAEE,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,SAEnE,KAAK,EACH,OAAO,SAAAL,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAIR,EAAEE,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,UAE7E,KAAK,EACH,OAAO,SAAAN,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAIT,EAAEE,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,WAEvF,QACE,MAAM,IAAIC,MAAM,mDAAqDX,KAGpE,SAASa,EAAab,EAAOC,EAAGa,GACrC,GAAS,MAALb,EACF,OAAO,KACF,GAhGW,gBAgGQA,EAAG,CAC3BA,EAAIA,EAAC,YAEL,IAAK,IAAIxC,EAAI,EAAGA,EAAIqD,EAAKlD,OAAQH,IAC/BwC,EAAIA,EAAEa,EAAKrD,IAGb,OAAOwC,EAEP,OAAQD,GACN,KAAK,EAIH,OAAO,SAAAG,GAAE,OAAIF,EAAEc,MAAM,KAAMD,EAAKE,OAAO,CAACb,MAE1C,KAAK,EACH,OAAO,SAAAA,GAAE,OAAI,SAAAC,GAAE,OAAIH,EAAEc,MAAM,KAAMD,EAAKE,OAAO,CAACb,EAAIC,OAEpD,KAAK,EACH,OAAO,SAAAD,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAIJ,EAAEc,MAAM,KAAMD,EAAKE,OAAO,CAACb,EAAIC,EAAIC,QAE9D,KAAK,EACH,OAAO,SAAAF,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAIL,EAAEc,MAAM,KAAMD,EAAKE,OAAO,CAACb,EAAIC,EAAIC,EAAIC,SAExE,KAAK,EACH,OAAO,SAAAH,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAIN,EAAEc,MAAM,KAAMD,EAAKE,OAAO,CAACb,EAAIC,EAAIC,EAAIC,EAAIC,UAElF,KAAK,EACH,OAAO,SAAAJ,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAIP,EAAEc,MAAM,KAAMD,EAAKE,OAAO,CAACb,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,WAE5F,KAAK,EACH,OAAO,SAAAL,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAIR,EAAEc,MAAM,KAAMD,EAAKE,OAAO,CAACb,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,YAEtG,KAAK,EACH,OAAO,SAAAN,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAI,SAAAC,GAAE,OAAIT,EAAEc,MAAM,KAAMD,EAAKE,OAAO,CAACb,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,aAEhH,QACE,MAAM,IAAIC,MAAM,6DAA+DX,IAuChF,SAASiB,EAAgB1E,EAAKC,GACnC,GAAID,EAAIG,IAAIF,GACV,OAAOD,EAAII,IAAIH,GAEf,MAAM,IAAImE,MAAJ,yBAA4BnE,EAA5B,yCC1uBV,SAAS0E,EAASnF,EAAG0C,GACnB,OAAY,MAALA,GAAa0C,OAAOC,eAAerF,GAAGsF,cAAgBF,OAAOC,eAAe3C,GAAG4C,YAwBjF,SAASC,EAAQC,EAAMC,GAE5B,OAtBF,SAAkBC,EAAUD,GAO1BC,EAASC,UAAYP,OAAOQ,OAAOH,GAAcA,EAAWE,UAAW,CACrEL,YAAa,CACXO,MAAOH,EACPI,YAAY,EACZC,UAAU,EACVC,cAAc,KASlBC,CAAST,EAAMC,GAAcS,GACtBV,EAEF,SAASU,KAgBhB,SAASC,EAAYC,EAAMC,GACzB,GAAID,IAASC,EACX,OAAO,EAEP,GAAa,MAATA,EACF,OAAQ,EAGV,KAAoB,MAAbD,EAAKE,MAAc,CACxB,GAAkB,MAAdD,EAAMC,KACR,OAAO,EAGT,IAAMC,EAAM7C,EAAQ0C,EAAKI,KAAMH,EAAMG,MAErC,GAAY,IAARD,EACF,OAAOA,EAGTH,EAAOA,EAAKE,KACZD,EAAQA,EAAMC,KAGhB,OAAqB,MAAdD,EAAMC,KAAe,GAAK,EAI9B,SAASG,EAAKD,EAAMF,GACzBI,KAAKF,KAAOA,EACZE,KAAKJ,KAAOA,EAsCP,SAASK,EAAMC,EAAKC,GACzBH,KAAKE,IAAY,EAANA,EACXF,KAAKG,KAAOA,EAF8B,2BAARC,EAAQ,iCAARA,EAAQ,kBAG1CJ,KAAKI,OAASA,EAyChB,SAASC,EAAaC,EAAQC,GAI5B,IAHA,IAAM7F,EAAI,GACJ8F,EAAwB,MAAjBD,EAAwB7B,OAAO8B,KAAKF,GAAUC,EAAcD,GAEhEtF,EAAI,EAAGA,EAAIwF,EAAKrF,OAAQH,IAC/BN,EAAE8F,EAAKxF,IAAMsF,EAAOE,EAAKxF,IAG3B,OAAON,EAGT,SAAS+F,EAAaf,EAAMC,EAAOY,GACjC,GAAIb,IAASC,EACX,OAAO,EACF,GAAKlB,EAASiB,EAAMC,GAEpB,CAGL,IAFA,IAAMe,EAA6B,MAAjBH,EAAwB7B,OAAO8B,KAAKd,GAAQa,EAAcb,GAEnE1E,EAAI,EAAGA,EAAI0F,EAAUvF,OAAQH,IACpC,IAAKmB,EAAOuD,EAAKgB,EAAU1F,IAAK2E,EAAMe,EAAU1F,KAC9C,OAAO,EAIX,OAAO,EAVP,OAAO,EAcX,SAAS2F,EAAcjB,EAAMC,EAAOY,GAClC,GAAIb,IAASC,EACX,OAAO,EACF,GAAKlB,EAASiB,EAAMC,GAEpB,CAGL,IAFA,IAAMe,EAA6B,MAAjBH,EAAwB7B,OAAO8B,KAAKd,GAAQa,EAAcb,GAEnE1E,EAAI,EAAGA,EAAI0F,EAAUvF,OAAQH,IAAK,CACzC,IAAM4F,EAAS5D,EAAQ0C,EAAKgB,EAAU1F,IAAK2E,EAAMe,EAAU1F,KAE3D,GAAe,IAAX4F,EACF,OAAOA,EAIX,OAAO,EAZP,OAAQ,EAgBL,SAASC,KA5KhBrB,EAAaP,UAAU6B,SAAW,WAAa,IAAD,OAC5C,MAAO,IAAMpC,OAAO8B,KAAKR,MAAMlG,KAAI,SAAAiH,GAAC,OAAIA,EAAI,MAAQjF,OAAO,EAAKiF,OAAKC,KAAK,QAAU,KAGtFxB,EAAaP,UAAUrD,YAAc,WACnC,ODuJK,SAAsBtC,GAC3B,GAAS,MAALA,EACF,OAAO,EAGT,cAAeA,GACb,IAAK,UACH,OAAOA,EAAI,EAAI,EAEjB,IAAK,SACH,OAAO+B,EAAW/B,GAEpB,IAAK,SACH,OAAOwB,EAAWxB,GAEpB,QACE,OAAO+B,EAAWZ,EAAUwG,GAAG3H,KCvK5B4H,CAAalB,OAGtBR,EAAaP,UAAU7C,OAAS,SAAUuD,GACxC,OAAOK,OAASL,GAmClBI,EAAKd,UAAU6B,SAAW,WACxB,MAAO,IAAMvH,MAAM4H,KAAKnB,MAAMlG,KAAI,SAAAR,GAAC,OAAIwC,OAAOxC,MAAI0H,KAAK,MAAQ,KAGjEjB,EAAKd,UAAUmC,OAAS,WACtB,OAAO7H,MAAM4H,KAAKnB,OAGpBD,EAAKd,UAAUoC,OAAOC,UAAY,WAChC,IAAIC,EAAMvB,KACV,MAAO,CACLwB,KAAM,WACJ,IAAMC,EAAMF,EAEZ,OADAA,EAAMA,EAAI3B,KACH,CACL8B,KAAkB,MAAZD,EAAI7B,KACVT,MAAOsC,EAAI3B,SAMnBC,EAAKd,UAAUrD,YAAc,WAE3B,OAAON,EADQ/B,MAAM4H,KAAKnB,MAAMlG,IAAI6B,KAItCoE,EAAKd,UAAU7C,OAAS,SAAUuD,GAChC,OAAoC,IAA7BF,EAAYO,KAAML,IAG3BI,EAAKd,UAAUhC,UAAY,SAAU0C,GACnC,OAAOF,EAAYO,KAAML,IAS3BM,EAAMhB,UAAU6B,SAAW,WACzB,IAAM5F,EAAM8E,KAAKI,OAAOjF,OAExB,OAAY,IAARD,EACK8E,KAAKG,KACK,IAARjF,EACF8E,KAAKG,KAAO,IAAMrE,OAAOkE,KAAKI,OAAO,IAErCJ,KAAKG,KAAO,KAAOH,KAAKI,OAAOtG,KAAI,SAAAR,GAAC,OAAIwC,OAAOxC,MAAI0H,KAAK,KAAO,KAI1Ef,EAAMhB,UAAUmC,OAAS,WACvB,OAA8B,IAAvBpB,KAAKI,OAAOjF,OAAe6E,KAAKG,KAAO,CAACH,KAAKG,MAAM5B,OAAOyB,KAAKI,SAGxEH,EAAMhB,UAAUrD,YAAc,WAC5B,IAAML,EAASyE,KAAKI,OAAOtG,KAAI,SAAAR,GAAC,OAAIqC,EAAerC,MAEnD,OADAiC,EAAOoG,OAAO,EAAG,EAAGtG,EAAW2E,KAAKE,MAC7B5E,EAAiBC,IAG1B0E,EAAMhB,UAAU7C,OAAS,SAAUuD,GACjC,OAAOK,OAASL,GAASlB,EAASuB,KAAML,IAAUK,KAAKE,MAAQP,EAAMO,KAAOhE,EAAY8D,KAAKI,OAAQT,EAAMS,SAG7GH,EAAMhB,UAAUhC,UAAY,SAAU0C,GACpC,OAAIK,OAASL,EACJ,EACGlB,EAASuB,KAAML,GAEhBK,KAAKE,MAAQP,EAAMO,IACrBnD,EAAciD,KAAKI,OAAQT,EAAMS,QAEjCJ,KAAKE,IAAMP,EAAMO,KAAO,EAAI,GAJ3B,GA6DZW,EAAO5B,UAAU6B,SAAW,WAAa,IAAD,OACtC,MAAO,IAAMpC,OAAO8B,KAAKR,MAAMlG,KAAI,SAAAiH,GAAC,OAAIA,EAAI,MAAQjF,OAAO,EAAKiF,OAAKC,KAAK,QAAU,KAGtFH,EAAO5B,UAAUmC,OAAS,WACxB,OAAOf,EAAaL,OAGtBa,EAAO5B,UAAUrD,YAAc,WAAa,IAAD,OAEzC,OAAON,EADQoD,OAAO8B,KAAKR,MAAMlG,KAAI,SAAAiH,GAAC,OAAIpF,EAAe,EAAKoF,SAIhEF,EAAO5B,UAAU7C,OAAS,SAAUuD,GAClC,OAAOc,EAAaT,KAAML,IAG5BkB,EAAO5B,UAAUhC,UAAY,SAAU0C,GACrC,OAAOgB,EAAcX,KAAML,IAMtB,IAAMiC,EAAY/C,GAAQ,SAAmBgD,GAClD7B,KAAK6B,SAAWA,IACfhB,GACUiB,EAAYjD,GAAQ,SAAmBkD,GAClD/B,KAAKgC,MAAQ9D,QAAQ8D,MACrBhC,KAAK+B,QAAUA,IACdvC,GAKH,SAASyC,EAA6BvC,GACpC,OAAOhB,OAAO8B,KAAKd,GAAMwC,QAAO,SAAAnB,GAAC,MAAU,YAANA,GAAyB,UAANA,KAGnD,IAAMoB,EAAkBtD,GAAQ,WACrCiD,EAAUM,KAAKpC,QACd8B,GAEHK,EAAgBlD,UAAU6B,SAAW,WAAa,IAAD,OACzCuB,EAAaJ,EAA6BjC,MAC1C9E,EAAMmH,EAAWlH,OAEvB,OAAY,IAARD,EACK8E,KAAK+B,QACK,IAAR7G,EACF8E,KAAK+B,QAAU,IAAMjG,OAAOkE,KAAKqC,EAAW,KAE5CrC,KAAK+B,QAAU,KAAOM,EAAWvI,KAAI,SAAAiH,GAAC,OAAIjF,OAAO,EAAKiF,OAAKC,KAAK,KAAO,KAIlFmB,EAAgBlD,UAAUmC,OAAS,WACjC,OAAOf,EAAaL,KAAMiC,IAG5BE,EAAgBlD,UAAUrD,YAAc,WAAa,IAAD,OAElD,OAAON,EADQ2G,EAA6BjC,MAAMlG,KAAI,SAAAiH,GAAC,OAAIpF,EAAe,EAAKoF,SAIjFoB,EAAgBlD,UAAU7C,OAAS,SAAUuD,GAC3C,OAAOc,EAAaT,KAAML,EAAOsC,IAGnCE,EAAgBlD,UAAUhC,UAAY,SAAU0C,GAC9C,OAAOgB,EAAcX,KAAML,EAAOsC,IAGCpD,GAAQ,SAA+ByD,EAAMC,EAAMC,GACtFxC,KAAKsC,KAAOA,EACZtC,KAAKuC,KAAc,EAAPA,EACZvC,KAAKwC,KAAc,EAAPA,EACZxC,KAAK+B,QAAU,oCACdI,GACsBtD,GAAQ,cAE9BW,G,YARI,I,OClRMiD,EAAb,WACE,WAAYC,EAAUC,EAAU/D,EAAawB,EAAQwC,EAAOC,GAAY,oBACtE7C,KAAK0C,SAAWA,EAChB1C,KAAK2C,SAAWA,EAChB3C,KAAKpB,YAAcA,EACnBoB,KAAKI,OAASA,EACdJ,KAAK4C,MAAQA,EACb5C,KAAK6C,UAAYA,EAPrB,uDAWI,OA0FG,SAASC,EAASC,GACvB,IAAMC,EAAoB,MAAdD,EAAEJ,UAAqBnJ,EAAQuJ,GAAkB,GAAbA,EAAEJ,SAElD,OAAIK,EAAI7H,OAAS,EACR4H,EAAEL,SAAW,IAAMM,EAAIlJ,KAAI,SAAAR,GAAC,OAAIwJ,EAASxJ,MAAI0H,KAAK,KAAO,IAEzD+B,EAAEL,SAhGFI,CAAS9C,QAXpB,6BAcSL,GACL,OAAOxD,EAAO6D,KAAML,KAfxB,gCAkBYA,GACR,OAAO3C,EAAQgD,KAAML,OAnBzB,KAuBO,SAASsD,EAAYF,GAC1B,OAAqB,MAAdA,EAAEJ,SAAmBI,EAAEJ,SAAW,GAEpC,SAASxG,EAAO+G,EAAIC,GACzB,MAAoB,KAAhBD,EAAGR,SAEkB,KAAhBS,EAAGT,UAAmB3G,EAAgBqH,EAAkBF,GAAKE,EAAkBD,IAAK,qCAAEE,EAAF,KAAMC,EAAN,wBAAYC,EAAZ,KAAgBC,EAAhB,YAAwBH,IAAOE,GAAMpH,EAAOmH,EAAIE,MAEpIN,EAAGR,WAAaS,EAAGT,UAAY3G,EAAgBkH,EAAYC,GAAKD,EAAYE,GAAKhH,GAKrF,SAASa,EAAQkG,EAAIC,GAC1B,OAAID,EAAGR,WAAaS,EAAGT,SACdQ,EAAGR,SAAWS,EAAGT,UAAY,EAAI,EAEjC9F,EAAkBqG,EAAYC,GAAKD,EAAYE,GAAKnG,GAqC5C,IAAIyF,EAAS,iBACZ,IAAIA,EAAS,8BACb,IAAIA,EAAS,eACX,IAAIA,EAAS,iBACf,IAAIA,EAAS,kBACb,IAAIA,EAAS,gBACZ,IAAIA,EAAS,eACb,IAAIA,EAAS,gBACZ,IAAIA,EAAS,iBACd,IAAIA,EAAS,gBACZ,IAAIA,EAAS,iBACZ,IAAIA,EAAS,iBACb,IAAIA,EAAS,iBACb,IAAIA,EAAS,kBAwB7B,SAASjJ,EAAQuJ,GACtB,OAAOA,EAAEL,SAASe,SAAS,MAoGtB,SAASL,EAAkBL,GAChC,GAAgB,MAAZA,EAAE3C,OACJ,OAAO2C,EAAE3C,SAET,MAAM,IAAIlC,MAAJ,UAAa6E,EAAEL,SAAf,8BCpOH,IAAMgB,EAAO7E,GAAQ,SAAmCqB,EAAKC,GAAkB,IAAD,uBAARC,EAAQ,iCAARA,EAAQ,kBACnFH,EAAMmC,KAAN,MAAAnC,EAAK,CAAMD,KAAME,EAAKC,GAAjB,OAA0BC,MAC9BH,GAII,IAAM0D,GAAQ9E,GAAQ,SAAoCyD,EAAMC,EAAMC,GAC3ExC,KAAK4D,OAAStB,EACdtC,KAAK6D,mBAAqBtB,EAC1BvC,KAAK0D,KAAOlB,IACX3B,GAII,IAAMiD,GAAMjF,GAAQ,SAAkCqB,EAAKC,GAAkB,IAAD,uBAARC,EAAQ,iCAARA,EAAQ,kBACjFH,EAAMmC,KAAN,MAAAnC,EAAK,CAAMD,KAAME,EAAKC,GAAjB,OAA0BC,MAC9BH,GCfI,IAAM8D,GAAb,WACE,WAAY5E,GAAQ,oBAClBa,KAAKb,MAAQA,EAFjB,uDAOI,OAAOrD,OAAOkE,KAAKb,SAPvB,+BAWI,OAAOa,KAAKb,QAXhB,oCAeI,OAAOxD,EAAeqE,KAAKb,SAf/B,6BAkBSQ,GACL,OAAa,MAATA,GAGKxD,EAAO6D,KAAKb,MAAOQ,aAAiBoE,EAAOpE,EAAMR,MAAQQ,KAtBtE,gCA0BYA,GACR,OAAa,MAATA,EACK,EAEA3C,EAAQgD,KAAKb,MAAOQ,aAAiBoE,EAAOpE,EAAMR,MAAQQ,OA9BvE,KAmCO,SAASqE,GAAK1K,GAEnB,OAAY,OADZA,OAAU2K,IAAN3K,EAAkB,KAAOA,IACTA,aAAayK,GAAO,IAAIA,GAAKzK,GAAKA,EAEjD,SAAS6F,GAAM7F,EAAG4K,GACvB,GAAS,MAAL5K,EAAW,CACb,IAAK4K,EACH,MAAM,IAAIhG,MAAM,uBAGlB,OAAO,KAEP,OAAO5E,aAAayK,GAAOzK,EAAE6F,MAAQ7F,EA4BnBuF,GAAQ,SAAgBqB,EAAKC,EAAMgE,GACvDlE,EAAMmC,KAAKpC,KAAME,EAAKC,EAAMgE,KAC3BlE,GAamBpB,GAAQ,SAAgBqB,EAAKC,EAAMgE,GACvDlE,EAAMmC,KAAKpC,KAAME,EAAKC,EAAMgE,KAC3BlE,G,YC1FCmE,GAAI,CACNxI,YADM,WAEJ,OAAON,EAAiB,CAAC0E,KAAKjF,EAAGiF,KAAKqE,GAAG9F,OAAOyB,KAAKsE,KAGvDlI,OALM,SAKC9C,GACL,OAAQ0G,KAAKuE,IAAIjL,IAGnB2D,UATM,SASI3D,GACR,OAAO0G,KAAKuE,IAAIjL,KA0DpBkL,GAAO,YACHC,GAAUD,GAAO,WACjBE,GAAaD,GAAU,iBAIvBE,GAAU,uCA6Dd,SAASC,GAAMtL,EAAGuL,GAChB,IAAIR,EAAGrJ,EAAG8J,EAEV,GAAU,IAAND,GAAW,EAAIA,EAAI,EAAGA,EAAI,UAAU,IAAKF,GAAQI,KAAKF,GAAK,IAAK,MAAM3G,MAAMuG,GAAU,UAkB1F,IAhBAnL,EAAEyB,EAAmB,KAAf8J,EAAEG,OAAO,IAAaH,EAAIA,EAAEI,MAAM,IAAK,GAAK,GAE7CZ,EAAIQ,EAAEK,QAAQ,OAAS,IAAGL,EAAIA,EAAEM,QAAQ,IAAK,MAE7CnK,EAAI6J,EAAEO,OAAO,OAAS,GAErBf,EAAI,IAAGA,EAAIrJ,GACfqJ,IAAMQ,EAAEI,MAAMjK,EAAI,GAClB6J,EAAIA,EAAEQ,UAAU,EAAGrK,IACVqJ,EAAI,IAEbA,EAAIQ,EAAE1J,QAGR2J,EAAKD,EAAE1J,OAEFH,EAAI,EAAGA,EAAIqJ,GAAKrJ,EAAI8J,GAAqB,KAAfD,EAAEG,OAAOhK,MAAcA,EAKtD,GAAIA,GAAK8J,EAEPxL,EAAEgL,EAAI,CAAChL,EAAE+K,EAAI,QAKb,IAHA/K,EAAE+K,EAAIA,EAAIrJ,EAAI,EACd1B,EAAEgL,EAAI,GAEDD,EAAI,EAAGrJ,EAAI8J,GAAKxL,EAAEgL,EAAED,MAAQQ,EAAEG,OAAOhK,KAS5C,OADA1B,EAAIgM,GAAMhM,EAAGiM,GAAIC,GAAID,GAAIE,IAc3B,SAASH,GAAMhM,EAAGoM,EAAIC,EAAIC,GACxB,IAAIC,EAAKvM,EAAEgL,EACPtJ,EAAI1B,EAAE+K,EAAIqB,EAAK,EAEnB,GAAI1K,EAAI6K,EAAG1K,OAAQ,CACjB,GAAW,IAAPwK,EAEFC,EAAOC,EAAG7K,IAAM,OACX,GAAW,IAAP2K,EACTC,EAAOC,EAAG7K,GAAK,GAAc,GAAT6K,EAAG7K,KAAY4K,GAAQ5K,EAAI,QA9HrC,IA8H0C6K,EAAG7K,EAAI,IAAgC,EAAZ6K,EAAG7K,EAAI,SACjF,GAAW,IAAP2K,EACTC,EAAOA,KAAUC,EAAG,QAGpB,GADAD,GAAO,EACI,IAAPD,EAAU,MAAMzH,MArITuG,kCAwIb,GAAIzJ,EAAI,EACN6K,EAAG1K,OAAS,EAERyK,GAEFtM,EAAE+K,GAAKqB,EACPG,EAAG,GAAK,GAGRA,EAAG,GAAKvM,EAAE+K,EAAI,MAEX,CAIL,GAFAwB,EAAG1K,OAASH,IAER4K,EAEF,OAASC,EAAG7K,GAAK,GACf6K,EAAG7K,GAAK,EAEHA,QACD1B,EAAE+K,EACJwB,EAAGC,QAAQ,IAMjB,IAAK9K,EAAI6K,EAAG1K,QAAS0K,IAAK7K,IAAK6K,EAAGE,YAE/B,GAAIJ,EAAK,GAAKA,EAAK,GAAKA,MAASA,EACtC,MAAMzH,MAvKOuG,kCA0Kf,OAAOnL,EAiBT,SAAS0M,GAAU1M,EAAG2H,EAAI4D,EAAG9D,GAC3B,IAAIsD,EACAtJ,EACAwK,EAAMjM,EAAEsF,YACRqH,GAAK3M,EAAEgL,EAAE,GAEb,QA/Lc,IA+LVO,EAAiB,CACnB,GAAIA,MAAQA,GAAKA,GAAW,GAAN5D,IAAY4D,EA9N7B,IA+NH,MAAM3G,MAAY,GAAN+C,EAAUwD,GAAU,YAAcC,IAWhD,IANAG,EAAI9D,GAFJzH,EAAI,IAAIiM,EAAIjM,IAEF+K,EAEN/K,EAAEgL,EAAEnJ,SAAW4F,GAAGuE,GAAMhM,EAAGuL,EAAGU,EAAIE,IAE5B,GAANxE,IAASF,EAAIzH,EAAE+K,EAAIQ,EAAI,GAEpBvL,EAAEgL,EAAEnJ,OAAS4F,GAAIzH,EAAEgL,EAAE4B,KAAK,GAOnC,GAJA7B,EAAI/K,EAAE+K,EAENQ,GADA9J,EAAIzB,EAAEgL,EAAEtD,KAAK,KACP7F,OAEI,GAAN8F,IAAkB,GAANA,GAAiB,GAANA,GAAWF,GAAKsD,GAAKA,GAAKkB,EAAIY,IAAM9B,GAAKkB,EAAIa,IACtErL,EAAIA,EAAEiK,OAAO,IAAMH,EAAI,EAAI,IAAM9J,EAAEkK,MAAM,GAAK,KAAOZ,EAAI,EAAI,IAAM,MAAQA,OACtE,GAAIA,EAAI,EAAG,CAChB,OAASA,GAAItJ,EAAI,IAAMA,EAEvBA,EAAI,KAAOA,OACN,GAAIsJ,EAAI,EACb,KAAMA,EAAIQ,EAAG,IAAKR,GAAKQ,EAAGR,KAAMtJ,GAAK,SAAasJ,EAAIQ,IAAG9J,EAAIA,EAAEkK,MAAM,EAAGZ,GAAK,IAAMtJ,EAAEkK,MAAMZ,SAClFQ,EAAI,IACb9J,EAAIA,EAAEiK,OAAO,GAAK,IAAMjK,EAAEkK,MAAM,IAGlC,OAAO3L,EAAEyB,EAAI,KAAOkL,GAAW,GAANhF,GAAW,IAAMlG,EAAIA,EAQhDqJ,GAAEiC,IAAM,WACN,IAAI/M,EAAI,IAAI0G,KAAKpB,YAAYoB,MAE7B,OADA1G,EAAEyB,EAAI,EACCzB,GAST8K,GAAEG,IAAM,SAAUvI,GAChB,IAAIsK,EACAf,EAAMvF,KAAKpB,YACXtF,EAAI,IAAIiM,EAAIvF,MAEZ6F,GADA7J,EAAI,IAAIuJ,EAAIvJ,GACP1C,EAAEgL,GACPiC,EAAKvK,EAAEsI,EACPtJ,EAAI1B,EAAEyB,EACN+B,EAAId,EAAEjB,EACNgG,EAAIzH,EAAE+K,EACNmC,EAAIxK,EAAEqI,EAEV,IAAKwB,EAAG,KAAOU,EAAG,GAAI,OAAQV,EAAG,GAAuB7K,EAAjBuL,EAAG,IAAUzJ,EAAL,EAE/C,GAAI9B,GAAK8B,EAAG,OAAO9B,EAGnB,GAFAsL,EAAQtL,EAAI,EAER+F,GAAKyF,EAAG,OAAOzF,EAAIyF,EAAIF,EAAQ,GAAK,EAIxC,IAFAxJ,EAAI2J,KAAKtJ,IAAI0I,EAAG1K,OAAQoL,EAAGpL,QAEtBH,EAAI,EAAGA,EAAI8B,EAAG9B,IAGjB,IAFA+F,EAAI/F,EAAI6K,EAAG1K,OAAS0K,EAAG7K,GAAK,KAC5BwL,EAAIxL,EAAIuL,EAAGpL,OAASoL,EAAGvL,GAAK,GAChB,OAAO+F,EAAIyF,EAAIF,EAAQ,GAAK,EAG1C,OAAO,GAeTlC,GAAEsC,IAAM,SAAU1K,GAChB,IAAIuJ,EAAMvF,KAAKpB,YACXtF,EAAI,IAAIiM,EAAIvF,MAEZ2G,GADA3K,EAAI,IAAIuJ,EAAIvJ,GACR1C,EAAEgL,GAEVsC,EAAI5K,EAAEsI,EAENvD,EAAIzH,EAAEyB,GAAKiB,EAAEjB,EAAI,GAAK,EAClB2K,EAAKH,EAAIC,GACb,GAAIE,MAASA,GAAMA,EAAK,GAAKA,EArUtB,IAqUmC,MAAMxH,MAAMwG,IAEtD,IAAKkC,EAAE,GAAI,MAAM1I,MA1SDsG,6BA4ShB,IAAKmC,EAAE,GAAI,OAAO,IAAIpB,EAAQ,EAAJxE,GAC1B,IAAI8F,EACAC,EACAjC,EACAN,EACAwC,EACAC,EAAKJ,EAAE3B,QACPgC,EAAKJ,EAAKD,EAAEzL,OACZ+L,EAAKP,EAAExL,OACPgM,EAAIR,EAAE1B,MAAM,EAAG4B,GAEnBO,EAAKD,EAAEhM,OACHkM,EAAIrL,EAERsL,EAAKD,EAAE/C,EAAI,GACPiD,EAAK,EACLC,EAAI9B,GAAM2B,EAAEhD,EAAI/K,EAAE+K,EAAIrI,EAAEqI,GAAK,EAOjC,IALAgD,EAAEtM,EAAIgG,EACNA,EAAIyG,EAAI,EAAI,EAAIA,EAEhBR,EAAGlB,QAAQ,GAEJsB,IAAOP,GAAKM,EAAEjB,KAAK,GAE1B,EAAG,CAED,IAAKrB,EAAI,EAAGA,EAAI,GAAIA,IAAK,CAEvB,GAAIgC,IAAOO,EAAKD,EAAEhM,QAChBoJ,EAAMsC,EAAKO,EAAK,GAAK,OAErB,IAAKL,GAAM,EAAGxC,EAAM,IAAKwC,EAAKF,GAC5B,GAAID,EAAEG,IAAOI,EAAEJ,GAAK,CAClBxC,EAAMqC,EAAEG,GAAMI,EAAEJ,GAAM,GAAK,EAC3B,MAMN,KAAIxC,EAAM,GAkBR,MAfA,IAAKuC,EAAKM,GAAMP,EAAKD,EAAII,EAAII,GAAK,CAChC,GAAID,IAAIC,GAAMN,EAAGM,GAAK,CAGpB,IAFAL,EAAKK,EAEEL,IAAOI,IAAIJ,IAAMI,EAAEJ,GAAM,IAE9BI,EAAEJ,GACJI,EAAEC,IAAO,GAGXD,EAAEC,IAAON,EAAGM,GAGd,MAAQD,EAAE,IAAKA,EAAEM,QAOrBH,EAAGC,KAAQhD,EAAMM,IAAMA,EAEnBsC,EAAE,IAAM5C,EAAK4C,EAAEC,GAAMT,EAAEM,IAAO,EAAOE,EAAI,CAACR,EAAEM,WACxCA,IAAOC,QA9WH,IA8WSC,EAAE,KAAqBpG,KAW9C,OARKuG,EAAG,IAAY,GAANC,IAEZD,EAAGG,QACHJ,EAAEhD,KAIAkD,EAAKC,GAAGlC,GAAM+B,EAAG3B,EAAIH,EAAIE,QAxXf,IAwXmB0B,EAAE,IAC5BE,GAOTjD,GAAEnI,GAAK,SAAUD,GACf,OAAQgE,KAAKuE,IAAIvI,IAQnBoI,GAAEsD,GAAK,SAAU1L,GACf,OAAOgE,KAAKuE,IAAIvI,GAAK,GAQvBoI,GAAEuD,IAAM,SAAU3L,GAChB,OAAOgE,KAAKuE,IAAIvI,IAAM,GAOxBoI,GAAEwD,GAAK,SAAU5L,GACf,OAAOgE,KAAKuE,IAAIvI,GAAK,GAQvBoI,GAAEyD,IAAM,SAAU7L,GAChB,OAAOgE,KAAKuE,IAAIvI,GAAK,GAOvBoI,GAAE0D,MAAQ1D,GAAE2D,IAAM,SAAU/L,GAC1B,IAAIhB,EACA8B,EACAiG,EACAiF,EACAzC,EAAMvF,KAAKpB,YACXtF,EAAI,IAAIiM,EAAIvF,MAEZ2G,GADA3K,EAAI,IAAIuJ,EAAIvJ,GACR1C,EAAEyB,GACN6L,EAAI5K,EAAEjB,EAEV,GAAI4L,GAAKC,EAEP,OADA5K,EAAEjB,GAAK6L,EACAtN,EAAE2O,KAAKjM,GAGhB,IAAI6J,EAAKvM,EAAEgL,EAAEW,QACTiD,EAAK5O,EAAE+K,EACPkC,EAAKvK,EAAEsI,EACP6D,EAAKnM,EAAEqI,EAEX,IAAKwB,EAAG,KAAOU,EAAG,GAEhB,OAAOA,EAAG,IAAMvK,EAAEjB,GAAK6L,EAAG5K,GAAK,IAAIuJ,EAAIM,EAAG,GAAKvM,EAAI,GAIrD,GAAIqN,EAAIuB,EAAKC,EAAI,CAWf,KAVIH,EAAOrB,EAAI,IACbA,GAAKA,EACL5D,EAAI8C,IAEJsC,EAAKD,EACLnF,EAAIwD,GAGNxD,EAAEqF,UAEGxB,EAAID,EAAGC,KAAM7D,EAAEmD,KAAK,GAEzBnD,EAAEqF,eAKF,IAFAtL,IAAMkL,EAAOnC,EAAG1K,OAASoL,EAAGpL,QAAU0K,EAAKU,GAAIpL,OAE1CwL,EAAIC,EAAI,EAAGA,EAAI9J,EAAG8J,IACrB,GAAIf,EAAGe,IAAML,EAAGK,GAAI,CAClBoB,EAAOnC,EAAGe,GAAKL,EAAGK,GAClB,MAkBN,GAZIoB,IACFjF,EAAI8C,EACJA,EAAKU,EACLA,EAAKxD,EACL/G,EAAEjB,GAAKiB,EAAEjB,IAQN6L,GAAK9J,EAAIyJ,EAAGpL,SAAWH,EAAI6K,EAAG1K,SAAW,EAAG,KAAOyL,KAAMf,EAAG7K,KAAO,EAExE,IAAK4L,EAAI5L,EAAG8B,EAAI6J,GAAI,CAClB,GAAId,IAAK/I,GAAKyJ,EAAGzJ,GAAI,CACnB,IAAK9B,EAAI8B,EAAG9B,IAAM6K,IAAK7K,IAAK6K,EAAG7K,GAAK,IAElC6K,EAAG7K,GACL6K,EAAG/I,IAAM,GAGX+I,EAAG/I,IAAMyJ,EAAGzJ,GAId,KAAmB,IAAZ+I,IAAKe,IAAWf,EAAGE,MAG1B,KAAiB,IAAVF,EAAG,IACRA,EAAG4B,UACDU,EAYJ,OATKtC,EAAG,KAEN7J,EAAEjB,EAAI,EAEN8K,EAAK,CAACsC,EAAK,IAGbnM,EAAEsI,EAAIuB,EACN7J,EAAEqI,EAAI8D,EACCnM,GAOToI,GAAEiE,IAAM,SAAUrM,GAChB,IAAIsM,EACA/C,EAAMvF,KAAKpB,YACXtF,EAAI,IAAIiM,EAAIvF,MAEZ2G,GADA3K,EAAI,IAAIuJ,EAAIvJ,GACR1C,EAAEyB,GACN6L,EAAI5K,EAAEjB,EACV,IAAKiB,EAAEsI,EAAE,GAAI,MAAMpG,MA3hBHsG,6BAgiBhB,OAJAlL,EAAEyB,EAAIiB,EAAEjB,EAAI,EACZuN,EAAmB,GAAZtM,EAAEuI,IAAIjL,GACbA,EAAEyB,EAAI4L,EACN3K,EAAEjB,EAAI6L,EACF0B,EAAa,IAAI/C,EAAIjM,IACzBqN,EAAIpB,EAAIC,GACRoB,EAAIrB,EAAIE,GACRF,EAAIC,GAAKD,EAAIE,GAAK,EAClBnM,EAAIA,EAAEoN,IAAI1K,GACVuJ,EAAIC,GAAKmB,EACTpB,EAAIE,GAAKmB,EACF5G,KAAK8H,MAAMxO,EAAEiP,MAAMvM,MAO5BoI,GAAE6D,KAAO7D,GAAEoE,IAAM,SAAUxM,GACzB,IAAI+G,EACAwC,EAAMvF,KAAKpB,YACXtF,EAAI,IAAIiM,EAAIvF,MAEZ2G,GADA3K,EAAI,IAAIuJ,EAAIvJ,GACR1C,EAAEyB,GACN6L,EAAI5K,EAAEjB,EAEV,GAAI4L,GAAKC,EAEP,OADA5K,EAAEjB,GAAK6L,EACAtN,EAAEwO,MAAM9L,GAGjB,IAAIkM,EAAK5O,EAAE+K,EACPwB,EAAKvM,EAAEgL,EACP6D,EAAKnM,EAAEqI,EACPkC,EAAKvK,EAAEsI,EAEX,IAAKuB,EAAG,KAAOU,EAAG,GAAI,OAAOA,EAAG,GAAKvK,EAAI,IAAIuJ,EAAIM,EAAG,GAAKvM,EAAQ,EAAJqN,GAI7D,GAHAd,EAAKA,EAAGZ,QAGJ0B,EAAIuB,EAAKC,EAAI,CAWf,IAVIxB,EAAI,GACNwB,EAAKD,EACLnF,EAAIwD,IAEJI,GAAKA,EACL5D,EAAI8C,GAGN9C,EAAEqF,UAEKzB,KAAM5D,EAAEmD,KAAK,GAEpBnD,EAAEqF,UAYJ,IARIvC,EAAG1K,OAASoL,EAAGpL,OAAS,IAC1B4H,EAAIwD,EACJA,EAAKV,EACLA,EAAK9C,GAGP4D,EAAIJ,EAAGpL,OAEFyL,EAAI,EAAGD,EAAGd,EAAGc,IAAM,GAAIC,GAAKf,IAAKc,GAAKd,EAAGc,GAAKJ,EAAGI,GAAKC,GAAK,GAAK,EASrE,IANIA,IACFf,EAAGC,QAAQc,KACTuB,GAICxB,EAAId,EAAG1K,OAAoB,IAAZ0K,IAAKc,IAAWd,EAAGE,MAIvC,OAFA/J,EAAEsI,EAAIuB,EACN7J,EAAEqI,EAAI8D,EACCnM,GAWToI,GAAEqE,IAAM,SAAU5D,GAChB,IAAIU,EAAMvF,KAAKpB,YACXtF,EAAI,IAAIiM,EAAIvF,MACZhE,EAAI,IAAIuJ,EAAI,GACZmD,EAAM,IAAInD,EAAI,GACde,EAAQzB,EAAI,EAChB,GAAIA,MAAQA,GAAKA,GArpBP,KAqpByBA,EArpBzB,IAqpBwC,MAAM3G,MAAMuG,GAAU,YAGxE,IAFI6B,IAAOzB,GAAKA,GAGN,EAAJA,IAAO7I,EAAIA,EAAEuM,MAAMjP,IACvBuL,IAAM,GAENvL,EAAIA,EAAEiP,MAAMjP,GAGd,OAAOgN,EAAQoC,EAAIhC,IAAI1K,GAAKA,GAc9BoI,GAAEkB,MAAQ,SAAUI,EAAIC,GACtB,IAAIJ,EAAMvF,KAAKpB,YACf,QAppBc,IAopBV8G,EAAkBA,EAAK,OAAO,GAAIA,MAASA,GAAMA,GAlrB9C,KAkrB8DA,EAlrB9D,IAkrB2E,MAAMxH,MAAMwG,IAC9F,OAAOY,GAAM,IAAIC,EAAIvF,MAAO0F,OArpBd,IAqpBkBC,EAAmBJ,EAAIE,GAAKE,IAQ9DvB,GAAEuE,KAAO,WACP,IAAIxB,EACA7C,EACAvB,EACAwC,EAAMvF,KAAKpB,YACXtF,EAAI,IAAIiM,EAAIvF,MACZjF,EAAIzB,EAAEyB,EACNsJ,EAAI/K,EAAE+K,EACNuE,EAAO,IAAIrD,EAAI,IAEnB,IAAKjM,EAAEgL,EAAE,GAAI,OAAO,IAAIiB,EAAIjM,GAE5B,GAAIyB,EAAI,EAAG,MAAMmD,MAAMsG,GAAO,kBAKpB,KAHVzJ,EAAI0L,KAAKkC,KAAKrP,EAAI,MAGHyB,IAAM,MACnBuJ,EAAIhL,EAAEgL,EAAEtD,KAAK,KACL7F,OAASkJ,EAAI,IAAIC,GAAK,KAE9BD,IAAMA,EAAI,GAAK,EAAI,IAAMA,EAAI,GAAS,EAAJA,GAClC8C,EAAI,IAAI5B,IAFRxK,EAAI0L,KAAKkC,KAAKrE,KAEI,IAAQ,MAAQvJ,EAAIA,EAAE8N,iBAAiB5D,MAAM,EAAGlK,EAAEmK,QAAQ,KAAO,IAAMb,IAEzF8C,EAAI,IAAI5B,EAAIxK,GAGdsJ,EAAI8C,EAAE9C,GAAKkB,EAAIC,IAAM,GAErB,GACEzC,EAAIoE,EACJA,EAAIyB,EAAKL,MAAMxF,EAAEkF,KAAK3O,EAAEoN,IAAI3D,WACrBA,EAAEuB,EAAEW,MAAM,EAAGZ,GAAGrD,KAAK,MAAQmG,EAAE7C,EAAEW,MAAM,EAAGZ,GAAGrD,KAAK,KAE3D,OAAOsE,GAAM6B,EAAG5B,EAAIC,IAAM,EAAGD,EAAIE,KAOnCrB,GAAEmE,MAAQnE,GAAE0E,IAAM,SAAU9M,GAC1B,IAAIsI,EACAiB,EAAMvF,KAAKpB,YACXtF,EAAI,IAAIiM,EAAIvF,MAEZ6F,GADA7J,EAAI,IAAIuJ,EAAIvJ,GACP1C,EAAEgL,GACPiC,EAAKvK,EAAEsI,EACPqC,EAAId,EAAG1K,OACPyL,EAAIL,EAAGpL,OACPH,EAAI1B,EAAE+K,EACNvH,EAAId,EAAEqI,EAIV,GAFArI,EAAEjB,EAAIzB,EAAEyB,GAAKiB,EAAEjB,EAAI,GAAK,GAEnB8K,EAAG,KAAOU,EAAG,GAAI,OAAO,IAAIhB,EAAU,EAANvJ,EAAEjB,GAcvC,IAZAiB,EAAEqI,EAAIrJ,EAAI8B,EAEN6J,EAAIC,IACNtC,EAAIuB,EACJA,EAAKU,EACLA,EAAKjC,EACLxH,EAAI6J,EACJA,EAAIC,EACJA,EAAI9J,GAIDwH,EAAI,IAAI/K,MAAMuD,EAAI6J,EAAIC,GAAI9J,KAAMwH,EAAExH,GAAK,EAI5C,IAAK9B,EAAI4L,EAAG5L,KAAM,CAGhB,IAFA4L,EAAI,EAEC9J,EAAI6J,EAAI3L,EAAG8B,EAAI9B,GAElB4L,EAAItC,EAAExH,GAAKyJ,EAAGvL,GAAK6K,EAAG/I,EAAI9B,EAAI,GAAK4L,EACnCtC,EAAExH,KAAO8J,EAAI,GAEbA,EAAIA,EAAI,GAAK,EAGftC,EAAExH,IAAMwH,EAAExH,GAAK8J,GAAK,GAMtB,IAFIA,IAAK5K,EAAEqI,EAAOC,EAAEmD,QAEfzM,EAAIsJ,EAAEnJ,QAASmJ,IAAItJ,IAAKsJ,EAAEyB,MAG/B,OADA/J,EAAEsI,EAAIA,EACCtI,GAUToI,GAAEyE,cAAgB,SAAUnD,GAC1B,OAAOM,GAAUhG,KAAM,EAAG0F,EAAIA,IAahCtB,GAAE2E,QAAU,SAAUrD,GACpB,OAAOM,GAAUhG,KAAM,EAAG0F,EAAI1F,KAAKqE,EAAIqB,IAWzCtB,GAAE4E,YAAc,SAAUC,GACxB,OAAOjD,GAAUhG,KAAM,EAAGiJ,EAAIA,EAAK,IAUrC7E,GAAEtD,SAAW,WACX,OAAOkF,GAAUhG,OAUnBoE,GAAE8E,QAAU9E,GAAEhD,OAAS,WACrB,OAAO4E,GAAUhG,KAAM,IAIlB,IAAIuF,GAlzBX,SAAS4D,IAOP,SAAS5D,EAAIV,GACX,IAAIvL,EAAI0G,KAER,KAAM1G,aAAaiM,GAAM,YAjBb,IAiBoBV,EAAkBsE,IAAU,IAAI5D,EAAIV,GAEhEA,aAAaU,GACfjM,EAAEyB,EAAI8J,EAAE9J,EACRzB,EAAE+K,EAAIQ,EAAER,EACR/K,EAAEgL,EAAIO,EAAEP,EAAEW,QAuBhB,SAAmB3L,GAGjB,IAFAA,EAAIgM,GAAMhM,EA1FH,GA0FU,IAEXgL,EAAEnJ,OAAS,IAAM7B,EAAEgL,EAAE,GAAI,CAC7B,IAAItJ,EAAI1B,EAAEgL,EAAE8E,WAAU,SAAA9P,GAAC,OAAIA,KAC3BA,EAAEgL,EAAIhL,EAAEgL,EAAEW,MAAMjK,GAChB1B,EAAE+K,EAAI/K,EAAE+K,EAAIrJ,GA5BVqO,CAAU/P,IAEVsL,GAAMtL,EAAGuL,GAQXvL,EAAEsF,YAAc2G,EASlB,OANAA,EAAItG,UAAYmF,GAChBmB,EAAIC,GAjFG,GAkFPD,EAAIE,GAvED,EAwEHF,EAAIY,IA1DD,GA2DHZ,EAAIa,GAlDD,GAmDHb,EAAI+D,QAAU,QACP/D,EA+wBQ4D,GACF5D,MCv4BAgE,MACS,IAAIA,GAAQ,GACb,IAAIA,GAAQ,GACP,IAAIA,IAAS,GACb,IAAIA,GAAQ,iCACZ,IAAIA,GAAQ,kCA4DjC,IClEIC,IAEX,SAAWA,GAWTA,EAAaA,EAAY,kBAAwB,KAAO,oBAX1D,CAqBGA,KAAiBA,GAAe,KCrBpBC,IAKXC,GAAO,KAEX,IACEA,GAAO,IAAIC,YAAYC,SAAS,IAAID,YAAYE,OAAO,IAAIC,WAAW,CAAC,EAAG,GAAI,IAAK,IAAK,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,IAAK,GAAI,EAAG,IAAK,IAAK,IAAK,IAAK,EAAG,IAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAAK,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,IAAK,IAAK,IAAK,EAAG,EAAG,EAAG,IAAK,IAAK,IAAK,GAAI,IAAK,EAAG,EAAG,EAAG,IAAK,IAAK,IAAK,GAAI,IAAK,EAAG,EAAG,EAAG,IAAK,IAAK,IAAK,GAAI,IAAK,EAAG,EAAG,EAAG,IAAK,IAAK,IAAK,GAAI,IAAK,EAAG,EAAG,EAAG,IAAK,IAAK,IAAK,GAAI,IAAK,IAAK,IAAK,IAAK,EAAG,EAAG,GAAI,IAAK,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,IAAK,GAAI,EAAG,GAAI,GAAI,IAAK,IAAK,GAAI,EAAG,GAAI,EAAG,IAAK,GAAI,GAAI,EAAG,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,IAAK,GAAI,EAAG,GAAI,GAAI,IAAK,IAAK,GAAI,EAAG,GAAI,EAAG,IAAK,GAAI,GAAI,EAAG,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,IAAK,GAAI,EAAG,GAAI,GAAI,IAAK,IAAK,GAAI,EAAG,GAAI,EAAG,IAAK,GAAI,GAAI,EAAG,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,IAAK,GAAI,EAAG,GAAI,GAAI,IAAK,IAAK,GAAI,EAAG,GAAI,EAAG,IAAK,GAAI,GAAI,EAAG,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,IAAK,GAAI,EAAG,GAAI,GAAI,IAAK,IAAK,GAAI,EAAG,GAAI,EAAG,IAAK,MAAO,IAAIC,QAC5sC,MAAO1F,KAcF,SAASoF,GAAKO,EAAKC,EAAMC,GAK9BlK,KAAKgK,IAAY,EAANA,EAMXhK,KAAKiK,KAAc,EAAPA,EAMZjK,KAAKkK,WAAaA,EA4Db,SAASC,GAAOC,GACrB,OAAsC,KAA9BA,GAAOA,EAAG,YA1DpBX,GAAKxK,UAAUrD,YAAc,WAC3B,IAAIH,EAAKuE,KAAKkK,SAAW,EAAI,EAG7B,OADAzO,IADAA,GAAMA,GAAM,GAAKA,EAAKuE,KAAKiK,OACf,GAAKxO,EAAKuE,KAAKgK,KAI7BP,GAAKxK,UAAU7C,OAAS,SAAU9C,GAChC,OAAO6C,GAAO6D,KAAM1G,IAGtBmQ,GAAKxK,UAAUhC,UAAY,SAAU3D,GACnC,OAAO0D,GAAQgD,KAAM1G,IAGvBmQ,GAAKxK,UAAU6B,SAAW,SAAUuJ,GAClC,OAAOvJ,GAASd,KAAMqK,IAGxBZ,GAAKxK,UAAUmC,OAAS,WACtB,OAAON,GAASd,OA0BlByJ,GAAKxK,UAAUqL,WACf5L,OAAO6L,eAAed,GAAKxK,UAAW,aAAc,CAClDE,OAAO,IA0BT,IAAIqL,GAAY,GAOZC,GAAa,GAQV,SAASC,GAAQvL,EAAO+K,GAC7B,IAAIE,EAAKO,EAAWC,EAEpB,OAAIV,GAGEU,EAAQ,IAFZzL,KAAW,IAEeA,EAAQ,OAChCwL,EAAYF,GAAWtL,IACDwL,GAGxBP,EAAMS,GAAS1L,GAAgB,EAARA,GAAa,GAAK,EAAI,GAAG,GAC5CyL,IAAOH,GAAWtL,GAASiL,GACxBA,IAIHQ,GAAS,MAFbzL,GAAS,IAEoBA,EAAQ,OACnCwL,EAAYH,GAAUrL,IACAwL,GAGxBP,EAAMS,GAAS1L,EAAOA,EAAQ,GAAK,EAAI,GAAG,GACtCyL,IAAOJ,GAAUrL,GAASiL,GACvBA,GAmBJ,SAASU,GAAW3L,EAAO+K,GAChC,GAAIa,MAAM5L,GAAQ,OAAO+K,EAAWc,GAAQC,GAE5C,GAAIf,EAAU,CACZ,GAAI/K,EAAQ,EAAG,OAAO6L,GACtB,GAAI7L,GAAS+L,GAAgB,OAAOC,OAC/B,CACL,GAAIhM,IAAUiM,GAAgB,OAAOC,GACrC,GAAIlM,EAAQ,GAAKiM,GAAgB,OAAOE,GAG1C,OAAInM,EAAQ,EAAUoM,GAAOT,IAAY3L,EAAO+K,IACzCW,GAAS1L,EAAQqM,GAAiB,EAAGrM,EAAQqM,GAAiB,EAAGtB,GAmBnE,SAASW,GAASY,EAASC,EAAUxB,GAC1C,OAAO,IAAIT,GAAKgC,EAASC,EAAUxB,GAqBrC,IAAIyB,GAAUlF,KAAKgC,IAUZ,SAASmD,GAAWC,EAAK3B,EAAUG,GACxC,GAAmB,IAAfwB,EAAI1Q,OAAc,MAAM+C,MAAM,gBAClC,GAAY,QAAR2N,GAAyB,aAARA,GAA8B,cAARA,GAA+B,cAARA,EAAqB,OAAOZ,GAU9F,GARwB,kBAAbf,GAETG,EAAQH,EAAUA,GAAW,GAE7BA,IAAaA,GAGfG,EAAQA,GAAS,IACL,GAAK,GAAKA,EAAO,MAAMyB,WAAW,SAC9C,IAAIC,EAAIF,EAAI3G,QAAQ,KACpB,GAAI6G,EAAI,EAAG,MAAM7N,MAAM,mBAAwB,GAAU,IAAN6N,EACjD,OAAOR,GAAOK,GAAWC,EAAIxG,UAAU,GAAI6E,EAAUG,IAOvD,IAHA,IAAI2B,EAAelB,GAAWa,GAAQtB,EAAO,IACzCzJ,EAASqK,GAEJjQ,EAAI,EAAGA,EAAI6Q,EAAI1Q,OAAQH,GAAK,EAAG,CACtC,IAAIiR,EAAOxF,KAAKyF,IAAI,EAAGL,EAAI1Q,OAASH,GAChCmE,EAAQgN,SAASN,EAAIxG,UAAUrK,EAAGA,EAAIiR,GAAO5B,GAEjD,GAAI4B,EAAO,EAETrL,EAAS4H,GAAI4D,GAASxL,EADVkK,GAAWa,GAAQtB,EAAO4B,KACAnB,GAAW3L,SAGjDyB,EAAS4H,GADT5H,EAASwL,GAASxL,EAAQoL,GACLlB,GAAW3L,IAKpC,OADAyB,EAAOsJ,SAAWA,EACXtJ,EAoBF,SAASyL,GAAUC,EAAKpC,GAC7B,MAAmB,kBAARoC,EAAyBxB,GAAWwB,EAAKpC,GACjC,kBAARoC,EAAyBV,GAAWU,EAAKpC,GAE7CW,GAASyB,EAAItC,IAAKsC,EAAIrC,KAA0B,mBAAbC,EAAyBA,EAAWoC,EAAIpC,UAmBpF,IAcIsB,GAAiBe,WAOjBrB,GAAiBM,GAAiBA,GAOlCJ,GAAiBF,GAAiB,EAOlCsB,GAAa9B,GA5BI,GAAK,IAkCfO,GAAOP,GAAQ,GAYfM,GAAQN,GAAQ,GAAG,GAYnB+B,GAAM/B,GAAQ,GAYdgC,GAAOhC,GAAQ,GAAG,GAYlBiC,GAAUjC,IAAS,GAYnBY,GAAYT,IAAS,EAAgB,YAAgB,GAYrDM,GAAqBN,IAAS,GAAgB,GAAgB,GAY9DQ,GAAYR,GAAS,GAAG,YAAgB,GAmB5C,SAAS+B,GAAMC,GACpB,OAAOA,EAAM3C,SAAW2C,EAAM7C,MAAQ,EAAI6C,EAAM7C,IAS3C,SAAS8C,GAASD,GACvB,OAAIA,EAAM3C,UAAkB2C,EAAM5C,OAAS,GAAKuB,IAAkBqB,EAAM7C,MAAQ,GACzE6C,EAAM5C,KAAOuB,IAAkBqB,EAAM7C,MAAQ,GAY/C,SAASlJ,GAAS+L,EAAOxC,GAE9B,IADAA,EAAQA,GAAS,IACL,GAAK,GAAKA,EAAO,MAAMyB,WAAW,SAC9C,GAAIiB,GAAOF,GAAQ,MAAO,IAE1B,GAAIG,GAAWH,GAAQ,CAErB,GAAI1Q,GAAO0Q,EAAOxB,IAAY,CAG5B,IAAI4B,EAAYnC,GAAWT,GACvB3D,EAAMwG,GAAOL,EAAOI,GACpBE,EAAOC,GAAShB,GAAS1F,EAAKuG,GAAYJ,GAC9C,OAAO/L,GAAS4F,EAAK2D,GAASuC,GAAMO,GAAMrM,SAASuJ,GAC9C,MAAO,IAAMvJ,GAASyK,GAAOsB,GAAQxC,GAS9C,IAJA,IAAI2B,EAAelB,GAAWa,GAAQtB,EAAO,GAAIwC,EAAM3C,UACnDmD,EAAMR,EACNjM,EAAS,KAEA,CACX,IAAI0M,EAASJ,GAAOG,EAAKrB,GAErBuB,GADSX,GAAMQ,GAASC,EAAKjB,GAASkB,EAAQtB,OAAoB,GAClDlL,SAASuJ,GAE7B,GAAI0C,GADJM,EAAMC,GACW,OAAOC,EAAS3M,EAC/B,KAAO2M,EAAOpS,OAAS,GAAGoS,EAAS,IAAMA,EAEzC3M,EAAS,GAAK2M,EAAS3M,GAmEtB,SAASmM,GAAOF,GACrB,OAAsB,IAAfA,EAAM5C,MAA4B,IAAd4C,EAAM7C,IAe5B,SAASgD,GAAWH,GACzB,OAAQA,EAAM3C,UAAY2C,EAAM5C,KAAO,EAmBlC,SAASuD,GAAMX,GACpB,OAA2B,KAAP,EAAZA,EAAM7C,KAoBT,SAAS7N,GAAO0Q,EAAOlN,GAE5B,OADKwK,GAAOxK,KAAQA,EAAQ0M,GAAU1M,KAClCkN,EAAM3C,WAAavK,EAAMuK,UAAY2C,EAAM5C,OAAS,KAAO,GAAKtK,EAAMsK,OAAS,KAAO,KACnF4C,EAAM5C,OAAStK,EAAMsK,MAAQ4C,EAAM7C,MAAQrK,EAAMqK,KA+CnD,SAASyD,GAASZ,EAAOlN,GAC9B,OAAO3C,GAAQ6P,EAEflN,GAAS,EA+CJ,SAAS+N,GAAYb,EAAOlN,GACjC,OAAO3C,GAAQ6P,EAEflN,GAAS,EAkBJ,SAASgO,GAAmBd,EAAOlN,GACxC,OAAO3C,GAAQ6P,EAEflN,IAAU,EA2BL,SAAS3C,GAAQ6P,EAAOlN,GAE7B,GADKwK,GAAOxK,KAAQA,EAAQ0M,GAAU1M,IAClCxD,GAAO0Q,EAAOlN,GAAQ,OAAO,EACjC,IAAIiO,EAAUZ,GAAWH,GACrBgB,EAAWb,GAAWrN,GAC1B,OAAIiO,IAAYC,GAAkB,GAC7BD,GAAWC,EAAiB,EAE5BhB,EAAM3C,SAEJvK,EAAMsK,OAAS,EAAI4C,EAAM5C,OAAS,GAAKtK,EAAMsK,OAAS4C,EAAM5C,MAAQtK,EAAMqK,MAAQ,EAAI6C,EAAM7C,MAAQ,GAAK,EAAI,EAFxFgD,GAAWI,GAASP,EAAOlN,KAAW,EAAI,EAoBjE,SAAS4L,GAAOsB,GACrB,OAAKA,EAAM3C,UAAY/N,GAAO0Q,EAAOxB,IAAmBA,GACjD7C,GAAIsF,GAAIjB,GAAQJ,IAiBlB,SAASjE,GAAIqE,EAAOkB,GACpB5D,GAAO4D,KAASA,EAAS1B,GAAU0B,IAExC,IAAIC,EAAMnB,EAAM5C,OAAS,GACrBgE,EAAmB,MAAbpB,EAAM5C,KACZiE,EAAMrB,EAAM7C,MAAQ,GACpBmE,EAAkB,MAAZtB,EAAM7C,IACZoE,EAAML,EAAO9D,OAAS,GACtBoE,EAAoB,MAAdN,EAAO9D,KACbqE,EAAMP,EAAO/D,MAAQ,GAErBuE,EAAM,EACNC,EAAM,EACNC,EAAM,EACNC,EAAM,EAYV,OAVAD,IADAC,GAAOP,GALgB,MAAbJ,EAAO/D,QAMF,GAGfwE,IADAC,GAAOP,EAAMI,KACE,GAGfC,IADAC,GAAOP,EAAMI,KACE,GAEfE,GAAOP,EAAMI,EAENvD,IANP4D,GAAO,QAMgB,IATvBC,GAAO,QAQPH,GAAO,QACiC,IAHxCC,GAAO,OAG2C3B,EAAM3C,UAUnD,SAASkD,GAASP,EAAO8B,GAE9B,OADKxE,GAAOwE,KAAaA,EAAatC,GAAUsC,IACzCnG,GAAIqE,EAAOtB,GAAOoD,IAkBpB,SAASvC,GAASS,EAAO+B,GAC9B,GAAI7B,GAAOF,GAAQ,OAAOA,EAAM3C,SAAWc,GAAQC,GAGnD,GAFKd,GAAOyE,KAAaA,EAAavC,GAAUuC,IAE5ClF,GAEF,OAAOmB,GADGnB,GAAKZ,IAAI+D,EAAM7C,IAAK6C,EAAM5C,KAAM2E,EAAW5E,IAAK4E,EAAW3E,MAChDP,GAAKmF,WAAYhC,EAAM3C,UAG9C,GAAI6C,GAAO6B,GAAa,OAAO/B,EAAM3C,SAAWc,GAAQC,GACxD,GAAI9O,GAAO0Q,EAAOxB,IAAY,OAAOmC,GAAMoB,GAAcvD,GAAYJ,GACrE,GAAI9O,GAAOyS,EAAYvD,IAAY,OAAOmC,GAAMX,GAASxB,GAAYJ,GAErE,GAAI+B,GAAWH,GACb,OAAIG,GAAW4B,GAAoBxC,GAASb,GAAOsB,GAAQtB,GAAOqD,IAAyBrD,GAAOa,GAASb,GAAOsB,GAAQ+B,IACrH,GAAI5B,GAAW4B,GAAa,OAAOrD,GAAOa,GAASS,EAAOtB,GAAOqD,KAGxE,GAAInB,GAASZ,EAAOL,KAAeiB,GAASmB,EAAYpC,IAAa,OAAO1B,GAAWgC,GAASD,GAASC,GAAS8B,GAAa/B,EAAM3C,UAGrI,IAAI8D,EAAMnB,EAAM5C,OAAS,GACrBgE,EAAmB,MAAbpB,EAAM5C,KACZiE,EAAMrB,EAAM7C,MAAQ,GACpBmE,EAAkB,MAAZtB,EAAM7C,IACZoE,EAAMQ,EAAW3E,OAAS,GAC1BoE,EAAwB,MAAlBO,EAAW3E,KACjBqE,EAAMM,EAAW5E,MAAQ,GACzB8E,EAAuB,MAAjBF,EAAW5E,IACjBuE,EAAM,EACNC,EAAM,EACNC,EAAM,EACNC,EAAM,EAqBV,OAnBAD,IADAC,GAAOP,EAAMW,KACE,GAGfN,IADAC,GAAOP,EAAMY,KACE,GACfL,GAAO,MAEPD,IADAC,GAAON,EAAMG,KACE,GAGfC,IADAC,GAAOP,EAAMa,KACE,GACfN,GAAO,MAEPD,IADAC,GAAON,EAAMI,KACE,GACfE,GAAO,MAEPD,IADAC,GAAOL,EAAME,KACE,GAEfE,GAAOP,EAAMc,EAAMb,EAAMK,EAAMJ,EAAMG,EAAMF,EAAMC,EAE1CvD,IAZP4D,GAAO,QAYgB,IAlBvBC,GAAO,QAiBPH,GAAO,QACiC,IAHxCC,GAAO,OAG2C3B,EAAM3C,UAmBnD,SAASgD,GAAOL,EAAOkC,GAE5B,GADK5E,GAAO4E,KAAUA,EAAU1C,GAAU0C,IACtChC,GAAOgC,GAAU,MAAM7Q,MAAM,oBAW/B,IAKE8Q,EAAQ3B,EAAKxN,EAdjB,GAAI6J,GAIF,OAAKmD,EAAM3C,WAA4B,aAAhB2C,EAAM5C,OAAyC,IAAjB8E,EAAQ/E,MAAgC,IAAlB+E,EAAQ9E,KAM5EY,IADIgC,EAAM3C,SAAWR,GAAKuF,MAAQvF,GAAKwF,OAAOrC,EAAM7C,IAAK6C,EAAM5C,KAAM8E,EAAQ/E,IAAK+E,EAAQ9E,MAC5EP,GAAKmF,WAAYhC,EAAM3C,UAJnC2C,EAOX,GAAIE,GAAOF,GAAQ,OAAOA,EAAM3C,SAAWc,GAAQC,GAGnD,GAAK4B,EAAM3C,SA0BJ,CAIL,GADK6E,EAAQ7E,WAAU6E,EA4RpB,SAAoBlC,GACzB,OAAIA,EAAM3C,SAAiB2C,EACpBhC,GAASgC,EAAM7C,IAAK6C,EAAM5C,MAAM,GA9RJkF,CAAWJ,IACxCrB,GAAYqB,EAASlC,GAAQ,OAAO7B,GACxC,GAAI0C,GAAYqB,EAASK,GAAmBvC,EAAO,IACjD,OAAOH,GACT7M,EAAMmL,OAjCa,CAGnB,GAAI7O,GAAO0Q,EAAOxB,IAChB,OAAIlP,GAAO4S,EAAStC,KAAQtQ,GAAO4S,EAASpC,IAAiBtB,GACpDlP,GAAO4S,EAAS1D,IAAmBoB,GAKpCtQ,GAFJ6S,EAASK,GAAUnC,GADJoC,GAAWzC,EAAO,GACGkC,GAAU,GAE3B9D,IACV+B,GAAW+B,GAAWtC,GAAME,GAGnC9M,EAAM2I,GAAIwG,EAAQ9B,GADlBG,EAAMD,GAASP,EAAOT,GAAS2C,EAASC,IACVD,IAI/B,GAAI5S,GAAO4S,EAAS1D,IAAY,OAAOwB,EAAM3C,SAAWc,GAAQC,GAEvE,GAAI+B,GAAWH,GACb,OAAIG,GAAW+B,GAAiB7B,GAAO3B,GAAOsB,GAAQtB,GAAOwD,IACtDxD,GAAO2B,GAAO3B,GAAOsB,GAAQkC,IAC/B,GAAI/B,GAAW+B,GAAU,OAAOxD,GAAO2B,GAAOL,EAAOtB,GAAOwD,KAEnElP,EAAMoL,GAkBR,IAFAoC,EAAMR,EAECc,GAAmBN,EAAK0B,IAAU,CAGvCC,EAASvI,KAAKtJ,IAAI,EAAGsJ,KAAK8I,MAAMzC,GAASO,GAAOP,GAASiC,KAUzD,IAPA,IAAIS,EAAO/I,KAAKgJ,KAAKhJ,KAAKiJ,IAAIV,GAAUvI,KAAKkJ,KACzCC,EAAQJ,GAAQ,GAAK,EAAI7D,GAAQ,EAAG6D,EAAO,IAG/CK,EAAY/E,GAAWkE,GACnBc,EAAY1D,GAASyD,EAAWd,GAE7B/B,GAAW8C,IAAcpC,GAAYoC,EAAWzC,IAGrDyC,EAAY1D,GADZyD,EAAY/E,GADZkE,GAAUY,EACqB/C,EAAM3C,UACL6E,GAK9BhC,GAAO8C,KAAYA,EAAYpD,IACnC5M,EAAM2I,GAAI3I,EAAKgQ,GACfxC,EAAMD,GAASC,EAAKyC,GAGtB,OAAOjQ,EAmDF,SAASiO,GAAIjB,GAClB,OAAOhC,IAAUgC,EAAM7C,KAAM6C,EAAM5C,KAAM4C,EAAM3C,UA8C1C,SAASmF,GAAUxC,EAAOkD,GAE/B,OADI5F,GAAO4F,KAAUA,EAAUnD,GAAMmD,IACb,KAAnBA,GAAW,IAAkBlD,EAAekD,EAAU,GAAWlF,GAASgC,EAAM7C,KAAO+F,EAASlD,EAAM5C,MAAQ8F,EAAUlD,EAAM7C,MAAQ,GAAK+F,EAASlD,EAAM3C,UAAsBW,GAAS,EAAGgC,EAAM7C,KAAO+F,EAAU,GAAIlD,EAAM3C,UAkB7N,SAASoF,GAAWzC,EAAOkD,GAEhC,OADI5F,GAAO4F,KAAUA,EAAUnD,GAAMmD,IACb,KAAnBA,GAAW,IAAkBlD,EAAekD,EAAU,GAAWlF,GAASgC,EAAM7C,MAAQ+F,EAAUlD,EAAM5C,MAAQ,GAAK8F,EAASlD,EAAM5C,MAAQ8F,EAASlD,EAAM3C,UAAsBW,GAASgC,EAAM5C,MAAQ8F,EAAU,GAAIlD,EAAM5C,MAAQ,EAAI,GAAK,EAAG4C,EAAM3C,UAkBtP,SAASkF,GAAmBvC,EAAOkD,GAGxC,GAFI5F,GAAO4F,KAAUA,EAAUnD,GAAMmD,IAErB,KADhBA,GAAW,IACQ,OAAOlD,EACxB,IAAI5C,EAAO4C,EAAM5C,KAEjB,OAAI8F,EAAU,GAELlF,GADGgC,EAAM7C,MACQ+F,EAAU9F,GAAQ,GAAK8F,EAAS9F,IAAS8F,EAASlD,EAAM3C,UAChDW,GAAX,KAAZkF,EAAgC9F,EAA8CA,IAAS8F,EAAU,GAA3D,EAAGlD,EAAM3C,UClrC/CT,UAKFuG,GAAcvG,GAkBdzM,GAAUyM,GAGVwG,GDyyCN,SAAmBC,EAAOhG,EAAUiG,GACzC,OAAOA,EAUF,SAAqBD,EAAOhG,GACjC,OAAO,IAAIT,GAAKyG,EAAM,GAAKA,EAAM,IAAM,EAAIA,EAAM,IAAM,GAAKA,EAAM,IAAM,GAAIA,EAAM,GAAKA,EAAM,IAAM,EAAIA,EAAM,IAAM,GAAKA,EAAM,IAAM,GAAIhG,GAX5HkG,CAAYF,EAAOhG,GAqB1B,SAAqBgG,EAAOhG,GACjC,OAAO,IAAIT,GAAKyG,EAAM,IAAM,GAAKA,EAAM,IAAM,GAAKA,EAAM,IAAM,EAAIA,EAAM,GAAIA,EAAM,IAAM,GAAKA,EAAM,IAAM,GAAKA,EAAM,IAAM,EAAIA,EAAM,GAAIhG,GAtB7FmG,CAAYH,EAAOhG,ICryCnDoG,GDgwCN,SAAiBzD,EAAOsD,GAC7B,OAAOA,EASF,SAAmBtD,GACxB,IAAI0D,EAAK1D,EAAM5C,KACXuG,EAAK3D,EAAM7C,IACf,MAAO,CAAM,IAALwG,EAAWA,IAAO,EAAI,IAAMA,IAAO,GAAK,IAAMA,IAAO,GAAS,IAALD,EAAWA,IAAO,EAAI,IAAMA,IAAO,GAAK,IAAMA,IAAO,IAZ1GE,CAAU5D,GAqBjB,SAAmBA,GACxB,IAAI0D,EAAK1D,EAAM5C,KACXuG,EAAK3D,EAAM7C,IACf,MAAO,CAACuG,IAAO,GAAIA,IAAO,GAAK,IAAMA,IAAO,EAAI,IAAW,IAALA,EAAWC,IAAO,GAAIA,IAAO,GAAK,IAAMA,IAAO,EAAI,IAAW,IAALA,GAxBhFE,CAAU7D,IC/vC9B/L,GAAW2I,GC/BjB,IAAMkH,GAAb,WACE,WAAYC,GAAO,oBACjB5Q,KAAK4Q,KAAOA,EAFhB,uDAMI,IAAMrP,EAAMvB,KAAK4Q,KAAKpP,OAEtB,OADAxB,KAAK6Q,QAAUtP,EAAIpC,OACXoC,EAAIG,OARhB,8BAgBI,MAAM,IAAIxD,MAAM,kCAhBpB,iEAYI,OAAO8B,KAAK6Q,YAZhB,KAwBO,SAASC,GAAcpW,GAC5B,OAAO,IAAIiW,GAAWjW,EAAE2G,OAAOC,aAE1B,SAASyP,GAAWC,GACzB,MAAO,CACLxP,KADK,WAEH,OAAOwP,EAAGC,WAAa,CACrBvP,MAAM,EACNvC,MAAO6R,EAAGE,SACR,CACFxP,MAAM,EACNvC,MAAO,QAyCR,SAASgS,GAAOC,EAAIC,GACzB,OAAOC,IAAM,WACX,IAAIC,GAAY,EAEZC,EAAQ,CADFJ,EAAG/P,OAAOC,YACJ,MAChB,OAAOmQ,IAAO,WACZ,IAAIC,EAAIC,EAEJpQ,EAEJ,IAAKgQ,EAAW,CAGd,GAAW,OAFXhQ,EAA0B,QAAnBmQ,EAAKF,EAAM,UAAuB,IAAPE,OAAgB,EAASA,EAAGlQ,UAE1CD,EAAIG,KACtB,MAAO,CAACH,EAAIpC,MAAOqS,GAEnBD,GAAY,EACZC,EAAQ,CAAC,KAAMH,EAAGhQ,OAAOC,aAK7B,OAAc,OADdC,EAA0B,QAAnBoQ,EAAKH,EAAM,UAAuB,IAAPG,OAAgB,EAASA,EAAGnQ,SACvCD,EAAIG,KAA4B,KAArB,CAACH,EAAIpC,MAAOqS,KAC7CA,MAmBA,SAASjT,GAAO6S,GACrB,OAAOE,IAAM,WACX,IAAMV,EAAOQ,EAAG/P,OAAOC,YACnBsQ,EAAS,CACXzS,MAAO,MAET,OAAOsS,IAAO,SAAAI,GAGZ,IAFA,IAAIC,GAAc,GAEVA,GACN,GAAiB,MAAbD,EAAmB,CACrB,IAAMtQ,EAAMqP,EAAKpP,OAEZD,EAAIG,KAGPoQ,GAAc,EAFdD,EAAYtQ,EAAIpC,MAAMkC,OAAOC,gBAI1B,CACL,IAAMC,EAAMsQ,EAAUrQ,OAEjBD,EAAIG,KAMPmQ,EAAY,MALZD,EAAS,CACPzS,MAAOoC,EAAIpC,OAEb2S,GAAc,GAOpB,OAAoB,MAAbD,GAA+B,MAAVD,EAAiB,CAACA,EAAOzS,MAAO0S,GAAa,OACxE,SAGA,SAASE,GAAQvU,EAAG4T,GACzB,OAAO7S,GAAOzE,GAAI0D,EAAG4T,IAuBhB,SAASE,GAAM9T,GACpB,OAAO,gBACJ6D,OAAOC,UAAW,kBAAM9D,IAAI6D,OAAOC,eA4IjC,SAAS0Q,GAAKxU,EAAGyU,EAAKb,GAC3B,GAAI7X,MAAMC,QAAQ4X,IAAO3X,YAAYC,OAAO0X,GAC1C,OAAOA,EAAG5V,OAAOgC,EAAGyU,GAIpB,IAFA,IAAI1Q,EAEKvG,EAAI,EAAG4V,EAAOQ,EAAG/P,OAAOC,cAC/BC,EAAMqP,EAAKpP,QAEHE,KAHqC1G,IAO7CiX,EAAMzU,EAAEyU,EAAK1Q,EAAIpC,MAAOnE,GAG1B,OAAOiX,EAiFJ,SAASC,GAAQ1U,EAAG4T,GACzBY,IAAK,SAACG,EAAG7Y,GAAJ,OAAWkE,EAAElE,GAAI,OAAO,KAAM8X,GAK9B,SAASgB,GAAe5U,EAAG4T,GAChCY,IAAK,SAACG,EAAG7Y,EAAG0B,GAAP,OAAcwC,EAAQ,OAANxC,QAAoB,IAANA,EAAeA,EAAI,EAAG1B,GAAI,OAAO,KAAM8X,GAkBrE,SAAStX,GAAI0D,EAAG4T,GACrB,OAAOE,IAAM,kBAAMG,IAAO,SAAAb,GACxB,IAAMrP,EAAMqP,EAAKpP,OACjB,OAAQD,EAAIG,KAA8B,KAAvB,CAAClE,EAAE+D,EAAIpC,OAAQyR,KACjCQ,EAAG/P,OAAOC,gBA+LR,SAAS+Q,GAAUrW,GACxB,MAAO,CAACA,GAEH,SAASsW,GAAKzN,EAAGuM,GACtB,OAAO,gBACJ/P,OAAOC,UAAW,WAGjB,IAFA,IAAMsP,EAAOQ,EAAG/P,OAAOC,YAEdtG,EAAI,EAAGA,GAAK6J,EAAG7J,IACtB,GAAI4V,EAAKpP,OAAOE,KACd,MAAM,IAAIxD,MAAM,+BAIpB,OAAO0S,KAiBN,SAAS2B,GAAM/U,EAAG4T,EAAIoB,GAC3B,OAAOR,IAAK,SAACC,EAAK3Y,GAAN,OAAYkZ,EAAMC,IAAIR,EAAKzU,EAAElE,MAAKkZ,EAAME,UAAWtB,GAc1D,SAASuB,GAAK9N,EAAGuM,GAAuB,IAAnBwB,EAAkB,wDAC5C,OAAOtB,IAAM,WACX,IAAMV,EAAOQ,EAAG/P,OAAOC,YACvB,OAAOmQ,IAAO,SAAAzW,GACZ,GAAIA,EAAI6J,EAAG,CACT,IAAMtD,EAAMqP,EAAKpP,OAEjB,IAAKD,EAAIG,KACP,MAAO,CAACH,EAAIpC,MAAOnE,EAAI,GAGzB,IAAK4X,EACH,MAAM,IAAI1U,MAAM,+BAIpB,OAAO,OACN,MAiGA,SAASuT,GAAOjU,EAAGqV,GACxB,OAAO,gBACJxR,OAAOC,UAAW,WAGjB,IAAI2Q,EAAMY,EAuBV,MAtBa,CACXrR,KAAM,WACJ,IAAM3B,EAAMrC,EAAEyU,GAEd,GAAW,MAAPpS,EAAa,CACf,IAAMiT,EAAI3T,GAAMU,GAEhB,GAAS,MAALiT,EAEF,OADAb,EAAMa,EAAE,GACD,CACLpR,MAAM,EACNvC,MAAO2T,EAAE,IAKf,MAAO,CACLpR,MAAM,EACNvC,WAAO8E,QCrzBnB,IAAM8O,GAAiB,4CAOvB,SAASC,GAAU1Z,GACjB,MAAoB,kBAANA,GAAkBA,aAAamQ,IAAQnQ,aAAaiQ,GAGpE,SAAS0J,GAAW3Z,EAAG0C,GACrB,OAAI1C,aAAamQ,GACRyJ,GAAc5Z,EAAG0C,GAAK,EACpB1C,aAAaiQ,GACfjQ,EAAEiL,IAAIvI,GAAK,EAEX1C,EAAI0C,EAIf,SAASoQ,GAAS9S,EAAG0C,GACnB,OAAI1C,aAAamQ,GACRyJ,GAAkB5Z,EAAG0C,GACnB1C,aAAaiQ,GACfjQ,EAAEwP,IAAI9M,GAEN1C,EAAI0C,EAIf,SAAS+M,GAAQzP,EAAGoM,GAClB,OAAIpM,aAAamQ,GACR3N,OAAOxC,IAAK,GAAGyP,QAAQrD,GAAIyN,OAAO,GAElC7Z,EAAEyP,QAAQrD,GAIrB,SAASsD,GAAY1P,EAAG2P,GACtB,OAAI3P,aAAamQ,GACR3N,OAAOxC,IAAK,GAAG0P,YAAYC,GAAIkK,OAAO,GAEtC7Z,EAAE0P,YAAYC,GAIzB,SAASJ,GAAcvP,EAAGoM,GACxB,OAAIpM,aAAamQ,GACR3N,OAAOxC,IAAK,GAAGuP,cAAcnD,GAAIyN,OAAO,GAExC7Z,EAAEuP,cAAcnD,GA4H3B,SAAS0N,GAAM9Z,GACb,OAAIA,aAAamQ,GACRyJ,GAAe5Z,EAAE4Q,SAAW5Q,EAAI4Z,GAAgBA,GAAc5Z,IAAI,GAAO,KAExE+Z,OAAO/Z,KAAO,GAAGwH,SAAS,IAI/B,SAASwS,GAAOC,GACrB,MAAO,CACLA,QACAC,MAgHqB3H,EAhHN0H,EAiHV,SAAAC,GACL,OAAOT,GAAehO,KAAK8G,GAf/B,SAAS4H,EAAc5H,EAAK2H,GAC1B,OAAO,WAAa,IAElB,IAAIE,EAAU7H,EAFI,mBAATxN,EAAS,yBAATA,EAAS,gBAIlB,cAAkBA,EAAlB,eAAwB,CAAnB,IAAMsV,EAAG,KACZD,EAAUE,GAAWF,EAASC,GAGhC,OAAOZ,GAAehO,KAAK2O,GAAWD,EAAcC,EAASF,GAAQA,EAAKE,EAAQvO,QAAQ,MAAO,OAM/DsO,CAAc5H,EAAK2H,GAAQA,EAAK3H,MAF/D,IAAkBA,EAlGlB,SAASgI,GAAOF,GACrB,OAAOA,EAAIH,MAAK,SAAAla,GAAC,OAAIA,KAQvB,SAASsa,GAAWE,EAAMC,GACxB,OAAOD,EAAK3O,QAAQ4N,IAAgB,SAACZ,EAAG6B,EAAQC,EAAOC,EAAWC,EAAWC,GAC3E,IAAIC,EAAO,GAEX,GAAIrB,GAAUe,GAgBZ,OAf6B,MAAzBK,EAAOE,gBACLrB,GAAWc,EAAK,IAClBA,EAAM3H,GAAS2H,GAAM,GACrBM,EAAO,KAEHJ,EAAM/O,QAAQ,MAAQ,EACxBmP,EAAO,IACEJ,EAAM/O,QAAQ,MAAQ,IAC/BmP,EAAO,MAKbF,EAAyB,MAAbA,EAAoB,KAAOhI,SAASgI,EAAW,IAEnDC,GACN,IAAK,IACL,IAAK,IAEHL,EAAMhL,GAAQgL,EADdI,EAAyB,MAAbA,EAAoBA,EAAY,GAE5C,MAEF,IAAK,IACL,IAAK,IACHJ,EAAmB,MAAbI,EAAoBnL,GAAY+K,EAAKI,GAAanL,GAAY+K,GACpE,MAEF,IAAK,IACL,IAAK,IACHA,EAAmB,MAAbI,EAAoBtL,GAAckL,EAAKI,GAAatL,GAAckL,GACxE,MAEF,IAAK,IACHA,EAAMX,GAAMW,GACZ,MAEF,IAAK,IACHA,EAAMX,GAAMW,GAAKQ,cACjB,MAEF,QAEER,EAAMjY,OAAOiY,GAOnB,GAFAG,EAAY/H,SAAS+H,EAAW,IAE3BnJ,MAAMmJ,GAcTH,EAAMM,EAAON,MAdQ,CACrB,IAAMS,EAAWP,EAAM/O,QAAQ,MAAQ,EAEjCuP,EAAYR,EAAM/O,QAAQ,MAAQ,EAElCwP,EAAKD,IAAcD,EAAW,IAAM,IAIxCT,EAFS,MAAPW,EAEIL,GADNN,EAAMY,GAAQZ,EAAKG,EAAYG,EAAKlZ,OAAQuZ,EAAID,IAG1CE,GAAQN,EAAON,EAAKG,EAAWQ,EAAID,GAO7C,OADaT,EAASD,GACV5O,QAAQ,KAAM,SAuIvB,SAASnE,GAAK4T,EAAWxD,GAC9B,OAAI7X,MAAMC,QAAQ4X,GACTA,EAAGpQ,KAAK4T,GAERrb,MAAM4H,KAAKiQ,GAAIpQ,KAAK4T,GA8IxB,SAASD,GAAQ9I,EAAK3Q,EAAKwZ,EAAIG,GACpCH,EAAKA,GAAM,IACXxZ,GAAY2Q,EAAI1Q,OAEhB,IAAK,IAAIH,EAAI,EAAGA,EAAIE,EAAKF,IACvB6Q,EAAMgJ,EAAUhJ,EAAM6I,EAAKA,EAAK7I,EAGlC,OAAOA,ECzjBF,IAAMiJ,GAAmBjW,GAAQ,SAAsCkW,EAAO3X,GACnF,IACM4X,EAAQ,IAAIpT,EAAU,MADX5B,KAER5C,SAAWA,EACpB4X,EAAMnT,SAHW7B,UAIRiV,QAAU,IAAIC,IAAI,IAJVlV,KAKR,aAAe,EACxBkS,IAAQ,SAAUiD,GAChBC,GAA8BJ,EAAMnT,SAAUsT,EAAK,GAAIA,EAAK,MAC3DJ,MASL,SAASM,GAAsCC,EAAUvU,GACvD,IAAM9F,EAAuC,EAAnCqa,EAASlY,SAASxB,YAAYmF,GAClCwU,EAAa1b,EAAYyb,EAASL,QAASha,EAAG,MAEpD,OAAIsa,EAAW,GACN,EAAC,EAAMta,EAAGsa,EAAW,GAAGnM,WAAU,SAAUoM,GACjD,OAAOF,EAASlY,SAAShB,OAAO2E,EAAGyU,EAAQ,QAGtC,EAAC,EAAOva,GAAI,GAIhB,SAASwa,GAAiCC,EAAUC,GACzD,IAAMC,EAAgBP,GAAsCK,EAAUC,GAatE,OAVIC,EAAc,IACZA,EAAc,IAAM,EACR,EAKF,GAId,KAAK,EAED,OAAOpX,EAAgBkX,EAAST,QAASW,EAAc,IAAIA,EAAc,IAG7E,KAAK,EAED,OAAO,MAOR,SAASC,GAAwBC,GACtCA,EAASb,QAAQc,QAEZ,SAASC,GAA4BC,GAE1C,OAWK,EAXE1D,IAAM,SAAoB2D,GAC/B,OAAOA,EAAS/a,SAFH8a,EAAShB,QAAQkB,SAGrB,CACTzD,QADS,WAEP,OAAO,GAGTD,IALS,SAKL2D,EAAOC,GACT,OAAOD,EAAQC,KAiDd,SAASjB,GAA8BkB,EAAUC,EAAMC,GAC5D,IAAMC,EAAgBpB,GAAsCiB,EAAUC,GAatE,OAVIE,EAAc,IACZA,EAAc,IAAM,EACR,EAKF,GAId,KAAK,EAED,IAAIC,EAGJ,MADAA,EADa7C,GAAOP,GAAO,6DACrBqD,CAAKJ,GACL,IAAIrY,MAAMwY,GAIpB,KAAK,EAED,GAAID,EAAc,GACCjY,EAAgB8X,EAASrB,QAASwB,EAAc,IAAIvQ,KAAK,CAACqQ,EAAMC,SAGjFF,EAASrB,QAAQra,IAAI6b,EAAc,GAAI,CAAC,CAACF,EAAMC,MAiClD,SAASI,GAAgCC,EAAWC,GACzD,IAAMC,EAAgB1B,GAAsCwB,EAAWC,GAavE,OAVIC,EAAc,IACZA,EAAc,IAAM,EACR,EAKF,GAId,KAAK,EAGD,OADAvY,EAAgBqY,EAAU5B,QAAS8B,EAAc,IAAIpV,OAAOoV,EAAc,GAAI,IACvE,EAGX,KAAK,EAED,OAAO,GAKfjC,GAAiB7V,UAAUoC,OAAOC,UAAY,WAC5C,IACM0V,EAAYhX,KAClB,OAAO+Q,GAMHD,GANuBQ,IAAM,WAC/B,OAAOS,IAAQ,SAAUkF,GACvB,OAAOnd,IAAI,SAAUod,GACnB,OAAOA,IACND,KACFD,EAAU/B,QAAQkB,gBAIzBrB,GAAiB7V,UAAUwT,IAAM,SAAU0E,GAEzC/B,GADkBpV,KACuBmX,EAAK,GAAIA,EAAK,KAGzDrC,GAAiB7V,UAAUmY,MAAQ,WAEjCvB,GADkB7V,OAIpB8U,GAAiB7V,UAAUoY,SAAW,SAAUC,GAC9C,IAEMC,EAAgB9B,GADJzV,KACgDsX,EAAQ,IAa1E,OAVqB,MAAjBC,GACqBpb,EAAfob,EAAwB,GAAID,EAAQ,IAC5B,EAKF,GAId,KAAK,EAED,OAAO,EAGX,KAAK,EAED,OAAO,IAKfxC,GAAiB7V,UAAUuY,OAAS,SAAUC,EAAOC,GAEnDtF,IAAe,SAAgBuF,EAAOtT,GACpCoT,EAAMC,EAAaC,GAAStT,IAFZrE,OAMpBtB,OAAO6L,eAAeuK,GAAiB7V,UAAW,QAAS,CACzD,IAAO,WAEL,OAAgD,EAAzC+W,GADWhW,SAItBtB,OAAO6L,eAAeuK,GAAiB7V,UAAW,aAAc,CAC9D,IAAO,WACL,OAAO,KAIX6V,GAAiB7V,UAAU2Y,OAAS,SAAUC,GAC5C,IACMC,EAAgBrC,GADJzV,KACgD6X,EAAQ,IAE1E,GAAqB,MAAjBC,EAAuB,CAGzB,GAAI3b,EAFY2b,EAEG,GAAID,EAAQ,IACZjB,GAPH5W,KAO8C6X,EAAQ,IAItE,OAAO,EAEP,OAAO,GAIXnZ,OAAO6L,eAAeuK,GAAiB7V,UAAW,OAAQ,CACxD,IAAO,WAEL,OAAgD,EAAzC+W,GADWhW,SAKtB8U,GAAiB7V,UAAU8W,MAAQ,WAEjCF,GADkB7V,OAIpB8U,GAAiB7V,UAAU8Y,OAAS,SAAUC,GAE5C,OAAOpB,GADW5W,KACgCgY,IAGpDlD,GAAiB7V,UAAUgZ,QAAU,WAEnC,OAAOne,IAAI,SAAiBR,GAC1B,OAAOA,IAFS0G,OAMpB8U,GAAiB7V,UAAU/E,IAAM,SAAUge,GAEzC,OAzPK,SAA2CC,EAAUC,GAC1D,IAAMC,EAAgB5C,GAAiC0C,EAAUC,GAEjE,GAAqB,MAAjBC,EAEF,OADgBA,EACD,GAEf,MAAM,IAAIna,MAAM,wCAkPXoa,CADWtY,KACkCkY,IAGtDpD,GAAiB7V,UAAUhF,IAAM,SAAUse,GAEzC,OA7KK,SAA8CC,EAAUC,GAC7D,IAAMC,EAAgBrD,GAAsCmD,EAAUC,GAatE,OAVIC,EAAc,IACZA,EAAc,IAAM,EACR,EAKF,GAId,KAAK,EAED,OAAO,EAGX,KAAK,EAED,OAAO,GAuJNC,CADW3Y,KACqCuY,IAGzDzD,GAAiB7V,UAAUuB,KAAO,WAEhC,OAAO1G,IAAI,SAAoB8e,GAC7B,OAAOA,EAAQ,KAFC5Y,OAMpB8U,GAAiB7V,UAAUrE,IAAM,SAAUie,EAAOC,GAGhD,OAjQK,SAA4CC,EAAUC,EAAMlG,GACjE,IAAMmG,EAAgB5D,GAAsC0D,EAAUC,GAatE,OAVIC,EAAc,IACZA,EAAc,IAAM,EACR,EAKF,GAId,KAAK,EAEDza,EAAgBua,EAAS9D,QAASgE,EAAc,IAAIA,EAAc,IAAM,CAACD,EAAMlG,GAC/E,MAGJ,KAAK,EAED,GAAImG,EAAc,GACFza,EAAgBua,EAAS9D,QAASgE,EAAc,IAAI/S,KAAK,CAAC8S,EAAMlG,SAG9EiG,EAAS9D,QAAQra,IAAIqe,EAAc,GAAI,CAAC,CAACD,EAAMlG,MAqOvDoG,CADkBlZ,KAC4B6Y,EAAOC,GADnC9Y,MAKpB8U,GAAiB7V,UAAUkX,OAAS,WAElC,OAAOrc,IAAI,SAAoBqf,GAC7B,OAAOA,EAAQ,KAFCnZ,OC3Vb,IAAMoZ,GAAgBva,GAAQ,SAAqBqB,EAAKC,GAAkB,IAAD,uBAARC,EAAQ,iCAARA,EAAQ,kBAC9EH,EAAMmC,KAAN,MAAAnC,EAAK,CAAMD,KAAME,EAAKC,GAAjB,OAA0BC,MAC9BH,GA+BI,SAASoZ,GAAqB/f,GACnC,OA5BK,SAASggB,EAAwBC,EAASC,GAC/CF,EAAyB,OAAa,CACpC,IAAMrH,EAAMsH,EACNE,EAAID,EAEV,OAAQC,EAAEvZ,KACR,KAAK,EAED,OAAO+R,EAAM,EAAI,EAGrB,KAAK,EAEDsH,EAAUD,EAAwBrH,EAAM,EAAGwH,EAAErZ,OAAO,IACpDoZ,EAAQC,EAAErZ,OAAO,GACjB,SAASkZ,EAGb,QAEI,OAAa,EAANrH,EAIb,OAIKqH,CAAwB,EAAGhgB,GAgI7B,SAASogB,GAAqBC,EAAkBC,EAAWC,GAChEH,EAAsB,OAAa,CACjC,IAAMI,EAAcH,EACdX,EAAOY,EACPG,EAAOF,EAEb,OAAQE,EAAK7Z,KACX,KAAK,EAID,GAAa,KAF4C,EAA5C4Z,EAAYE,QAAQhB,EAAMe,EAAK3Z,OAAO,KAGjD,OAAO2Z,EAAK3Z,OAAO,GAEnB,MAAM,IAAIlC,MAAM,iBAItB,KAAK,EAED,IAAM+b,EAAmD,EAA5CH,EAAYE,QAAQhB,EAAMe,EAAK3Z,OAAO,IAEnD,GAAI6Z,EAAO,EAAG,CACZN,EAAmBG,EACnBF,EAAYZ,EACZa,EAAYE,EAAK3Z,OAAO,GACxB,SAASsZ,EACJ,GAAa,IAATO,EACT,OAAOF,EAAK3Z,OAAO,GAEnBuZ,EAAmBG,EACnBF,EAAYZ,EACZa,EAAYE,EAAK3Z,OAAO,GACxB,SAASsZ,EAIf,QAEI,MAAM,IAAIxb,MAAM,iBAItB,OAuMG,SAASgc,GAAoBC,EAAmBC,EAAYC,GACjEH,EAAqB,OAAa,CAChC,IAAMI,EAAeH,EACfI,EAAQH,EACRI,EAAOH,EAEb,OAAQG,EAAKta,KACX,KAAK,EAED,OAAuD,IAAhDoa,EAAaN,QAAQO,EAAOC,EAAKpa,OAAO,IAGnD,KAAK,EAED,IAAMqa,EAAqD,EAA9CH,EAAaN,QAAQO,EAAOC,EAAKpa,OAAO,IAErD,GAAIqa,EAAO,EAAG,CACZN,EAAoBG,EACpBF,EAAaG,EACbF,EAAYG,EAAKpa,OAAO,GACxB,SAAS8Z,EACJ,GAAa,IAATO,EACT,OAAO,EAEPN,EAAoBG,EACpBF,EAAaG,EACbF,EAAYG,EAAKpa,OAAO,GACxB,SAAS8Z,EAIf,QAEI,OAAO,EAIb,OAgWG,IAAMQ,GAAsC7b,GAAQ,SAAuCyD,EAAMC,GACtGvC,KAAKgC,MAAQM,EACbtC,KAAK2a,QAAUpY,IACd1B,GAII,SAAS+Z,GAA4BC,GACb,OAAa,CACxC,IAAM7Y,EAAQ6Y,EAEd,GAAkB,MAAd7Y,EAAMpC,KAWR,OAAO,IAAIG,EAVX,GAAuB,IAAnBiC,EAAMlC,KAAKI,IACb,OAAO8B,EACqB,IAAnBA,EAAMlC,KAAKI,IAIpB2a,EAAc7Y,EAAMpC,KAHpBib,EAAc,IAAI9a,EAAKiC,EAAMlC,KAAKM,OAAO,GAAI,IAAIL,EAAK,IAAIqZ,GAAc,EAAG,SAAUpX,EAAMlC,KAAKM,OAAO,GAAI4B,EAAMlC,KAAKM,OAAO,IAAK,IAAIL,EAAKiC,EAAMlC,KAAKM,OAAO,GAAI4B,EAAMpC,SAaxK,SAASkb,GAA2BC,GACzC,OAAO,IAAIL,GAAoCE,GAA4B,IAAI7a,EAAKgb,EAAM,IAAIhb,KAAU,GAQnG,SAASib,GAAwBC,GACtC,GAAIA,EAAKN,QAAS,CAChB,IAAMlE,EAAgBwE,EAAKjZ,MAE3B,GAA0B,MAAtByU,EAAc7W,KAChB,OARC,WACL,MAAM,IAAI1B,MAAM,gCAOLgd,GACF,GAA+B,IAA3BzE,EAAc3W,KAAKI,IAC5B,MAAO,CAACuW,EAAc3W,KAAKM,OAAO,GAAIqW,EAAc3W,KAAKM,OAAO,IAEhE,MAAM,IAAIlC,MAAM,mEAGlB,OAlBG,WACL,MAAM,IAAIA,MAAM,2BAiBPid,GAoBJ,IAAMC,GAA6Cvc,GAAQ,SAA0Cwc,GACzFrb,KACRjF,EAAIsgB,EADIrb,KAERhF,EAAI8f,GAFI9a,KAEgCjF,MA8B5C,SAASugB,GAA8BC,GAC5C,OA1BK,SAA2EF,GAChF,OAAOrb,gBAAgBob,GAA6CA,GAA2ChZ,KAAKpC,KAAMqb,GAAQ,IAAID,GAA2CC,GAyB1KG,CAAkED,GAEpE,SAASE,GAAsBC,GAEpC,OAAOjK,IAAO,SAAmBkK,GAC/B,OAAIA,EAAM1K,WACD,CAAC0K,EAAMzK,QAASyK,GAEhB,OALAL,GAA8BI,IA1B3Chd,OAAO6L,eAAe6Q,GAA2Cnc,UAAW,UAAW,CACrF,IAAO,WAGL,OAAO+b,GAFIhb,KAEuBhF,MAItCogB,GAA2Cnc,UAAUgS,SAAW,WAG9D,OAvCK,SAAkC2K,GACvC,GAAIA,EAAKjB,QAAS,CAChB,IAAMjC,EAAgBkD,EAAK5Z,MAE3B,GAA0B,MAAtB0W,EAAc9Y,KAChB,OAAO,EACF,GAA+B,IAA3B8Y,EAAc5Y,KAAKI,IAE5B,OADA0b,EAAK5Z,MAAQ4Y,GAA4BlC,EAAc9Y,QAC3B,MAAnBgc,EAAK5Z,MAAMpC,MAEpB,MAAM,IAAI1B,MAAM,oEAIlB,OADA0d,EAAKjB,SAAU,IACa,MAAnBiB,EAAK5Z,MAAMpC,MAyBfic,CAFO7b,KAEwBhF,IAGxCogB,GAA2Cnc,UAAU6c,MAAQ,WAC7C9b,KAERhF,EAAI8f,GAFI9a,KAE6BjF,IAG7CqgB,GAA2Cnc,UAAUrF,QAAU,aAexD,IAAMmiB,GAAYld,GAAQ,SAAiBmd,EAAcC,GAC7Cjc,KACR5C,SAAW4e,EADHhc,KAERic,KAAOA,KAWX,SAASC,GAAoBC,GAClC,OAAOA,EAAMF,KAQR,SAASG,GAA2BC,EAAOC,GAChD,OAAO5C,GAAqB2C,EAAMjf,SAAUkf,EAAOD,EAAMJ,MA2CpD,SAASM,GAAqBC,GACnC,OAAOnD,GAAqBmD,EAAOP,MAE9B,SAASQ,GAA8BC,EAAQC,GACpD,OAAOzC,GAAoBwC,EAAOtf,SAAUuf,EAAOD,EAAOT,MAY5DF,GAAU9c,UAAU6B,SAAW,WAG7B,MAAO,QAIIE,GAAK,KAJY4b,IAAO,SAAiBC,GAGlD,OAFahJ,GAAOP,GAAO,YACdqD,CAAKkG,EAAG,GACdC,CAAKD,EAAG,MAJH7c,OAKoB,KAGpC+b,GAAU9c,UAAUrD,YAAc,WAUhC,IATA,IAEMmhB,EAAc,SAAqBC,EAAOC,GAC9C,OAAQD,GAAS,GAAKC,EAAO,KAG3BC,EAAS,EACPC,EAAO7B,GAA8BY,GAP1Blc,OASVmd,EAAKlM,YAAY,CACtB,IACMmM,EADkBD,EAAKjM,QAE7BgM,EAASH,EAAYG,EAAQvhB,EAAeyhB,EAAwB,KACpEF,EAASH,EAAYG,EAAQvhB,EAAeyhB,EAAwB,KAGtE,OAA0B,EAAnB3W,KAAKJ,IAAI6W,IAGlBnB,GAAU9c,UAAU7C,OAAS,SAAUihB,GAErC,OAAoC,IADnBrd,KACD/C,UAAUogB,IAG5BtB,GAAU9c,UAAUoC,OAAOC,UAAY,WAGrC,OAAOyP,GAAWuK,GAFHtb,KAEwCic,QAGzDF,GAAU9c,UAAUhC,UAAY,SAAUmN,GACxC,IACIkT,EAAS,EACTC,GAAW,EACTC,EAAKlC,GAA8BY,GAH3Blc,OAKd,IACE,IAAMyd,EAAKnC,GAA8BY,GAAoB9R,IAE7D,IACE,MAAQmT,GAAsB,IAAXD,GAAsB,CACvC,IAAM/F,EAAgB,CAACiG,EAAGvM,WAAYwM,EAAGxM,YAEzC,GAAIsG,EAAc,GAChB,GAAIA,EAAc,GAAI,CACpB,IAAMmG,EAAOF,EAAGtM,QACVyM,EAAOF,EAAGvM,QACV0M,EAAmD,EAhBrD5d,KAgBgB5C,SAAS4c,QAAQ0D,EAAK,GAAIC,EAAK,IACnDL,EAAmB,IAAVM,EAAcA,EAAQ5gB,EAAQ0gB,EAAK,GAAIC,EAAK,SAErDL,EAAS,OAEF/F,EAAc,GACvB+F,GAAU,EAEVC,GAAW,EAIf,OAAgB,EAATD,EApBT,QAsBM3jB,EAAa8jB,IACfA,EAAG7jB,WA1BT,QA8BMD,EAAa6jB,IACfA,EAAG5jB,YAKT8E,OAAO6L,eAAewR,GAAU9c,UAAW,OAAQ,CACjD,IAAO,WAEL,OAAwC,EAAjCsd,GADUvc,SAKrB+b,GAAU9c,UAAU8W,MAAQ,WAC1B,MAAM,IAAI7X,MAAM,0BAGlB6d,GAAU9c,UAAU8Y,OAAS,SAAU8F,GACrC,MAAM,IAAI3f,MAAM,0BAGlB6d,GAAU9c,UAAUgZ,QAAU,WAE5B,OAAOwD,GAAsBS,GADZlc,QAInB+b,GAAU9c,UAAU/E,IAAM,SAAU4jB,GAElC,OAAO1B,GADUpc,KAC2B8d,IAG9C/B,GAAU9c,UAAUhF,IAAM,SAAU8jB,GAElC,OAAOtB,GADUzc,KAC8B+d,IAGjDhC,GAAU9c,UAAUuB,KAAO,WAGzB,OAAOoc,IAAO,SAAoBoB,GAChC,OAAOA,EAAM,KAFGvC,GAAsBS,GADvBlc,SAOnB+b,GAAU9c,UAAUrE,IAAM,SAAUqjB,EAAOC,GACzC,MAAM,IAAIhgB,MAAM,0BAGlB6d,GAAU9c,UAAUkX,OAAS,WAG3B,OAAOyG,IAAO,SAAoBuB,GAChC,OAAOA,EAAM,KAFG1C,GAAsBS,GADvBlc,SC/lCZ,IAAMoe,GAAmBvf,GAAQ,SAAsCwf,EAAOjhB,GACnF,IACM4X,EAAQ,IAAIpT,EAAU,MADX5B,KAER5C,SAAWA,EACpB4X,EAAMnT,SAHW7B,UAIRiV,QAAU,IAAIC,IAAI,IAJVlV,KAKR,aAAe,EACxBkS,IAAQ,SAAUiF,GACFmH,GAA6BtJ,EAAMnT,SAAUsV,KAE1DkH,MASL,SAASE,GAAsCjJ,EAAUvU,GACvD,IAAM9F,EAAuC,EAAnCqa,EAASlY,SAASxB,YAAYmF,GAClCwU,EAAa1b,EAAYyb,EAASL,QAASha,EAAG,MAEpD,OAAIsa,EAAW,GACN,EAAC,EAAMta,EAAGsa,EAAW,GAAGnM,WAAU,SAAU0J,GACjD,OAAOwC,EAASlY,SAAShB,OAAO2E,EAAG+R,OAG9B,EAAC,EAAO7X,GAAI,GAkChB,SAASujB,GAAwB1I,GACtCA,EAASb,QAAQc,QAEZ,SAAS0I,GAA4BxI,GAE1C,OAWK,EAXE1D,IAAM,SAAoBwC,GAC/B,OAAOA,EAAM5Z,SAFA8a,EAAShB,QAAQkB,SAGrB,CACTzD,QADS,WAEP,OAAO,GAGTD,IALS,SAKL2D,EAAOC,GACT,OAAOD,EAAQC,KAKd,SAASiI,GAA6BnG,EAAUC,GACrD,IAAMC,EAAgBkG,GAAsCpG,EAAUC,GAatE,OAVIC,EAAc,IACZA,EAAc,IAAM,EACR,EAKF,GAId,KAAK,EAED,OAAO,EAGX,KAAK,EAED,GAAIA,EAAc,GAAI,CACH7Z,EAAgB2Z,EAASlD,QAASoD,EAAc,IAAInS,KAAKkS,GAE1E,OAAO,EAGP,OADAD,EAASlD,QAAQra,IAAIyd,EAAc,GAAI,CAACD,KACjC,GAKV,SAASsG,GAAkC3F,EAAUC,GAC1D,IAAMC,EAAgBsF,GAAsCxF,EAAUC,GAatE,OAVIC,EAAc,IACZA,EAAc,IAAM,EACR,EAKF,GAId,KAAK,EAED,OAAO,EAGX,KAAK,EAED,OAAO,GAIR,SAAS0F,GAAgCrI,EAAUC,GACxD,IAAME,EAAgB8H,GAAsCjI,EAAUC,GAatE,OAVIE,EAAc,IACZA,EAAc,IAAM,EACR,EAKF,GAId,KAAK,EAGD,OADAjY,EAAgB8X,EAASrB,QAASwB,EAAc,IAAI9U,OAAO8U,EAAc,GAAI,IACtE,EAGX,KAAK,EAED,OAAO,GAKf2H,GAAiBnf,UAAUoC,OAAOC,UAAY,WAC5C,IACMkX,EAAWxY,KACjB,OAAO+Q,GAMHD,GANuBQ,IAAM,WAC/B,OAAOS,IAAQ,SAAU6M,GACvB,OAAO9kB,IAAI,SAAU+kB,GACnB,OAAOA,IACND,KACFpG,EAASvD,QAAQkB,gBAIxBiI,GAAiBnf,UAAUwT,IAAM,SAAU6E,GAExBgH,GADCte,KACuCsX,IAI3D8G,GAAiBnf,UAAUmY,MAAQ,WAEjCoH,GADkBxe,OAIpBoe,GAAiBnf,UAAUoY,SAAW,SAAUQ,GAE9C,OAAO6G,GADW1e,KACkC6X,IAGtDuG,GAAiBnf,UAAUuY,OAAS,SAAUC,EAAOC,GAEnDtF,IAAe,SAAgB0M,EAAMza,GACnCoT,EAAMC,EAAaoH,GAAQza,IAFXrE,OAMpBtB,OAAO6L,eAAe6T,GAAiBnf,UAAW,QAAS,CACzD,IAAO,WAEL,OAAgD,EAAzCwf,GADWze,SAItBtB,OAAO6L,eAAe6T,GAAiBnf,UAAW,aAAc,CAC9D,IAAO,WACL,OAAO,KAIXmf,GAAiBnf,UAAU2Y,OAAS,SAAUmH,GAE5C,OAAOJ,GADW3e,KACgC+e,IAGpDrgB,OAAO6L,eAAe6T,GAAiBnf,UAAW,OAAQ,CACxD,IAAO,WAEL,OAAgD,EAAzCwf,GADWze,SAKtBoe,GAAiBnf,UAAUuJ,IAAM,SAAUiQ,GAExB6F,GADCte,KACuCyY,GAEzD,OAHkBzY,MAMpBoe,GAAiBnf,UAAU+f,KAAO,SAAUlI,GAE1C,OAAOwH,GADWte,KAC6B8W,IAGjDsH,GAAiBnf,UAAU8W,MAAQ,WAEjCyI,GADkBxe,OAIpBoe,GAAiBnf,UAAU8Y,OAAS,SAAUC,GAE5C,OAAO2G,GADW3e,KACgCgY,IAGpDoG,GAAiBnf,UAAUhF,IAAM,SAAUie,GAEzC,OAAOwG,GADW1e,KACkCkY,IAGtDkG,GAAiBnf,UAAUuB,KAAO,WAEhC,OAAO1G,IAAI,SAAiBR,GAC1B,OAAOA,IAFS0G,OAMpBoe,GAAiBnf,UAAUkX,OAAS,WAElC,OAAOrc,IAAI,SAAoBmlB,GAC7B,OAAOA,IAFSjf,OAMpBoe,GAAiBnf,UAAUgZ,QAAU,WAEnC,OAAOne,IAAI,SAAoB0c,GAC7B,MAAO,CAACA,EAAMA,KAFExW,OC1Qb,IAAMkf,GAAgBrgB,GAAQ,SAAqBqB,EAAKC,GAAkB,IAAD,uBAARC,EAAQ,iCAARA,EAAQ,kBAC9EH,EAAMmC,KAAN,MAAAnC,EAAK,CAAMD,KAAME,EAAKC,GAAjB,OAA0BC,MAC9BH,GAkCI,SAASkf,GAAuBta,GACrC,OAAO,IAAIqa,GAAc,EAAG,SAAUra,GAEjC,SAASua,GAAwB9lB,EAAG+lB,EAAMC,EAAMrkB,GACrD,OAAO,IAAIikB,GAAc,EAAG,UAAW5lB,EAAG+lB,EAAMC,EAAMrkB,GA61BjD,IAAMskB,GAAsC1gB,GAAQ,SAAuCyD,EAAMC,GACtGvC,KAAKgC,MAAQM,EACbtC,KAAK2a,QAAUpY,IACd1B,GAII,SAAS2e,GAA4BC,GACb,OAAa,CACxC,IAAMzd,EAAQyd,EAEd,GAAkB,MAAdzd,EAAMpC,KAWR,OAAO,IAAIG,EAVX,GAAuB,IAAnBiC,EAAMlC,KAAKI,IACb,OAAO8B,EACqB,IAAnBA,EAAMlC,KAAKI,IAIpBuf,EAAczd,EAAMpC,KAHpB6f,EAAc,IAAI1f,EAAKiC,EAAMlC,KAAKM,OAAO,GAAI,IAAIL,EAAKof,GAAuBnd,EAAMlC,KAAKM,OAAO,IAAK,IAAIL,EAAKiC,EAAMlC,KAAKM,OAAO,GAAI4B,EAAMpC,SAa1I,SAAS8f,GAA2BC,GACzC,OAAO,IAAIJ,GAAoCC,GAA4B,IAAIzf,EAAK4f,EAAO,IAAI5f,KAAU,GAQpG,SAAS6f,GAAwB5kB,GACtC,GAAIA,EAAE2f,QAAS,CACb,IAAM5D,EAAgB/b,EAAEgH,MAExB,GAA0B,MAAtB+U,EAAcnX,KAChB,OARC,WACL,MAAM,IAAI1B,MAAM,+BAOL2hB,GACF,GAA+B,IAA3B9I,EAAcjX,KAAKI,IAC5B,OAAO6W,EAAcjX,KAAKM,OAAO,GAEjC,MAAM,IAAIlC,MAAM,mEAGlB,OAlBG,WACL,MAAM,IAAIA,MAAM,2BAiBP4hB,GAoBJ,IAAMC,GAAwClhB,GAAQ,SAAyCmhB,GACnFhgB,KACRjF,EAAIilB,EADIhgB,KAERhF,EAAI0kB,GAFI1f,KAEgCjF,MA8B5C,SAASklB,GAA8BC,GAC5C,OA1BK,SAAsEF,GAC3E,OAAOhgB,gBAAgB+f,GAAwCA,GAAsC3d,KAAKpC,KAAMggB,GAAS,IAAID,GAAsCC,GAyB5JG,CAA6DD,GA8O/D,SAASE,GAAwBC,EAAcC,EAAIC,GACxD,OAAe,IAAXD,EAAGpgB,IACU,IAAXqgB,EAAGrgB,IACE,GAEA,EAEW,IAAXqgB,EAAGrgB,IACL,EAEkG,EA5OtG,SAAuCsgB,EAAoBC,EAAUC,GAC1EC,EAA+B,OAAa,CAC1C,IAGIC,EAAcC,EAAOC,EAAOC,EAAKC,EAAKC,EAAOC,EAAOC,EAAQC,EAAQC,EAAKC,EAAOC,EAAOC,EAAKC,EAAQC,EAAKC,EAAQC,EAAOC,EAAOC,EAAQC,EAAQC,EAAQC,EAAQC,EAAQC,EAAQC,EAAQC,EAAQC,EAAQC,EAAKC,EAAQC,EAAQC,EAAQC,EAAQC,EAAQC,EAAKC,EAAQC,EAH/P/G,EAAewE,EACfwC,EAAKvC,EACLwC,EAAKvC,EA0GX,OAvGe,MAAXsC,EAAGpjB,KACU,MAAXqjB,EAAGrjB,KACe,IAAhBqjB,EAAGnjB,KAAKI,IACU,IAAhB8iB,EAAGljB,KAAKI,KACV0gB,EAAe,EACfG,EAAMiC,EAAGljB,KAAKM,OAAO,GACrB4gB,EAAMiC,EAAGnjB,KAAKM,OAAO,GACrB6gB,EAAQ+B,EAAGpjB,KACXshB,EAAQ+B,EAAGrjB,MACc,IAAhBojB,EAAGljB,KAAKI,IACa,IAA1B8iB,EAAGljB,KAAKM,OAAO,GAAGF,KACpB0gB,EAAe,EACfY,EAAMwB,EAAGljB,KAAKM,OAAO,GACrBqhB,EAASuB,EAAGljB,KAAKM,OAAO,GACxBshB,EAAMsB,EAAGljB,KAAKM,OAAO,GACrBuhB,EAASsB,EAAGnjB,KAAKM,OAAO,GACxBwhB,EAAQoB,EAAGpjB,KACXiiB,EAAQoB,EAAGrjB,OAEXghB,EAAe,EACf0B,EAASU,EAAGljB,KAAKM,OAAO,GACxBmiB,EAAMS,EAAGljB,KAAKM,OAAO,GACrBoiB,EAASQ,EAAGljB,KAAKM,OAAO,GACxBqiB,EAASO,EAAGpjB,OAGdghB,EAAe,GACf8B,EAASO,EAAGnjB,KAAKM,OAAO,GACxBuiB,EAASM,EAAGrjB,MAEW,IAAhBqjB,EAAGnjB,KAAKI,IACa,IAA1B+iB,EAAGnjB,KAAKM,OAAO,GAAGF,IACA,IAAhB8iB,EAAGljB,KAAKI,KACV0gB,EAAe,EACfO,EAAS6B,EAAGljB,KAAKM,OAAO,GACxBghB,EAAS6B,EAAGnjB,KAAKM,OAAO,GACxBihB,EAAM4B,EAAGnjB,KAAKM,OAAO,GACrBkhB,EAAQ0B,EAAGpjB,KACX2hB,EAAQ0B,EAAGrjB,MACc,IAAhBojB,EAAGljB,KAAKI,IACa,IAA1B8iB,EAAGljB,KAAKM,OAAO,GAAGF,KACpB0gB,EAAe,EACfkB,EAASkB,EAAGljB,KAAKM,OAAO,GACxB2hB,EAASiB,EAAGljB,KAAKM,OAAO,GACxB4hB,EAASiB,EAAGnjB,KAAKM,OAAO,GACxB6hB,EAASgB,EAAGnjB,KAAKM,OAAO,GACxB8hB,EAASc,EAAGpjB,KACZuiB,EAASc,EAAGrjB,OAEZghB,EAAe,EACf0B,EAASU,EAAGljB,KAAKM,OAAO,GACxBmiB,EAAMS,EAAGljB,KAAKM,OAAO,GACrBoiB,EAASQ,EAAGljB,KAAKM,OAAO,GACxBqiB,EAASO,EAAGpjB,OAGdghB,EAAe,GACfgC,EAASK,EAAGnjB,KAAKM,OAAO,GACxByiB,EAAMI,EAAGnjB,KAAKM,OAAO,GACrB0iB,EAASG,EAAGnjB,KAAKM,OAAO,GACxB2iB,EAASE,EAAGrjB,MAEW,IAAhBojB,EAAGljB,KAAKI,KACjB0gB,EAAe,EACfwB,EAASY,EAAGljB,KAAKM,OAAO,GACxBiiB,EAASW,EAAGpjB,MACa,IAAhBojB,EAAGljB,KAAKI,KACjB0gB,EAAe,EACf0B,EAASU,EAAGljB,KAAKM,OAAO,GACxBmiB,EAAMS,EAAGljB,KAAKM,OAAO,GACrBoiB,EAASQ,EAAGljB,KAAKM,OAAO,GACxBqiB,EAASO,EAAGpjB,OAEZghB,EAAe,GACfgC,EAASK,EAAGnjB,KAAKM,OAAO,GACxByiB,EAAMI,EAAGnjB,KAAKM,OAAO,GACrB0iB,EAASG,EAAGnjB,KAAKM,OAAO,GACxB2iB,EAASE,EAAGrjB,MAEW,IAAhBojB,EAAGljB,KAAKI,KACjB0gB,EAAe,EACfwB,EAASY,EAAGljB,KAAKM,OAAO,GACxBiiB,EAASW,EAAGpjB,MACa,IAAhBojB,EAAGljB,KAAKI,KACjB0gB,EAAe,EACf0B,EAASU,EAAGljB,KAAKM,OAAO,GACxBmiB,EAAMS,EAAGljB,KAAKM,OAAO,GACrBoiB,EAASQ,EAAGljB,KAAKM,OAAO,GACxBqiB,EAASO,EAAGpjB,OAEZghB,EAAe,EACfC,EAAQmC,EAAGpjB,KACXkhB,EAAQmC,EAAGrjB,MAGbghB,EAAe,EAGjBA,EADoB,MAAXqC,EAAGrjB,KACG,EAEA,EAGTghB,GACN,KAAK,EAED,OAAO,EAGX,KAAK,EAED,OAAO,EAGX,KAAK,EAED,OAAO,EAGX,KAAK,EAEDJ,EAAqBxE,EACrByE,EAAWI,EACXH,EAAWI,EACX,SAASH,EAGb,KAAK,EAED,IAAMuC,EAAwC,EAAjClH,EAAahC,QAAQ+G,EAAKC,GAEvC,GAAa,IAATkC,EACF,OAAc,EAAPA,EAEP1C,EAAqBxE,EACrByE,EAAWQ,EACXP,EAAWQ,EACX,SAASP,EAIf,KAAK,EAED,IAAMlG,EAA8C,EAAvCuB,EAAahC,QAAQmH,EAAQC,GAE1C,GAAa,IAAT3G,EACF,OAAc,EAAPA,EAEP+F,EAAqBxE,EACrByE,EAAW,IAAI1gB,EAAK,IAAImf,GAAc,EAAG,YAAaoC,GACtDZ,EAAW,IAAI3gB,EAAKshB,EAAKE,GACzB,SAASZ,EAIf,KAAK,EAED,IAAMwC,EAA8C,EAAvCnH,EAAahC,QAAQyH,EAAQE,GAE1C,GAAa,IAATwB,EACF,OAAc,EAAPA,EAEP3C,EAAqBxE,EACrByE,EAAW,IAAI1gB,EAAK2hB,EAAKE,GACzBlB,EAAW,IAAI3gB,EAAKyhB,EAAKK,GACzB,SAASlB,EAIf,KAAK,EAED,IAAM/C,EAA+C,EAAvC5B,EAAahC,QAAQ8H,EAAQE,GAE3C,GAAc,IAAVpE,EACF,OAAe,EAARA,EAEP4C,EAAqBxE,EACrByE,EAAW,IAAI1gB,EAAKgiB,EAAQG,GAC5BxB,EAAW,IAAI3gB,EAAKkiB,EAAQE,GAC5B,SAASxB,EAIf,KAAK,EAEDH,EAAqBxE,EACrByE,EAAW,IAAI1gB,EAAK,IAAImf,GAAc,EAAG,YAAa,IAAInf,EAAKof,GAAuBiD,GAASC,IAC/F3B,EAAWuC,EACX,SAAStC,EAGb,KAAK,EAEDH,EAAqBxE,EACrByE,EAAW,IAAI1gB,EAAKwiB,EAAK,IAAIxiB,EAAKqf,GAAwBkD,EAAQ,IAAIpD,GAAc,EAAG,YAAasD,EAAQ,GAAIC,IAChH/B,EAAWuC,EACX,SAAStC,EAGb,KAAK,GAEDH,EAAqBxE,EACrByE,EAAWuC,EACXtC,EAAW,IAAI3gB,EAAK,IAAImf,GAAc,EAAG,YAAa,IAAInf,EAAKof,GAAuBuD,GAASC,IAC/F,SAAShC,EAGb,KAAK,GAEDH,EAAqBxE,EACrByE,EAAWuC,EACXtC,EAAW,IAAI3gB,EAAK8iB,EAAK,IAAI9iB,EAAKqf,GAAwBwD,EAAQ,IAAI1D,GAAc,EAAG,YAAa4D,EAAQ,GAAIC,IAChH,SAASpC,EAIf,OAaOA,CAA8BN,EAAc,IAAItgB,EAAKugB,EAAI,IAAIvgB,GAAS,IAAIA,EAAKwgB,EAAI,IAAIxgB,IA/QlGrB,OAAO6L,eAAewV,GAAsC9gB,UAAW,UAAW,CAChF,IAAO,WAGL,OAAO2gB,GAFI5f,KAEuBhF,MAItC+kB,GAAsC9gB,UAAUgS,SAAW,WAGzD,OAvCK,SAAkCmS,GACvC,GAAIA,EAAKzI,QAAS,CAChB,IAAMpD,EAAgB6L,EAAKphB,MAE3B,GAA0B,MAAtBuV,EAAc3X,KAChB,OAAO,EACF,GAA+B,IAA3B2X,EAAczX,KAAKI,IAE5B,OADAkjB,EAAKphB,MAAQwd,GAA4BjI,EAAc3X,QAC3B,MAAnBwjB,EAAKphB,MAAMpC,MAEpB,MAAM,IAAI1B,MAAM,oEAIlB,OADAklB,EAAKzI,SAAU,IACa,MAAnByI,EAAKphB,MAAMpC,MAyBfyjB,CAFOrjB,KAEwBhF,IAGxC+kB,GAAsC9gB,UAAU6c,MAAQ,WACxC9b,KAERhF,EAAI0kB,GAFI1f,KAE6BjF,IAG7CglB,GAAsC9gB,UAAUrF,QAAU,aA4UnD,IAAM0pB,GAAYzkB,GAAQ,SAAiB0kB,EAActH,GAC7Cjc,KACR5C,SAAWmmB,EADHvjB,KAERic,KAAOA,KAQX,SAASuH,GAAwBC,GACtC,OAAOA,EAAMrmB,SAER,SAASsmB,GAAoBvH,GAClC,OAAOA,EAAMF,KAmIfqH,GAAUrkB,UAAU6B,SAAW,WAG7B,MAAO,QAGIE,GAAK,KAHY2iB,IAAO,SAAUC,GAE3C,OAAO9nB,OADY8nB,KAFP5jB,OAIoB,KAGpCsjB,GAAUrkB,UAAUrD,YAAc,WAKhC,IAJA,IACIiE,EAAM,EACJsd,EAAO8C,GAA8ByD,GAF1B1jB,OAIVmd,EAAKlM,YAAY,CAGtBpR,IAFoB,EAANA,IAEE,IAD4B,EAA/BlE,EAAewhB,EAAKjM,UACL,IAG9B,OAAuB,EAAhBzK,KAAKJ,IAAIxG,IAGlByjB,GAAUrkB,UAAU7C,OAAS,SAAUihB,GAErC,OAAgI,IAAzH+C,GAAwBoD,GADdxjB,MACiD0jB,GADjD1jB,MACgF0jB,GAAoBrG,KAGvHiG,GAAUrkB,UAAUhC,UAAY,SAAU4mB,GAExC,OAAiI,EAA1HzD,GAAwBoD,GADdxjB,MACiD0jB,GADjD1jB,MACgF0jB,GAAoBG,KAGvHP,GAAUrkB,UAAUoC,OAAOC,UAAY,WAErC,OAAOyP,GAAWkP,GAA8ByD,GADlC1jB,SCp3CT,SAASgS,GAAK8R,EAAWC,EAAeC,GACvC,OAAa,CACjB,IAAMC,EAAOH,EACPI,EAAWH,EACXI,EAAQH,EAEd,GAAkB,MAAdG,EAAMvkB,KAMR,OAAOskB,EALPJ,EAAYG,EACZF,EAAgBE,EAAKC,EAAUC,EAAMrkB,MACrCkkB,EAAaG,EAAMvkB,MASlB,SAASwI,GAAQgc,GACtB,OAAOpS,IAAK,SAAUqS,EAAQC,GAC5B,OAAO,IAAIvkB,EAAKukB,EAAMD,KACrB,IAAItkB,EAAQqkB,GA6PV,SAASlS,GAAQqS,EAAOC,GAC7BxS,IAAK,SAAUyS,EAAUC,GACvBH,EAAMG,KACL,KAAMF,G,iDCjZEG,GAAb,WACE,aAAgC,IAApBC,EAAmB,4EAC7B5kB,KAAK6kB,IAAM,EACX7kB,KAAK8kB,WAAaF,EAClB5kB,KAAK+kB,WAAa,IAAI7P,IAJ1B,qDAYI,IAAKlV,KAAK8kB,WAAY,CACpB9kB,KAAK8kB,YAAa,EADE,2BAGpB,YAA2B9kB,KAAK+kB,WAAhC,+CAA4C,EAC1CC,EAD0C,8BAHxB,sFAZ1B,kCAqBcxnB,GACV,IAAMyD,EAAKjB,KAAK6kB,IAIhB,OAFA7kB,KAAK+kB,WAAWnqB,IAAIoF,KAAK6kB,MAAOrnB,GAEzByD,IA1BX,qCA6BiBA,GACb,OAAOjB,KAAK+kB,WAAWhN,OAAO9W,KA9BlC,+BAiCWzD,EAAGynB,GACV,IAAMC,EAAIllB,KACJiB,EAAKjB,KAAKmlB,YAAqB,MAATF,EAAgBznB,EAAI,kBAAMA,EAAEynB,KACxD,MAAO,CACLrrB,QADK,WAEHsrB,EAAEE,eAAenkB,OAtCzB,kCAQI,OAAOjB,KAAK8kB,eARhB,KA6CaO,GAAb,YACE,aAAe,IAAD,6BACZ,8CAAM,+BACN3mB,OAAO4mB,eAAP5mB,OAAA,KAAAA,CAAA,GAA4B2mB,EAAuBpmB,WAFvC,EADhB,yCAA4Cf,QA0BrC,SAASqnB,GAAc/nB,GAC5B,OAAO,SAAAgoB,GACL,GAAIA,EAAIC,YAAYC,YAClBF,EAAIG,SAAS,IAAIN,SACZ,GAAIG,EAAII,WAAWC,oBACxBL,EAAII,WAAWE,QAAO,WACpB,IACEtoB,EAAEgoB,GACF,MAAOO,GACPP,EAAIQ,QAAQD,YAIhB,IACEvoB,EAAEgoB,GACF,MAAOO,GACPP,EAAIQ,QAAQD,KAKb,SAASE,GAAcC,EAAaC,GACzC,OAAOZ,IAAc,SAAAC,GACnBU,EAAY,CACVE,UAAW,SAAA9sB,GACT,IACE6sB,EAAO7sB,EAAP6sB,CAAUX,GACV,MAAOa,GACPb,EAAIQ,QAAQK,KAGhBL,QAASR,EAAIQ,QACbL,SAAUH,EAAIG,SACdF,YAAaD,EAAIC,YACjBG,WAAYJ,EAAII,gBAIf,SAASU,GAAgBnnB,GAC9B,OAAOomB,IAAc,SAAAC,GAAG,OAAIA,EAAIY,UAAUjnB,MAyFnB,IAvFzB,6FACO+mB,EAAaC,GAChB,OAAOF,GAAcC,EAAaC,KAFtC,8BAKUI,EAAcC,GACpB,OAAOxmB,KAAKymB,KAAKF,GAAc,kBAAMC,OANzC,4BASQE,GACJ,OAAOnB,IAAc,SAAAC,GAAG,OAAIkB,IAAYlB,QAV5C,0BAaMmB,EAAUC,GACZ,IAAMhW,EAAO+V,EAAStlB,OAAOC,YACzBC,EAAMqP,EAAKpP,OACf,OAAOxB,KAAK6mB,OAAM,kBAAOtlB,EAAIG,OAAM1B,KAAK8mB,OAAM,WAC5C,IAAMjnB,EAAM+mB,EAAKrlB,EAAIpC,OAErB,OADAoC,EAAMqP,EAAKpP,OACJ3B,QAnBb,6BAuBSV,GACL,OAAOmnB,GAAgBnnB,KAxB3B,iCA2Ba+mB,GACT,OAAOA,IA5BX,iCA+BaA,EAAaa,GACtB,OAAOxB,IAAc,SAAAC,GACnBU,EAAY,CACVE,UAAW,SAAA9sB,GACTytB,IACAvB,EAAIY,UAAU9sB,IAEhB0sB,QAAS,SAAA1sB,GACPytB,IACAvB,EAAIQ,QAAQ1sB,IAEdqsB,SAAU,SAAArsB,GACRytB,IACAvB,EAAIG,SAASrsB,IAEfmsB,YAAaD,EAAIC,YACjBG,WAAYJ,EAAII,kBA/CxB,8BAoDUM,EAAac,GACnB,OAAOzB,IAAc,SAAAC,GACnBU,EAAY,CACVE,UAAWZ,EAAIY,UACfT,SAAUH,EAAIG,SACdF,YAAaD,EAAIC,YACjBG,WAAYJ,EAAII,WAChBI,QAAS,SAAAK,GACP,IACEW,EAAaX,EAAbW,CAAiBxB,GACjB,MAAOyB,GACPzB,EAAIQ,QAAQiB,YA/DxB,4BAsEQC,EAAUf,GACd,OAAOnmB,KAAKmnB,WAAWhB,EAAOe,IAAW,kBAAMA,EAASttB,eAvE5D,4BA0EQwtB,EAAOlB,GAAc,IAAD,OACxB,OAAIkB,IACKpnB,KAAKymB,KAAKP,GAAa,kBAAM,EAAKW,MAAMO,EAAOlB,MAE/ClmB,KAAKqnB,YAAO,KA9EzB,6BAmFI,OAAO9B,IAAc,SAAAC,GAAG,OAAIA,EAAIY,eAAU,UAnF9C,MCjDwC,IAAIzB,GC5DrC,SAAS2C,GAAcC,EAAMlB,GAClCmB,QAAQC,MAAMzjB,GAAKujB,GAAOlB,GCCrB,SAASqB,GAAWC,EAAUC,GACnC1V,IAAQ,SAAgBnK,GACtBA,EAAI4f,KACHC,GAEE,SAASC,KACd,OAAO,IAAI9nB,ECPN,IAAM+nB,GAAe,IAAInkB,GAAM,IAAI5D,EAAQ,KAAM,IAAIgoB,EAAQ,EAAG,YAIvE,IAAMC,GCEC,SAAwBC,GAI7B,OAdF,SAAkBC,GAChB,IACMC,EADYD,EAAME,MAAM,KAAK,GACVjjB,QAAQ,KAAM,KAAKA,QAAQ,KAAM,KACpDkjB,EAAcC,mBAAmBC,KAAKJ,GAAQC,MAAM,IAAItuB,KAAI,SAAUwK,GAC1E,MAAO,KAAO,KAAOA,EAAElJ,WAAW,GAAG0F,SAAS,KAAKmE,OAAO,MACzDjE,KAAK,KACR,OAAOwnB,KAAK5jB,MAAMyjB,GAKJI,CAASR,IAAa,CAClCS,YAAa,KAEFA,aDJf,SAASC,GAAQC,GACf,IAAMF,EAAcV,GAAeY,GAE7BC,EAAgB,SAAuB1oB,GAC3C,OAAOuoB,EAAY1kB,MAAK,SAAU+H,GAChC,OAAOA,IAAM5L,MAIjB,OAAI0oB,EAAc,mBACT,IAAId,EAAQ,EAAG,SACbc,EAAc,kBAChB,IAAId,EAAQ,EAAG,UAEf,IAAIA,EAAQ,EAAG,WAInB,SAASe,GAAOpS,EAAKqS,GAC1B,IAAIllB,EAAoBH,EACxB,MAAO,EAAEG,EAAqB6S,EAAItW,OAAO,GAAKsD,EAAOilB,GAAQjS,EAAItW,OAAO,IAAK,IAAIuD,GAAMolB,EAAMnlB,OAAQC,EAAoBH,IAASslB,MExB7H,IAAMC,GAAkBpqB,GAAQ,SAA0BqB,EAAKC,GAAkB,IAAD,uBAARC,EAAQ,iCAARA,EAAQ,kBACrFH,EAAMmC,KAAN,MAAAnC,EAAK,CAAMD,KAAME,EAAKC,GAAjB,OAA0BC,MAC9BH,GAII,IAAMipB,GAAmBrqB,GAAQ,SAA2BoN,GACjE,ICgBmBkd,EAAQC,EAAavuB,EAAOsE,EDhB9Ba,KACRilB,MAAQ,IAAIgE,GAAgB,EAAG,YCerBE,EDfsC,IAAI5vB,MAAM4D,EAAIR,EAAmBsP,EAAM,KCerEmd,EDf2E,ECe9DvuB,EDfiEsC,EAAIR,EAAmBsP,EAAM,ICevF9M,EDf4F,KCgB3IgqB,EAAOE,KAAKlqB,EAAOiqB,EAAaA,EAAcvuB,GACvCsuB,GDjB2I,MAQ7I,SAASG,GAAsBC,GACpC,IAAMhU,EAAagU,EAAGtE,MAEtB,GAAuB,IAAnB1P,EAAWrV,IAAW,CACxB,IAAMspB,GAAYjU,EAAWnV,OAAO,GAAK,GAAKmV,EAAWnV,OAAO,GAAGjF,OAAS,EACtEya,EAAgB4T,IAAajU,EAAWnV,OAAO,GAQrD,OALEmpB,EAAGtE,MADDrP,EACS,IAAIqT,GAAgB,EAAG,WAAY1T,EAAWnV,OAAO,GAAImV,EAAWnV,OAAO,IAE3E,IAAI6oB,GAAgB,EAAG,eAAgB1T,EAAWnV,OAAO,GAAImV,EAAWnV,OAAO,GAAIopB,GAGzFxlB,GAAKuR,EAAWnV,OAAO,GAAGmV,EAAWnV,OAAO,KAEnD,OAAO,KAGJ,SAASqpB,GAA8BC,EAAOvS,GACnD,IAAMkB,EAAgBqR,EAAMzE,MAE5B,GAA0B,IAAtB5M,EAAcnY,IAAW,CAC3BmY,EAAcjY,OAAO,GAAGiY,EAAcjY,OAAO,IAAM+W,EACnD,IAAMwS,GAAYtR,EAAcjY,OAAO,GAAK,GAAKiY,EAAcjY,OAAO,GAAGjF,OAAS,EAC5E8d,EAAgB0Q,IAAatR,EAAcjY,OAAO,GAGtDspB,EAAMzE,MADJhM,EACY,IAAIgQ,GAAgB,EAAG,eAW3C,SAAsCjU,EAAO4U,EAAOC,GAUlD,OC2lCoBC,EDpmCFxY,IAAM,WACtB,OAAOH,GAAQmB,GAAKsX,EAAOC,GAAYvY,IAAM,WAC3C,OAAOH,GAAQwB,GAAKiX,EAAOC,GAAYvY,IAAM,WAC3C,OAAOS,IAAQ,SAAU0E,GACvB,OAAOpE,GAAU,QbgfpB,SAAqB0X,EAAOC,EAAMC,GACvC,GAAa,IAATD,EACF,MAAM,IAAI9rB,MAAM,oBAGlB,OAAOoT,IAAM,kBAAMG,IAAO,SAAAnY,GAAC,OAAI0wB,EAAO,GAAK1wB,GAAK2wB,GAAQD,EAAO,GAAK1wB,GAAK2wB,EAAO,CAAC3wB,EAAGA,EAAI0wB,GAAQ,OAAMD,Mapf7FG,CAAY,EAAG,EAAGL,EAAS1uB,oBC+lCLgvB,ED3lCP5wB,MC4lCjB4wB,EAAShpB,KAAK2oB,GADhB,IAAeA,EAAWK,EDhnC2BC,CAA6BV,EAAOrR,EAAcjY,OAAO,GAAIiY,EAAcjY,OAAO,IAAMiY,EAAcjY,OAAO,GAAGjF,OAAQ,GAEhK,IAAI8tB,GAAgB,EAAG,eAAgB5Q,EAAcjY,OAAO,GAAIupB,EAAUtR,EAAcjY,OAAO,QAE1G,CACLiY,EAAcjY,OAAO,GAAGiY,EAAcjY,OAAO,IAAM+W,EACnD,IAAMkT,GAAUhS,EAAcjY,OAAO,GAAK,GAAKiY,EAAcjY,OAAO,GAAGjF,OAAS,EAChFuuB,EAAMzE,MAAQ,IAAIgE,GAAgB,EAAG,eAAgB5Q,EAAcjY,OAAO,GAAIiqB,EAAQhS,EAAcjY,OAAO,KE/CxG,IAAMkqB,GAAgBzrB,GAAQ,SAAwByD,EAAMC,EAAMC,EAAM+nB,EAAMC,EAAMC,EAAMC,GAC/F1qB,KAAK2qB,KAAOroB,EACZtC,KAAK8oB,OAASvmB,EACdvC,KAAK4qB,UAAYpoB,EACjBxC,KAAK6qB,KAAON,EACZvqB,KAAK8qB,SAAWN,EAChBxqB,KAAKgmB,QAAUyE,EACfzqB,KAAK+qB,aAAeL,IACnB7pB,GAyFI,SAASmqB,GAAwBC,EAAQC,GAC9C,IAmCIC,EAnCEC,EAAkBF,EAAYP,KAAKM,GACnCI,EFzFD,SAAiDpf,GACtD,OAAOjM,gBAAgBkpB,GAAmBA,GAAiB9mB,KAAKpC,KAAMiM,GAAQ,IAAIid,GAAiBjd,GEwFxFqf,CAAoE,IAC3EC,GAAY,EACZC,EAAWJ,EAAgB,GA8BzBK,EAAkBrtB,EAAa,EAAG8sB,EAAYH,aAAc,CA5BjD,SAAkBW,GACjC,IAAI/U,EAEJ,GAAI4U,EACFI,GAAkDN,EAAIK,OACjD,CACLH,GAAY,EAGZ,IAFA,IAAIK,EAAU5nB,GAAK0nB,GAED,MAAXE,GAAiB,CACtB,IAAMC,EAAShN,GAAS+M,GAExB,IACE,IAAME,EAAkBZ,EAAYpC,OAAO+C,EAAQL,GACnDN,EAAYJ,SAASgB,EAAgB,GAAIL,GACzCM,GAAuBN,EAAiBK,EAAgB,IACxDN,EAAWM,EAAgB,GAC3B,MAAOE,GACPd,EAAYlF,QAAQ,EAAErP,EAAO9C,GAAOP,GAAO,sCAAuCqD,EAAKkV,IAAUG,IAGnGJ,EAAUK,GAAkCZ,GAG9CE,GAAY,MAKhBL,EAAYJ,SAASM,EAAgB,GAAIK,GAGzC,IACEN,EAASD,EAAYN,UAAUQ,EAAgB,IAC/C,MAAOc,GACPhB,EAAYlF,QAAQ,CAAC,uBAAwBkG,IAC7Cf,EAASnC,KAGX,ITyLqBmD,ESzLfC,GTyLeD,ESzLChB,ET0LfnZ,IAAK,SAAUqa,EAASC,GAC7B,OAAO,IAAIvsB,EAAKusB,EAAOD,KS3LKjB,EAAgB,GT4LnChjB,GAAQ+jB,KS3LnBJ,GAAuBN,EAAiBW,GCtJdvtB,GAAQ,SAAwCqB,EAAKC,GAAkB,IAAD,uBAARC,EAAQ,iCAARA,EAAQ,kBAChGH,EAAMmC,KAAN,MAAAnC,EAAK,CAAMD,KAAME,EAAKC,GAAjB,OAA0BC,MAC9BH,GAIiBpB,GAAQ,SAAgCqB,EAAKC,GAAkB,IAAD,uBAARC,EAAQ,iCAARA,EAAQ,kBAChFH,EAAMmC,KAAN,MAAAnC,EAAK,CAAMD,KAAME,EAAKC,GAAjB,OAA0BC,MAC9BH,GAI0BpB,GAAQ,SAAyCyD,GAC5EtC,KAAKusB,OAASjqB,IACbzB,GAIoBhC,GAAQ,SAAmCqB,EAAKC,GAAkB,IAAD,uBAARC,EAAQ,iCAARA,EAAQ,kBACtFH,EAAMmC,KAAN,MAAAnC,EAAK,CAAMD,KAAME,EAAKC,GAAjB,OAA0BC,MAC9BH,GAIoBpB,GAAQ,SAAmCqB,EAAKC,GAAkB,IAAD,uBAARC,EAAQ,iCAARA,EAAQ,kBACtFH,EAAMmC,KAAN,MAAAnC,EAAK,CAAMD,KAAME,EAAKC,GAAjB,OAA0BC,MAC9BH,GAIqBpB,GAAQ,SAAoCqB,EAAKC,GAAkB,IAAD,uBAARC,EAAQ,iCAARA,EAAQ,kBACxFH,EAAMmC,KAAN,MAAAnC,EAAK,CAAMD,KAAME,EAAKC,GAAjB,OAA0BC,MAC9BH,GAIoBpB,GAAQ,SAAmCqB,EAAKC,GAAkB,IAAD,uBAARC,EAAQ,iCAARA,EAAQ,kBACtFH,EAAMmC,KAAN,MAAAnC,EAAK,CAAMD,KAAME,EAAKC,GAAjB,OAA0BC,MAC9BH,GChCI,SAASusB,GAAkCC,EAAUC,GAC1D,OAAOC,OAAWD,EAAWD,GCJE5tB,GAAQ,eCGlC,IAAM+tB,GAAa/tB,GAAQ,SAAwCyD,EAAMC,GAC9EvC,KAAK2D,MAAQrB,EACbtC,KAAK6sB,SAAWtqB,IACf1B,GAIH,IACaisB,GAAaH,qBADE,GAEfI,GDRN,SAA2CC,EAAQC,EAAaC,EAAaC,GAClF,GAAmB,MAAfF,OAA6B,CAC/B,IAAM9sB,EAAO8sB,EACbD,EAAOC,YAAc9sB,EAGvB,IAAIitB,EAEJ,GAA6B,MAAzBjvB,EAAM,EAAG+uB,GACXE,EAAWJ,MACN,CACL,IACMK,EAAcC,GADHJ,EAC2DF,GAE5E,GAAmB,MAAfC,OAA6B,CAC/B,IAAMM,EAAUN,EAChBI,EAAYJ,YAAc,QAAUM,EAAU,IAGhDH,EAAWC,EAGb,OAAO,SAAUG,GACf,IAAIC,EAEJ,GAAe,MAAXN,EACFM,EAAWD,MACN,CACL,IAAME,EAAOP,EACbK,EAAMzzB,IAAM2zB,EAAKF,GACjBC,EAAWD,EAIb,OAAOb,gBAAA,MAAAA,EAAK,CAAeS,EAAUK,GAAzB,OADK,MCzBQE,EAAsD,SAAUH,GAC3F,IAAMvI,EAAQ0H,WAAe,IAAIC,GAAW9E,IAAc,SAAU3oB,QAGpEwtB,aAAgB,WACd,IJDoD9B,EIC9C+C,EJAD,IAAItD,IIA6C,WACpD,MRjBG,CAACxC,GAAckB,QQkBjBF,IJFkC,SAAU+E,GAC/C,OAAO7E,OAF6C6B,EIGzC,SAAc9B,EAAOpB,GAC9B1C,EAAM,GAAG,IAAI2H,GAAW7D,EAAOpB,MJD1B,SAAkBoB,EAAO+E,GAClBjD,EAAK9B,EAAO+E,MAEzB,SAAUC,GACXC,GAA0BD,EAAU,GAAIA,EAAU,MACjDzwB,EAAQ,GAAG,SAAUhE,GACtB,OAAOA,MA6HT0xB,GAAwB,KIhIU4C,KAC/B,IAAIr0B,MAAM,IACb,IAAM00B,EAAWhJ,EAAM,GACjBiJ,EAAW,CAACV,EAAMU,UACxB,OAAOvB,gBAAA,MAAAA,EAAK,CAAeG,GAAWqB,SAAU,CAC9ChvB,MAAO8uB,IADG,OAENC,MACL,iBFFI,SAA0CjP,EAAMmP,GACrD,GAAInP,IAASmP,EACX,OAAO,EACF,GAAoB,kBAATnP,GAAsBA,EAAK5d,OAAOC,WAAsB,MAAR8sB,EAehE,OAAO,EATP,IALA,IAAMC,EAAU3vB,OAAO8B,KAAKye,GACtBqP,EAA6B,EAAjBD,EAAQlzB,OACtBioB,EAAO,EACPmL,GAAY,EAETnL,EAAOkL,GAAYC,GAAmB,CAC3C,IAAMC,EAASH,EAAQjL,GACvBA,GAAc,EACd,IAAMqL,EAAYxP,EAAKuP,GACvBD,EAAiC,oBAAdE,GAAkCA,IAAcL,EAAKI,GAG1E,OAAOD,KG1BJ,SAASG,KACd,IAjBSC,EAiBHC,EALkBjC,aAAiBG,IAClBD,SAKvB,OAlBS8B,EAkBA,SAAUzG,GACjB0G,EAAY,IAAI9qB,GAAI,EAAG,WAAYokB,KAlB9B,SAAU2G,GACf,OAAOF,EAAEE,IAoBN,SAASC,KACd,IAAMC,EAhBepC,aAAiBG,IAClBnpB,MAgBpB,OAAO6kB,KAAKxiB,UAAU+oB,EAAUzxB,EAAQ,EAAG,MAAO0G,GAAK,IC3BzD,IAUegrB,GAVF,WACT,IAAMjG,EAAQ+F,KACd,OACI,oCACQ,6BACJ,8BAAO/F,KCEJkG,GARE,WACb,OACI,gD,sDCwCOC,GAxCK,WAAO,IAAD,EAC0BC,aAAQ,CACxDhvB,KAAM,GACNivB,SAAU,CAAC,EAAG,GACdC,MAAO,EACPC,SAAS,EACTC,OAAQ,KALFC,EADgB,EAChBA,SAAUC,EADM,EACNA,aAAcC,EADR,EACQA,OAAQC,EADhB,EACgBA,MAYxC,OAFAnI,QAAQ9X,IAAIigB,EAAM,SAGhB,yBAAKC,UAAW,uBACd,yBAAKA,UAAU,aACb,mDACA,kBAACC,GAAA,EAAD,CAAMC,SAAUL,GARL,SAAAtZ,QAST,kBAAC4Z,GAAA,EAAD,KACE,kBAACC,GAAA,EAAD,CAAOC,IAAI,QAAX,SACA,kBAACC,GAAA,EAAD,CACEC,KAAK,OACLhwB,KAAK,OACLiwB,aAAa,MACbC,SAAUb,EACVc,QAASZ,EAAOvvB,KAChBowB,YAAY,8CAGhB,yBAAKX,UAAU,cACb,kBAACY,GAAA,EAAD,CAAQL,KAAK,SAASM,MAAM,WAA5B,cChCNC,GAAa,UAAMtB,SAASuB,SAAf,aAA4BvB,SAASwB,MAWzCC,GATK,CAClBC,OAAQC,qBACRC,UAAWD,mCACXE,SAAUF,qBACVG,aAAa,GAAD,OAAKR,GAAL,UACZS,MAAOJ,gCACPK,mBAAoB,kBAAMC,mBAAS,O,yDCP/BC,GAA4B,kBAChCC,OAAOC,QAAQC,aAAa,GAAIC,SAASC,MAAOJ,OAAOnC,SAASwC,WAErDC,GAAeC,IAAMC,gBACrBC,GAAW,kBAAMC,qBAAWJ,KAC5BK,GAAgB,SAAC,GAIvB,IAHLhE,EAGI,EAHJA,SAGI,IAFJkD,0BAEI,MAFiBE,GAEjB,EADDa,EACC,oDAC0CC,qBAD1C,mBACGC,EADH,KACoBC,EADpB,OAEoBF,qBAFpB,mBAEGG,EAFH,KAESC,EAFT,OAG4BJ,qBAH5B,mBAGGK,EAHH,KAGgBC,EAHhB,OAI0BN,oBAAS,GAJnC,mBAIGO,EAJH,KAIYC,EAJZ,OAK8BR,oBAAS,GALvC,mBAKGS,EALH,KAKcC,EALd,KAOJC,qBAAU,YACO,yCAAG,qCAAApsB,EAAA,sEACYqsB,KAAkBb,GAD9B,UACVc,EADU,OAEhBP,EAASO,IAEL1B,OAAOnC,SAAShqB,OAAO8tB,SAAS,SAJpB,iCAKaD,EAAcE,yBAL3B,gBAKNC,EALM,EAKNA,SACRhC,EAAmBgC,GANL,yBAScH,EAAcZ,kBAT5B,WASVA,EATU,OAWhBC,EAAmBD,IAEfA,EAbY,kCAcKY,EAAcI,UAdnB,QAcRd,EAdQ,OAedC,EAAQD,GAfM,QAkBhBK,GAAW,GAlBK,4CAAH,qDAoBfU,KAEC,IAEH,IAAMC,EAAc,yCAAG,2CAAA5sB,EAAA,6DAAO6sB,EAAP,+BAAgB,GACrCV,GAAa,GADQ,kBAGbL,EAAYc,eAAeC,GAHd,uDAKnBhM,QAAQC,MAAR,MALmB,yBAOnBqL,GAAa,GAPM,sCASFL,EAAYY,UATV,QASfd,EATe,OAUrBC,EAAQD,GACRD,GAAmB,GAXE,+DAAH,qDAcda,EAAsB,yCAAG,6BAAAxsB,EAAA,6DAC7BisB,GAAW,GADkB,SAEvBH,EAAYU,yBAFW,uBAGVV,EAAYY,UAHF,OAGvBd,EAHuB,OAI7BK,GAAW,GACXN,GAAmB,GACnBE,EAAQD,GANqB,2CAAH,qDAS5B,OACE,kBAACV,GAAa1D,SAAd,CACEhvB,MAAO,CACLkzB,kBACAE,OACAI,UACAE,YACAU,iBACAJ,yBACAM,iBAAkB,kBAAUhB,EAAYgB,iBAAZ,MAAAhB,EAAW,YACvCiB,kBAAmB,kBAAUjB,EAAYiB,kBAAZ,MAAAjB,EAAW,YACxCkB,iBAAkB,kBAAUlB,EAAYkB,iBAAZ,MAAAlB,EAAW,YACvCmB,kBAAmB,kBAAUnB,EAAYmB,kBAAZ,MAAAnB,EAAW,YACxCoB,OAAQ,kBAAUpB,EAAYoB,OAAZ,MAAApB,EAAW,cAG9BvE,ICjFM4F,GAASjD,GACTkD,GAAclD,GAAYK,aCYxB8C,GAZG,WAAO,IACfL,EAAqB3B,KAArB2B,iBADc,EAEIvB,qBAFJ,mBAEflK,EAFe,KAER+L,EAFQ,KAStB,OANAlB,qBAAU,WACRY,IAAmBO,MAAK,SAAAhM,GACtB+L,EAAS/L,QAEV,CAACyL,EAAkBzL,IAEf,6BAAMA,ICTA,IACb,IAAK,kBAAM,kBAAC,GAAD,OACX,SAAU,kBAAM,kBAAC,GAAD,OAChB,gBAAiB,kBAAM,kBAAC,GAAD,Q,+DC0FViM,GAlFI,SAAC,GAAc,IAAZC,EAAW,EAAXA,KAAW,EACGhC,oBAAS,GADZ,mBACxBiC,EADwB,KACbC,EADa,OAE8BtC,KAArD0B,EAFuB,EAEvBA,kBAAmBG,EAFI,EAEJA,OAAQxB,EAFJ,EAEIA,gBAAiBE,EAFrB,EAEqBA,KAE9CgC,EAAOC,oBASTC,EAAcpC,EAChB,kBAACqC,GAAA,EAAD,CAASC,QALW,SAAAC,GACpBA,EAAGC,iBACHhB,MAIE,kBAACiB,GAAA,EAAD,CAASC,KAAM,KAAf,cAGF,kBAACL,GAAA,EAAD,CAASC,QAbU,SAAAC,GACnBA,EAAGC,iBACHnB,EAAkB,CAAExC,aAAc6C,OAYhC,kBAACe,GAAA,EAAD,CAASC,KAAM,KAAf,aAIEC,EAAczC,GAClB,0BAAM3C,UAAW,yCACf,yBAAKqF,IAAK1C,EAAK2C,QAAStF,UAAW,SAAUuF,IAAK,gBACjD5C,EAAK6C,UAIJC,EAAU,SAACC,EAAMn1B,GACrB,IAAMo1B,EAAWD,IAASf,EAC1B,OACE,kBAACG,GAAA,EAAD,CAAS36B,IAAKu7B,GACZ,kBAACR,GAAA,EAAD,CAASC,KAAMO,EAAMp1B,IAAKs1B,IAAGC,OAAQF,GAClCp1B,KAMHu1B,EAAkB,WACtB,IAAKrD,EACH,MAAO,CAACgD,EAAQ,MAEhB,OAAQjB,GACN,IAAK,QACL,IAAK,SACH,MAAO,CACLiB,EAAQ,IAAK,UACbA,EAAQ,gBAAiB,uBACzBA,EAAQ,eAAgB,cACxBA,EAAQ,SAAU,aAClBA,EAAQ,YAAa,iBAEzB,QACE,MAAO,CAACA,EAAQ,IAAK,UAAWA,EAAQ,YAAa,kBAfrC,GAoBxB,OACE,kBAACM,GAAA,EAAD,CAAQlF,MAAM,UAAUmF,MAAI,EAACC,OAAQ,MACnC,kBAACC,GAAA,EAAD,CAAaf,KAAM,KACjB,yBAAKE,IAAK,qBAAsBE,IAAK,qBAEvC,kBAACY,GAAA,EAAD,CAAepB,QAAS,kBAAML,GAAcD,MAC5C,kBAAC2B,GAAA,EAAD,CAAUC,QAAS5B,EAAW6B,QAAM,GAClC,kBAACC,GAAA,EAAD,CAAKD,QAAM,EAACtG,UAAU,WACnB8F,EACAjB,GAEFO,KCvEMoB,GAZC,SAAC,GAAY,IAAXC,EAAU,EAAVA,KACd,OACI,yBAAKp1B,GAAI,aACL,yBAAKA,GAAG,UAAUo1B,KCkCfC,GA/BA,WACb,IAAMC,EAAcC,oBAAUC,IADX,EAEuBzE,KAApCW,EAFa,EAEbA,QAASJ,EAFI,EAEJA,KAAMoB,EAFF,EAEEA,iBAErBZ,qBAAU,WACR,IAAMwB,EAAOmC,aAAaC,QAAQ,QAC9BpC,IACFmC,aAAaE,WAAW,QACxBvF,mBAASkD,MAEV,IAEH,IAAMN,EAAWvF,KASjB,OARAqE,qBAAU,YACJJ,GAAWJ,GACboB,IAAmBO,KAAKD,KAEzB,CAACtB,EAASJ,EAAMoB,EAAkBM,IAEjBtB,EAGlB,kBAAC,GAAD,MAEA,8BACE,kBAAC,GAAD,CAAYyB,KAAM,UACjBmC,GAAe,kBAAC,GAAD,QCpBPM,OAVf,WACE,OACE,kBAAC,GAAkB/C,GACjB,kBAAC/G,GAAD,KACE,kBAAC,GAAD,SCGY+J,QACW,cAA7BvF,OAAOnC,SAAS2H,UAEe,UAA7BxF,OAAOnC,SAAS2H,UAEhBxF,OAAOnC,SAAS2H,SAASC,MACvB,2DCXNC,IAASjK,OAAO,kBAAC,GAAD,MAAS0E,SAASwF,eAAe,QD4H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBnD,MAAK,SAAAoD,GACJA,EAAaC,gBAEdC,OAAM,SAAA/P,GACLD,QAAQC,MAAMA,EAAM1lB,c","file":"static/js/main.7bffe68e.chunk.js","sourcesContent":["// tslint:disable:ban-types\n// Object.assign flattens getters and setters\n// See https://stackoverflow.com/questions/37054596/js-es5-how-to-assign-objects-with-setters-and-getters\nexport function extend(target, ...sources) {\n  for (const source of sources) {\n    for (const key of Object.keys(source)) {\n      const descr = Object.getOwnPropertyDescriptor(source, key);\n\n      if (descr) {\n        Object.defineProperty(target, key, descr);\n      }\n    }\n  }\n\n  return target;\n}\nexport function isIterable(x) {\n  return x != null && typeof x === \"object\" && Symbol.iterator in x;\n}\nexport function isArrayLike(x) {\n  return x != null && (Array.isArray(x) || ArrayBuffer.isView(x));\n}\nexport function isComparer(x) {\n  return x != null && typeof x.Compare === \"function\";\n}\nexport function isComparable(x) {\n  return x != null && typeof x.CompareTo === \"function\";\n}\nexport function isEquatable(x) {\n  return x != null && typeof x.Equals === \"function\";\n}\nexport function isHashable(x) {\n  return x != null && typeof x.GetHashCode === \"function\";\n}\nexport function isDisposable(x) {\n  return x != null && typeof x.Dispose === \"function\";\n}\nexport class Comparer {\n  constructor(f) {\n    this.Compare = f || compare;\n  }\n\n}\nexport function comparerFromEqualityComparer(comparer) {\n  // Sometimes IEqualityComparer also implements IComparer\n  if (isComparer(comparer)) {\n    return new Comparer(comparer.Compare);\n  } else {\n    return new Comparer((x, y) => {\n      const xhash = comparer.GetHashCode(x);\n      const yhash = comparer.GetHashCode(y);\n\n      if (xhash === yhash) {\n        return comparer.Equals(x, y) ? 0 : -1;\n      } else {\n        return xhash < yhash ? -1 : 1;\n      }\n    });\n  }\n} // TODO: Move these three methods to Map and Set modules\n\nexport function containsValue(v, map) {\n  for (const kv of map) {\n    if (equals(v, kv[1])) {\n      return true;\n    }\n  }\n\n  return false;\n}\nexport function tryGetValue(map, key, defaultValue) {\n  return map.has(key) ? [true, map.get(key)] : [false, defaultValue];\n}\nexport function addToSet(v, set) {\n  if (set.has(v)) {\n    return false;\n  }\n\n  set.add(v);\n  return true;\n}\nexport function assertEqual(actual, expected, msg) {\n  if (!equals(actual, expected)) {\n    throw Object.assign(new Error(msg || `Expected: ${expected} - Actual: ${actual}`), {\n      actual,\n      expected\n    });\n  }\n}\nexport function assertNotEqual(actual, expected, msg) {\n  if (equals(actual, expected)) {\n    throw Object.assign(new Error(msg || `Expected: ${expected} - Actual: ${actual}`), {\n      actual,\n      expected\n    });\n  }\n}\nexport class Lazy {\n  constructor(factory) {\n    this.factory = factory;\n    this.isValueCreated = false;\n  }\n\n  get Value() {\n    if (!this.isValueCreated) {\n      this.createdValue = this.factory();\n      this.isValueCreated = true;\n    }\n\n    return this.createdValue;\n  }\n\n  get IsValueCreated() {\n    return this.isValueCreated;\n  }\n\n}\nexport function lazyFromValue(v) {\n  return new Lazy(() => v);\n}\nexport function padWithZeros(i, length) {\n  let str = i.toString(10);\n\n  while (str.length < length) {\n    str = \"0\" + str;\n  }\n\n  return str;\n}\nexport function padLeftAndRightWithZeros(i, lengthLeft, lengthRight) {\n  let str = i.toString(10);\n\n  while (str.length < lengthLeft) {\n    str = \"0\" + str;\n  }\n\n  while (str.length < lengthRight) {\n    str = str + \"0\";\n  }\n\n  return str;\n}\nexport function dateOffset(date) {\n  const date1 = date;\n  return typeof date1.offset === \"number\" ? date1.offset : date.kind === 1\n  /* UTC */\n  ? 0 : date.getTimezoneOffset() * -60000;\n}\nexport function int16ToString(i, radix) {\n  i = i < 0 && radix != null && radix !== 10 ? 0xFFFF + i + 1 : i;\n  return i.toString(radix);\n}\nexport function int32ToString(i, radix) {\n  i = i < 0 && radix != null && radix !== 10 ? 0xFFFFFFFF + i + 1 : i;\n  return i.toString(radix);\n}\nexport class ObjectRef {\n  static id(o) {\n    if (!ObjectRef.idMap.has(o)) {\n      ObjectRef.idMap.set(o, ++ObjectRef.count);\n    }\n\n    return ObjectRef.idMap.get(o);\n  }\n\n}\nObjectRef.idMap = new WeakMap();\nObjectRef.count = 0;\nexport function stringHash(s) {\n  let i = 0;\n  let h = 5381;\n  const len = s.length;\n\n  while (i < len) {\n    h = h * 33 ^ s.charCodeAt(i++);\n  }\n\n  return h;\n}\nexport function numberHash(x) {\n  return x * 2654435761 | 0;\n} // From https://stackoverflow.com/a/37449594\n\nexport function combineHashCodes(hashes) {\n  if (hashes.length === 0) {\n    return 0;\n  }\n\n  return hashes.reduce((h1, h2) => {\n    return (h1 << 5) + h1 ^ h2;\n  });\n}\nexport function identityHash(x) {\n  if (x == null) {\n    return 0;\n  }\n\n  switch (typeof x) {\n    case \"boolean\":\n      return x ? 1 : 0;\n\n    case \"number\":\n      return numberHash(x);\n\n    case \"string\":\n      return stringHash(x);\n\n    default:\n      return numberHash(ObjectRef.id(x));\n  }\n}\nexport function structuralHash(x) {\n  if (x == null) {\n    return 0;\n  }\n\n  switch (typeof x) {\n    case \"boolean\":\n      return x ? 1 : 0;\n\n    case \"number\":\n      return numberHash(x);\n\n    case \"string\":\n      return stringHash(x);\n\n    default:\n      {\n        if (isHashable(x)) {\n          return x.GetHashCode();\n        } else if (isArrayLike(x)) {\n          const len = x.length;\n          const hashes = new Array(len);\n\n          for (let i = 0; i < len; i++) {\n            hashes[i] = structuralHash(x[i]);\n          }\n\n          return combineHashCodes(hashes);\n        } else {\n          return stringHash(String(x));\n        }\n      }\n  }\n}\nexport function equalArraysWith(x, y, eq) {\n  if (x == null) {\n    return y == null;\n  }\n\n  if (y == null) {\n    return false;\n  }\n\n  if (x.length !== y.length) {\n    return false;\n  }\n\n  for (let i = 0; i < x.length; i++) {\n    if (!eq(x[i], y[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\nexport function equalArrays(x, y) {\n  return equalArraysWith(x, y, equals);\n} // export function equalObjects(x: { [k: string]: any }, y: { [k: string]: any }): boolean {\n//   if (x == null) { return y == null; }\n//   if (y == null) { return false; }\n//   const xKeys = Object.keys(x);\n//   const yKeys = Object.keys(y);\n//   if (xKeys.length !== yKeys.length) {\n//     return false;\n//   }\n//   xKeys.sort();\n//   yKeys.sort();\n//   for (let i = 0; i < xKeys.length; i++) {\n//     if (xKeys[i] !== yKeys[i] || !equals(x[xKeys[i]], y[yKeys[i]])) {\n//       return false;\n//     }\n//   }\n//   return true;\n// }\n\nexport function equals(x, y) {\n  if (x === y) {\n    return true;\n  } else if (x == null) {\n    return y == null;\n  } else if (y == null) {\n    return false;\n  } else if (typeof x !== \"object\") {\n    return false;\n  } else if (isEquatable(x)) {\n    return x.Equals(y);\n  } else if (isArrayLike(x)) {\n    return isArrayLike(y) && equalArrays(x, y);\n  } else if (x instanceof Date) {\n    return y instanceof Date && compareDates(x, y) === 0;\n  } else {\n    return false;\n  }\n}\nexport function compareDates(x, y) {\n  let xtime;\n  let ytime; // DateTimeOffset and DateTime deals with equality differently.\n\n  if (\"offset\" in x && \"offset\" in y) {\n    xtime = x.getTime();\n    ytime = y.getTime();\n  } else {\n    xtime = x.getTime() + dateOffset(x);\n    ytime = y.getTime() + dateOffset(y);\n  }\n\n  return xtime === ytime ? 0 : xtime < ytime ? -1 : 1;\n}\nexport function comparePrimitives(x, y) {\n  return x === y ? 0 : x < y ? -1 : 1;\n}\nexport function compareArraysWith(x, y, comp) {\n  if (x == null) {\n    return y == null ? 0 : 1;\n  }\n\n  if (y == null) {\n    return -1;\n  }\n\n  if (x.length !== y.length) {\n    return x.length < y.length ? -1 : 1;\n  }\n\n  for (let i = 0, j = 0; i < x.length; i++) {\n    j = comp(x[i], y[i]);\n\n    if (j !== 0) {\n      return j;\n    }\n  }\n\n  return 0;\n}\nexport function compareArrays(x, y) {\n  return compareArraysWith(x, y, compare);\n}\nexport function compareObjects(x, y) {\n  if (x == null) {\n    return y == null ? 0 : 1;\n  }\n\n  if (y == null) {\n    return -1;\n  }\n\n  const xKeys = Object.keys(x);\n  const yKeys = Object.keys(y);\n\n  if (xKeys.length !== yKeys.length) {\n    return xKeys.length < yKeys.length ? -1 : 1;\n  }\n\n  xKeys.sort();\n  yKeys.sort();\n\n  for (let i = 0, j = 0; i < xKeys.length; i++) {\n    const key = xKeys[i];\n\n    if (key !== yKeys[i]) {\n      return key < yKeys[i] ? -1 : 1;\n    } else {\n      j = compare(x[key], y[key]);\n\n      if (j !== 0) {\n        return j;\n      }\n    }\n  }\n\n  return 0;\n}\nexport function compare(x, y) {\n  if (x === y) {\n    return 0;\n  } else if (x == null) {\n    return y == null ? 0 : -1;\n  } else if (y == null) {\n    return 1;\n  } else if (typeof x !== \"object\") {\n    return x < y ? -1 : 1;\n  } else if (isComparable(x)) {\n    return x.CompareTo(y);\n  } else if (isArrayLike(x) && isArrayLike(y)) {\n    return compareArrays(x, y);\n  } else if (x instanceof Date && y instanceof Date) {\n    return compareDates(x, y);\n  } else {\n    return 1;\n  }\n}\nexport function min(comparer, x, y) {\n  return comparer(x, y) < 0 ? x : y;\n}\nexport function max(comparer, x, y) {\n  return comparer(x, y) > 0 ? x : y;\n}\nexport function createAtom(value) {\n  let atom = value;\n  return value => {\n    if (value === void 0) {\n      return atom;\n    } else {\n      atom = value;\n      return void 0;\n    }\n  };\n}\nconst CaseRules = {\n  None: 0,\n  LowerFirst: 1,\n  SnakeCase: 2,\n  SnakeCaseAllCaps: 3,\n  KebabCase: 4\n};\n\nfunction dashify(str, separator) {\n  return str.replace(/[a-z]?[A-Z]/g, m => m.length === 1 ? m.toLowerCase() : m.charAt(0) + separator + m.charAt(1).toLowerCase());\n}\n\nfunction changeCase(str, caseRule) {\n  switch (caseRule) {\n    case CaseRules.LowerFirst:\n      return str.charAt(0).toLowerCase() + str.slice(1);\n\n    case CaseRules.SnakeCase:\n      return dashify(str, \"_\");\n\n    case CaseRules.SnakeCaseAllCaps:\n      return dashify(str, \"_\").toUpperCase();\n\n    case CaseRules.KebabCase:\n      return dashify(str, \"-\");\n\n    case CaseRules.None:\n    default:\n      return str;\n  }\n}\n\nexport function createObj(fields, caseRule = CaseRules.None) {\n  function fail(kvPair) {\n    throw new Error(\"Cannot infer key and value of \" + String(kvPair));\n  }\n\n  const o = {};\n  const definedCaseRule = caseRule;\n\n  for (let kvPair of fields) {\n    let caseRule = CaseRules.None;\n\n    if (kvPair == null) {\n      fail(kvPair);\n    } // Deflate unions and use the defined case rule\n\n\n    if (typeof kvPair.toJSON === \"function\") {\n      kvPair = kvPair.toJSON();\n      caseRule = definedCaseRule;\n    }\n\n    if (Array.isArray(kvPair)) {\n      switch (kvPair.length) {\n        case 0:\n          fail(kvPair);\n          break;\n\n        case 1:\n          o[changeCase(kvPair[0], caseRule)] = true;\n          break;\n\n        case 2:\n          const value = kvPair[1];\n          o[changeCase(kvPair[0], caseRule)] = value;\n          break;\n\n        default:\n          o[changeCase(kvPair[0], caseRule)] = kvPair.slice(1);\n      }\n    } else if (typeof kvPair === \"string\") {\n      o[changeCase(kvPair, caseRule)] = true;\n    } else {\n      fail(kvPair);\n    }\n  }\n\n  return o;\n}\nexport function jsOptions(mutator) {\n  const opts = {};\n  mutator(opts);\n  return opts;\n}\nexport function round(value, digits = 0) {\n  const m = Math.pow(10, digits);\n  const n = +(digits ? value * m : value).toFixed(8);\n  const i = Math.floor(n);\n  const f = n - i;\n  const e = 1e-8;\n  const r = f > 0.5 - e && f < 0.5 + e ? i % 2 === 0 ? i : i + 1 : Math.round(n);\n  return digits ? r / m : r;\n}\nexport function sign(x) {\n  return x > 0 ? 1 : x < 0 ? -1 : 0;\n}\nexport function randomNext(min, max) {\n  return Math.floor(Math.random() * (max - min)) + min;\n}\nexport function randomBytes(buffer) {\n  if (buffer == null) {\n    throw new Error(\"Buffer cannot be null\");\n  }\n\n  for (let i = 0; i < buffer.length; i += 6) {\n    // Pick random 48-bit number. Fill buffer in 2 24-bit chunks to avoid bitwise truncation.\n    let r = Math.floor(Math.random() * 281474976710656); // Low 24 bits = chunk 1.\n\n    const rhi = Math.floor(r / 16777216); // High 24 bits shifted via division = chunk 2.\n\n    for (let j = 0; j < 6 && i + j < buffer.length; j++) {\n      if (j === 3) {\n        r = rhi;\n      }\n\n      buffer[i + j] = r & 255;\n      r >>>= 8;\n    }\n  }\n}\nexport function unescapeDataString(s) {\n  // https://stackoverflow.com/a/4458580/524236\n  return decodeURIComponent(s.replace(/\\+/g, \"%20\"));\n}\nexport function escapeDataString(s) {\n  return encodeURIComponent(s).replace(/!/g, \"%21\").replace(/'/g, \"%27\").replace(/\\(/g, \"%28\").replace(/\\)/g, \"%29\").replace(/\\*/g, \"%2A\");\n}\nexport function escapeUriString(s) {\n  return encodeURI(s);\n} // ICollection.Clear and Count members can be called on Arrays\n// or Dictionaries so we need a runtime check (see #1120)\n\nexport function count(col) {\n  if (isArrayLike(col)) {\n    return col.length;\n  } else {\n    let count = 0;\n\n    for (const _ of col) {\n      count++;\n    }\n\n    return count;\n  }\n}\nexport function clear(col) {\n  if (isArrayLike(col)) {\n    col.splice(0);\n  } else {\n    col.clear();\n  }\n}\nconst CURRIED_KEY = \"__CURRIED__\";\nexport function uncurry(arity, f) {\n  // f may be a function option with None value\n  if (f == null) {\n    return null;\n  } // The function is already uncurried\n\n\n  if (f.length > 1) {\n    // if (CURRIED_KEY in f) { // This doesn't always work\n    return f;\n  }\n\n  let uncurriedFn;\n\n  switch (arity) {\n    case 2:\n      uncurriedFn = (a1, a2) => f(a1)(a2);\n\n      break;\n\n    case 3:\n      uncurriedFn = (a1, a2, a3) => f(a1)(a2)(a3);\n\n      break;\n\n    case 4:\n      uncurriedFn = (a1, a2, a3, a4) => f(a1)(a2)(a3)(a4);\n\n      break;\n\n    case 5:\n      uncurriedFn = (a1, a2, a3, a4, a5) => f(a1)(a2)(a3)(a4)(a5);\n\n      break;\n\n    case 6:\n      uncurriedFn = (a1, a2, a3, a4, a5, a6) => f(a1)(a2)(a3)(a4)(a5)(a6);\n\n      break;\n\n    case 7:\n      uncurriedFn = (a1, a2, a3, a4, a5, a6, a7) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7);\n\n      break;\n\n    case 8:\n      uncurriedFn = (a1, a2, a3, a4, a5, a6, a7, a8) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8);\n\n      break;\n\n    default:\n      throw new Error(\"Uncurrying to more than 8-arity is not supported: \" + arity);\n  }\n\n  uncurriedFn[CURRIED_KEY] = f;\n  return uncurriedFn;\n}\nexport function curry(arity, f) {\n  if (f == null) {\n    return undefined;\n  }\n\n  if (CURRIED_KEY in f) {\n    return f[CURRIED_KEY];\n  }\n\n  switch (arity) {\n    case 2:\n      return a1 => a2 => f(a1, a2);\n\n    case 3:\n      return a1 => a2 => a3 => f(a1, a2, a3);\n\n    case 4:\n      return a1 => a2 => a3 => a4 => f(a1, a2, a3, a4);\n\n    case 5:\n      return a1 => a2 => a3 => a4 => a5 => f(a1, a2, a3, a4, a5);\n\n    case 6:\n      return a1 => a2 => a3 => a4 => a5 => a6 => f(a1, a2, a3, a4, a5, a6);\n\n    case 7:\n      return a1 => a2 => a3 => a4 => a5 => a6 => a7 => f(a1, a2, a3, a4, a5, a6, a7);\n\n    case 8:\n      return a1 => a2 => a3 => a4 => a5 => a6 => a7 => a8 => f(a1, a2, a3, a4, a5, a6, a7, a8);\n\n    default:\n      throw new Error(\"Currying to more than 8-arity is not supported: \" + arity);\n  }\n}\nexport function partialApply(arity, f, args) {\n  if (f == null) {\n    return null;\n  } else if (CURRIED_KEY in f) {\n    f = f[CURRIED_KEY];\n\n    for (let i = 0; i < args.length; i++) {\n      f = f(args[i]);\n    }\n\n    return f;\n  } else {\n    switch (arity) {\n      case 1:\n        // Wrap arguments to make sure .concat doesn't destruct arrays. Example\n        // [1,2].concat([3,4],5)   --> [1,2,3,4,5]    // fails\n        // [1,2].concat([[3,4],5]) --> [1,2,[3,4],5]  // ok\n        return a1 => f.apply(null, args.concat([a1]));\n\n      case 2:\n        return a1 => a2 => f.apply(null, args.concat([a1, a2]));\n\n      case 3:\n        return a1 => a2 => a3 => f.apply(null, args.concat([a1, a2, a3]));\n\n      case 4:\n        return a1 => a2 => a3 => a4 => f.apply(null, args.concat([a1, a2, a3, a4]));\n\n      case 5:\n        return a1 => a2 => a3 => a4 => a5 => f.apply(null, args.concat([a1, a2, a3, a4, a5]));\n\n      case 6:\n        return a1 => a2 => a3 => a4 => a5 => a6 => f.apply(null, args.concat([a1, a2, a3, a4, a5, a6]));\n\n      case 7:\n        return a1 => a2 => a3 => a4 => a5 => a6 => a7 => f.apply(null, args.concat([a1, a2, a3, a4, a5, a6, a7]));\n\n      case 8:\n        return a1 => a2 => a3 => a4 => a5 => a6 => a7 => a8 => f.apply(null, args.concat([a1, a2, a3, a4, a5, a6, a7, a8]));\n\n      default:\n        throw new Error(\"Partially applying to more than 8-arity is not supported: \" + arity);\n    }\n  }\n}\nexport function mapCurriedArgs(fn, mappings) {\n  function mapArg(fn, arg, mappings, idx) {\n    const mapping = mappings[idx];\n\n    if (mapping !== 0) {\n      const expectedArity = mapping[0];\n      const actualArity = mapping[1];\n\n      if (expectedArity > 1) {\n        arg = curry(expectedArity, arg);\n      }\n\n      if (actualArity > 1) {\n        arg = uncurry(actualArity, arg);\n      }\n    }\n\n    const res = fn(arg);\n\n    if (idx + 1 === mappings.length) {\n      return res;\n    } else {\n      return arg => mapArg(res, arg, mappings, idx + 1);\n    }\n  }\n\n  return arg => mapArg(fn, arg, mappings, 0);\n}\nexport function addToDict(dict, k, v) {\n  if (dict.has(k)) {\n    throw new Error(\"An item with the same key has already been added. Key: \" + k);\n  }\n\n  dict.set(k, v);\n}\nexport function getItemFromDict(map, key) {\n  if (map.has(key)) {\n    return map.get(key);\n  } else {\n    throw new Error(`The given key '${key}' was not present in the dictionary.`);\n  }\n}","// tslint:disable: space-before-function-paren\nimport { combineHashCodes, compare, compareArrays, equalArrays, equals, identityHash, numberHash, structuralHash } from \"./Util\";\n\nfunction sameType(x, y) {\n  return y != null && Object.getPrototypeOf(x).constructor === Object.getPrototypeOf(y).constructor;\n} // Taken from Babel helpers\n\n\nfunction inherits(subClass, superClass) {\n  // if (typeof superClass !== \"function\" && superClass !== null) {\n  //   throw new TypeError(\n  //     \"Super expression must either be null or a function, not \" +\n  //       typeof superClass\n  //   );\n  // }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  }); // if (superClass)\n  //   Object.setPrototypeOf\n  //     ? Object.setPrototypeOf(subClass, superClass)\n  //     : (subClass.__proto__ = superClass);\n}\n\nexport function declare(cons, superClass) {\n  inherits(cons, superClass || SystemObject);\n  return cons;\n}\nexport function SystemObject() {\n  return;\n}\n\nSystemObject.prototype.toString = function () {\n  return \"{\" + Object.keys(this).map(k => k + \" = \" + String(this[k])).join(\";\\n \") + \"}\";\n};\n\nSystemObject.prototype.GetHashCode = function () {\n  return identityHash(this);\n};\n\nSystemObject.prototype.Equals = function (other) {\n  return this === other;\n};\n\nfunction compareList(self, other) {\n  if (self === other) {\n    return 0;\n  } else {\n    if (other == null) {\n      return -1;\n    }\n\n    while (self.tail != null) {\n      if (other.tail == null) {\n        return 1;\n      }\n\n      const res = compare(self.head, other.head);\n\n      if (res !== 0) {\n        return res;\n      }\n\n      self = self.tail;\n      other = other.tail;\n    }\n\n    return other.tail == null ? 0 : -1;\n  }\n}\n\nexport function List(head, tail) {\n  this.head = head;\n  this.tail = tail;\n}\n\nList.prototype.toString = function () {\n  return \"[\" + Array.from(this).map(x => String(x)).join(\"; \") + \"]\";\n};\n\nList.prototype.toJSON = function () {\n  return Array.from(this);\n};\n\nList.prototype[Symbol.iterator] = function () {\n  let cur = this;\n  return {\n    next: () => {\n      const tmp = cur;\n      cur = cur.tail;\n      return {\n        done: tmp.tail == null,\n        value: tmp.head\n      };\n    }\n  };\n};\n\nList.prototype.GetHashCode = function () {\n  const hashes = Array.from(this).map(structuralHash);\n  return combineHashCodes(hashes);\n};\n\nList.prototype.Equals = function (other) {\n  return compareList(this, other) === 0;\n};\n\nList.prototype.CompareTo = function (other) {\n  return compareList(this, other);\n};\n\nexport function Union(tag, name, ...fields) {\n  this.tag = tag | 0;\n  this.name = name;\n  this.fields = fields;\n}\n\nUnion.prototype.toString = function () {\n  const len = this.fields.length;\n\n  if (len === 0) {\n    return this.name;\n  } else if (len === 1) {\n    return this.name + \" \" + String(this.fields[0]);\n  } else {\n    return this.name + \" (\" + this.fields.map(x => String(x)).join(\",\") + \")\";\n  }\n};\n\nUnion.prototype.toJSON = function () {\n  return this.fields.length === 0 ? this.name : [this.name].concat(this.fields);\n};\n\nUnion.prototype.GetHashCode = function () {\n  const hashes = this.fields.map(x => structuralHash(x));\n  hashes.splice(0, 0, numberHash(this.tag));\n  return combineHashCodes(hashes);\n};\n\nUnion.prototype.Equals = function (other) {\n  return this === other || sameType(this, other) && this.tag === other.tag && equalArrays(this.fields, other.fields);\n};\n\nUnion.prototype.CompareTo = function (other) {\n  if (this === other) {\n    return 0;\n  } else if (!sameType(this, other)) {\n    return -1;\n  } else if (this.tag === other.tag) {\n    return compareArrays(this.fields, other.fields);\n  } else {\n    return this.tag < other.tag ? -1 : 1;\n  }\n};\n\nfunction recordToJson(record, getFieldNames) {\n  const o = {};\n  const keys = getFieldNames == null ? Object.keys(record) : getFieldNames(record);\n\n  for (let i = 0; i < keys.length; i++) {\n    o[keys[i]] = record[keys[i]];\n  }\n\n  return o;\n}\n\nfunction recordEquals(self, other, getFieldNames) {\n  if (self === other) {\n    return true;\n  } else if (!sameType(self, other)) {\n    return false;\n  } else {\n    const thisNames = getFieldNames == null ? Object.keys(self) : getFieldNames(self);\n\n    for (let i = 0; i < thisNames.length; i++) {\n      if (!equals(self[thisNames[i]], other[thisNames[i]])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\n\nfunction recordCompare(self, other, getFieldNames) {\n  if (self === other) {\n    return 0;\n  } else if (!sameType(self, other)) {\n    return -1;\n  } else {\n    const thisNames = getFieldNames == null ? Object.keys(self) : getFieldNames(self);\n\n    for (let i = 0; i < thisNames.length; i++) {\n      const result = compare(self[thisNames[i]], other[thisNames[i]]);\n\n      if (result !== 0) {\n        return result;\n      }\n    }\n\n    return 0;\n  }\n}\n\nexport function Record() {\n  return;\n}\n\nRecord.prototype.toString = function () {\n  return \"{\" + Object.keys(this).map(k => k + \" = \" + String(this[k])).join(\";\\n \") + \"}\";\n};\n\nRecord.prototype.toJSON = function () {\n  return recordToJson(this);\n};\n\nRecord.prototype.GetHashCode = function () {\n  const hashes = Object.keys(this).map(k => structuralHash(this[k]));\n  return combineHashCodes(hashes);\n};\n\nRecord.prototype.Equals = function (other) {\n  return recordEquals(this, other);\n};\n\nRecord.prototype.CompareTo = function (other) {\n  return recordCompare(this, other);\n};\n\nexport function anonRecord(o) {\n  return Object.assign(Object.create(Record.prototype), o);\n}\nexport const FSharpRef = declare(function FSharpRef(contents) {\n  this.contents = contents;\n}, Record);\nexport const Exception = declare(function Exception(message) {\n  this.stack = Error().stack;\n  this.message = message;\n}, SystemObject);\nexport function isException(x) {\n  return x instanceof Error || x instanceof Exception;\n}\n\nfunction getFSharpExceptionFieldNames(self) {\n  return Object.keys(self).filter(k => k !== \"message\" && k !== \"stack\");\n}\n\nexport const FSharpException = declare(function FSharpException() {\n  Exception.call(this);\n}, Exception);\n\nFSharpException.prototype.toString = function () {\n  const fieldNames = getFSharpExceptionFieldNames(this);\n  const len = fieldNames.length;\n\n  if (len === 0) {\n    return this.message;\n  } else if (len === 1) {\n    return this.message + \" \" + String(this[fieldNames[0]]);\n  } else {\n    return this.message + \" (\" + fieldNames.map(k => String(this[k])).join(\",\") + \")\";\n  }\n};\n\nFSharpException.prototype.toJSON = function () {\n  return recordToJson(this, getFSharpExceptionFieldNames);\n};\n\nFSharpException.prototype.GetHashCode = function () {\n  const hashes = getFSharpExceptionFieldNames(this).map(k => structuralHash(this[k]));\n  return combineHashCodes(hashes);\n};\n\nFSharpException.prototype.Equals = function (other) {\n  return recordEquals(this, other, getFSharpExceptionFieldNames);\n};\n\nFSharpException.prototype.CompareTo = function (other) {\n  return recordCompare(this, other, getFSharpExceptionFieldNames);\n};\n\nexport const MatchFailureException = declare(function MatchFailureException(arg1, arg2, arg3) {\n  this.arg1 = arg1;\n  this.arg2 = arg2 | 0;\n  this.arg3 = arg3 | 0;\n  this.message = \"The match cases were incomplete\";\n}, FSharpException);\nexport const Attribute = declare(function Attribute() {\n  return;\n}, SystemObject);","import { anonRecord as makeAnonRecord, Record, Union } from \"./Types\";\nimport { compareArraysWith, equalArraysWith } from \"./Util\";\nexport class CaseInfo {\n  constructor(declaringType, tag, name, fields) {\n    this.declaringType = declaringType;\n    this.tag = tag;\n    this.name = name;\n    this.fields = fields;\n  }\n\n}\nexport class TypeInfo {\n  constructor(fullname, generics, constructor, fields, cases, enumCases) {\n    this.fullname = fullname;\n    this.generics = generics;\n    this.constructor = constructor;\n    this.fields = fields;\n    this.cases = cases;\n    this.enumCases = enumCases;\n  }\n\n  toString() {\n    return fullName(this);\n  }\n\n  Equals(other) {\n    return equals(this, other);\n  }\n\n  CompareTo(other) {\n    return compare(this, other);\n  }\n\n}\nexport function getGenerics(t) {\n  return t.generics != null ? t.generics : [];\n}\nexport function equals(t1, t2) {\n  if (t1.fullname === \"\") {\n    // Anonymous records\n    return t2.fullname === \"\" && equalArraysWith(getRecordElements(t1), getRecordElements(t2), ([k1, v1], [k2, v2]) => k1 === k2 && equals(v1, v2));\n  } else {\n    return t1.fullname === t2.fullname && equalArraysWith(getGenerics(t1), getGenerics(t2), equals);\n  }\n} // System.Type is not comparable in .NET, but let's implement this\n// in case users want to create a dictionary with types as keys\n\nexport function compare(t1, t2) {\n  if (t1.fullname !== t2.fullname) {\n    return t1.fullname < t2.fullname ? -1 : 1;\n  } else {\n    return compareArraysWith(getGenerics(t1), getGenerics(t2), compare);\n  }\n}\nexport function type(fullname, generics) {\n  return new TypeInfo(fullname, generics);\n}\nexport function record(fullname, generics, constructor, fields) {\n  return new TypeInfo(fullname, generics, constructor, fields);\n}\nexport function anonRecord(...fields) {\n  return new TypeInfo(\"\", undefined, undefined, () => fields);\n}\nexport function union(fullname, generics, constructor, cases) {\n  const t = new TypeInfo(fullname, generics, constructor, undefined, () => cases().map((x, i) => typeof x === \"string\" ? new CaseInfo(t, i, x) : new CaseInfo(t, i, x[0], x[1])));\n  return t;\n}\nexport function tuple(...generics) {\n  return new TypeInfo(\"System.Tuple`\" + generics.length, generics);\n}\nexport function delegate(...generics) {\n  return new TypeInfo(\"System.Func`\" + generics.length, generics);\n}\nexport function lambda(argType, returnType) {\n  return new TypeInfo(\"Microsoft.FSharp.Core.FSharpFunc`2\", [argType, returnType]);\n}\nexport function option(generic) {\n  return new TypeInfo(\"Microsoft.FSharp.Core.FSharpOption`1\", [generic]);\n}\nexport function list(generic) {\n  return new TypeInfo(\"Microsoft.FSharp.Collections.FSharpList`1\", [generic]);\n}\nexport function array(generic) {\n  return new TypeInfo(generic.fullname + \"[]\", [generic]);\n}\nexport function enumType(fullname, underlyingType, enumCases) {\n  return new TypeInfo(fullname, [underlyingType], undefined, undefined, undefined, enumCases);\n}\nexport const obj = new TypeInfo(\"System.Object\");\nexport const unit = new TypeInfo(\"Microsoft.FSharp.Core.Unit\");\nexport const char = new TypeInfo(\"System.Char\");\nexport const string = new TypeInfo(\"System.String\");\nexport const bool = new TypeInfo(\"System.Boolean\");\nexport const int8 = new TypeInfo(\"System.SByte\");\nexport const uint8 = new TypeInfo(\"System.Byte\");\nexport const int16 = new TypeInfo(\"System.Int16\");\nexport const uint16 = new TypeInfo(\"System.UInt16\");\nexport const int32 = new TypeInfo(\"System.Int32\");\nexport const uint32 = new TypeInfo(\"System.UInt32\");\nexport const float32 = new TypeInfo(\"System.Single\");\nexport const float64 = new TypeInfo(\"System.Double\");\nexport const decimal = new TypeInfo(\"System.Decimal\");\nexport function name(info) {\n  if (Array.isArray(info)) {\n    return info[0];\n  } else if (info instanceof CaseInfo) {\n    return info.name;\n  } else {\n    const i = info.fullname.lastIndexOf(\".\");\n    return i === -1 ? info.fullname : info.fullname.substr(i + 1);\n  }\n}\nexport function fullName(t) {\n  const gen = t.generics != null && !isArray(t) ? t.generics : [];\n\n  if (gen.length > 0) {\n    return t.fullname + \"[\" + gen.map(x => fullName(x)).join(\",\") + \"]\";\n  } else {\n    return t.fullname;\n  }\n}\nexport function namespace(t) {\n  const i = t.fullname.lastIndexOf(\".\");\n  return i === -1 ? \"\" : t.fullname.substr(0, i);\n}\nexport function isArray(t) {\n  return t.fullname.endsWith(\"[]\");\n}\nexport function getElementType(t) {\n  var _a;\n\n  return isArray(t) ? (_a = t.generics) === null || _a === void 0 ? void 0 : _a[0] : undefined;\n}\nexport function isGenericType(t) {\n  return t.generics != null && t.generics.length > 0;\n}\nexport function isEnum(t) {\n  return t.enumCases != null && t.enumCases.length > 0;\n}\n/**\n * This doesn't replace types for fields (records) or cases (unions)\n * but it should be enough for type comparison purposes\n */\n\nexport function getGenericTypeDefinition(t) {\n  return t.generics == null ? t : new TypeInfo(t.fullname, t.generics.map(() => obj));\n}\nexport function getEnumUnderlyingType(t) {\n  var _a;\n\n  return (_a = t.generics) === null || _a === void 0 ? void 0 : _a[0];\n}\nexport function getEnumValues(t) {\n  if (isEnum(t) && t.enumCases != null) {\n    return t.enumCases.map(kv => kv[1]);\n  } else {\n    throw new Error(`${t.fullname} is not an enum type`);\n  }\n}\nexport function getEnumNames(t) {\n  if (isEnum(t) && t.enumCases != null) {\n    return t.enumCases.map(kv => kv[0]);\n  } else {\n    throw new Error(`${t.fullname} is not an enum type`);\n  }\n}\n\nfunction getEnumCase(t, v) {\n  if (t.enumCases != null) {\n    if (typeof v === \"string\") {\n      for (const kv of t.enumCases) {\n        if (kv[0] === v) {\n          return kv;\n        }\n      }\n\n      throw new Error(`'${v}' was not found in ${t.fullname}`);\n    } else {\n      for (const kv of t.enumCases) {\n        if (kv[1] === v) {\n          return kv;\n        }\n      } // .NET returns the number even if it doesn't match any of the cases\n\n\n      return [\"\", v];\n    }\n  } else {\n    throw new Error(`${t.fullname} is not an enum type`);\n  }\n}\n\nexport function parseEnum(t, str) {\n  // TODO: better int parsing here, parseInt ceils floats: \"4.8\" -> 4\n  const value = parseInt(str, 10);\n  return getEnumCase(t, isNaN(value) ? str : value)[1];\n}\nexport function tryParseEnum(t, str) {\n  try {\n    const v = parseEnum(t, str);\n    return [true, v];\n  } catch (_a) {// supress error\n  }\n\n  return [false, NaN];\n}\nexport function getEnumName(t, v) {\n  return getEnumCase(t, v)[0];\n}\nexport function isEnumDefined(t, v) {\n  try {\n    const kv = getEnumCase(t, v);\n    return kv[0] != null && kv[0] !== \"\";\n  } catch (_a) {// supress error\n  }\n\n  return false;\n} // FSharpType\n\nexport function getUnionCases(t) {\n  if (t.cases != null) {\n    return t.cases();\n  } else {\n    throw new Error(`${t.fullname} is not an F# union type`);\n  }\n}\nexport function getRecordElements(t) {\n  if (t.fields != null) {\n    return t.fields();\n  } else {\n    throw new Error(`${t.fullname} is not an F# record type`);\n  }\n}\nexport function getTupleElements(t) {\n  if (isTuple(t) && t.generics != null) {\n    return t.generics;\n  } else {\n    throw new Error(`${t.fullname} is not a tuple type`);\n  }\n}\nexport function getFunctionElements(t) {\n  if (isFunction(t) && t.generics != null) {\n    const gen = t.generics;\n    return [gen[0], gen[1]];\n  } else {\n    throw new Error(`${t.fullname} is not an F# function type`);\n  }\n}\nexport function isUnion(t) {\n  return t instanceof TypeInfo ? t.cases != null : t instanceof Union;\n}\nexport function isRecord(t) {\n  return t instanceof TypeInfo ? t.fields != null : t instanceof Record;\n}\nexport function isTuple(t) {\n  return t.fullname.startsWith(\"System.Tuple\");\n} // In .NET this is false for delegates\n\nexport function isFunction(t) {\n  return t.fullname === \"Microsoft.FSharp.Core.FSharpFunc`2\";\n} // FSharpValue\n\nexport function getUnionFields(v, t) {\n  const cases = getUnionCases(t);\n  const case_ = cases[v.tag];\n\n  if (case_ == null) {\n    throw new Error(`Cannot find case ${v.name} in union type`);\n  }\n\n  return [case_, v.fields];\n}\nexport function getUnionCaseFields(uci) {\n  return uci.fields == null ? [] : uci.fields.map((t, i) => [\"Data\" + i, t]);\n}\nexport function getRecordFields(v) {\n  return Object.keys(v).map(k => v[k]);\n}\nexport function getRecordField(v, field) {\n  return v[field[0]];\n}\nexport function getTupleFields(v) {\n  return v;\n}\nexport function getTupleField(v, i) {\n  return v[i];\n}\nexport function makeUnion(uci, values) {\n  const expectedLength = (uci.fields || []).length;\n\n  if (values.length !== expectedLength) {\n    throw new Error(`Expected an array of length ${expectedLength} but got ${values.length}`);\n  }\n\n  return uci.declaringType.constructor != null ? new uci.declaringType.constructor(uci.tag, uci.name, ...values) : {};\n}\nexport function makeRecord(t, values) {\n  const fields = getRecordElements(t);\n\n  if (fields.length !== values.length) {\n    throw new Error(`Expected an array of length ${fields.length} but got ${values.length}`);\n  }\n\n  return t.constructor != null ? new t.constructor(...values) : makeAnonRecord(fields.reduce((obj, [key, _t], i) => {\n    obj[key] = values[i];\n    return obj;\n  }, {}));\n}\nexport function makeTuple(values, _t) {\n  return values;\n} // Fable.Core.Reflection\n\nfunction assertUnion(x) {\n  if (!(x instanceof Union)) {\n    throw new Error(`Value is not an F# union type`);\n  }\n}\n\nexport function getCaseTag(x) {\n  assertUnion(x);\n  return x.tag;\n}\nexport function getCaseName(x) {\n  assertUnion(x);\n  return x.name;\n}\nexport function getCaseFields(x) {\n  assertUnion(x);\n  return x.fields;\n}","import { Record, declare, Union } from \"./fable-library.2.4.13/Types\";\nimport { record, option, string, list, obj, union } from \"./fable-library.2.4.13/Reflection\";\nexport const Role = declare(function Ronnies_Client_Model_Role(tag, name, ...fields) {\n  Union.call(this, tag, name, ...fields);\n}, Union);\nexport function Role$reflection() {\n  return union(\"Ronnies.Client.Model.Role\", [], Role, () => [\"Admin\", \"Editor\", \"Visitor\"]);\n}\nexport const Model = declare(function Ronnies_Client_Model_Model(arg1, arg2, arg3) {\n  this.Events = arg1;\n  this.AuthorizationToken = arg2;\n  this.Role = arg3;\n}, Record);\nexport function Model$reflection() {\n  return record(\"Ronnies.Client.Model.Model\", [], Model, () => [[\"Events\", list(obj)], [\"AuthorizationToken\", option(string)], [\"Role\", Role$reflection()]]);\n}\nexport const Msg = declare(function Ronnies_Client_Model_Msg(tag, name, ...fields) {\n  Union.call(this, tag, name, ...fields);\n}, Union);\nexport function Msg$reflection() {\n  return union(\"Ronnies.Client.Model.Msg\", [], Msg, () => [[\"SetToken\", [string]]]);\n}","import { declare, Union } from \"./Types\";\nimport { compare, equals, structuralHash } from \"./Util\"; // Using a class here for better compatibility with TS files importing Some\n\nexport class Some {\n  constructor(value) {\n    this.value = value;\n  } // Don't add \"Some\" for consistency with erased options\n\n\n  toString() {\n    return String(this.value);\n  }\n\n  toJSON() {\n    return this.value;\n  }\n\n  GetHashCode() {\n    return structuralHash(this.value);\n  }\n\n  Equals(other) {\n    if (other == null) {\n      return false;\n    } else {\n      return equals(this.value, other instanceof Some ? other.value : other);\n    }\n  }\n\n  CompareTo(other) {\n    if (other == null) {\n      return 1;\n    } else {\n      return compare(this.value, other instanceof Some ? other.value : other);\n    }\n  }\n\n}\nexport function some(x) {\n  x = x === undefined ? null : x;\n  return x == null || x instanceof Some ? new Some(x) : x;\n}\nexport function value(x, acceptNull) {\n  if (x == null) {\n    if (!acceptNull) {\n      throw new Error(\"Option has no value\");\n    }\n\n    return null;\n  } else {\n    return x instanceof Some ? x.value : x;\n  }\n}\nexport function defaultArg(arg, defaultValue, f) {\n  return arg == null ? defaultValue : f != null ? f(value(arg)) : value(arg);\n}\nexport function defaultArgWith(arg, defThunk) {\n  return arg == null ? defThunk() : value(arg);\n}\nexport function filter(predicate, arg) {\n  return arg != null ? !predicate(value(arg)) ? null : arg : arg;\n}\nexport function map(f, arg) {\n  return arg == null ? null : some(f(value(arg)));\n}\nexport function mapMultiple(predicate, ...args) {\n  return args.every(x => x != null) ? predicate.apply(null, args) : null;\n}\nexport function bind(f, arg) {\n  return arg == null ? null : f(value(arg));\n}\nexport function tryOp(op, arg) {\n  try {\n    return some(op(arg));\n  } catch (_a) {\n    return null;\n  }\n}\nexport const Choice = declare(function Choice(tag, name, field) {\n  Union.call(this, tag, name, field);\n}, Union);\nexport function choice1(x) {\n  return new Choice(0, \"Choice1Of2\", x);\n}\nexport function choice2(x) {\n  return new Choice(1, \"Choice2Of2\", x);\n}\nexport function tryValueIfChoice1(x) {\n  return x.tag === 0 ? some(x.fields[0]) : null;\n}\nexport function tryValueIfChoice2(x) {\n  return x.tag === 1 ? some(x.fields[0]) : null;\n}\nexport const Result = declare(function Result(tag, name, field) {\n  Union.call(this, tag, name, field);\n}, Union);\nexport function ok(x) {\n  return new Result(0, \"Ok\", x);\n}\nexport function error(x) {\n  return new Result(1, \"Error\", x);\n}\nexport function mapOk(f, result) {\n  return result.tag === 0 ? ok(f(result.fields[0])) : result;\n}\nexport function mapError(f, result) {\n  return result.tag === 1 ? error(f(result.fields[0])) : result;\n}\nexport function bindOk(f, result) {\n  return result.tag === 0 ? f(result.fields[0]) : result;\n}","// https://github.com/MikeMcl/big.js/blob/01b3ce3a6b0ba7b42442ea48ec4ffc88d1669ec4/big.mjs\n\n/* tslint:disable */\nimport { combineHashCodes } from \"../fable-library.2.4.13/Util\"; // The shared prototype object.\n\nvar P = {\n  GetHashCode() {\n    return combineHashCodes([this.s, this.e].concat(this.c));\n  },\n\n  Equals(x) {\n    return !this.cmp(x);\n  },\n\n  CompareTo(x) {\n    return this.cmp(x);\n  }\n\n};\n/*\n *  big.js v5.2.2\n *  A small, fast, easy-to-use library for arbitrary-precision decimal arithmetic.\n *  Copyright (c) 2018 Michael Mclaughlin <M8ch88l@gmail.com>\n *  https://github.com/MikeMcl/big.js/LICENCE\n */\n\n/************************************** EDITABLE DEFAULTS *****************************************/\n// The default values below must be integers within the stated ranges.\n\n/*\n * The maximum number of decimal places (DP) of the results of operations involving division:\n * div and sqrt, and pow with negative exponents.\n */\n\nvar DP = 28,\n    // 0 to MAX_DP\n\n/*\n * The rounding mode (RM) used when rounding to the above decimal places.\n *\n *  0  Towards zero (i.e. truncate, no rounding).       (ROUND_DOWN)\n *  1  To nearest neighbour. If equidistant, round up.  (ROUND_HALF_UP)\n *  2  To nearest neighbour. If equidistant, to even.   (ROUND_HALF_EVEN)\n *  3  Away from zero.                                  (ROUND_UP)\n */\nRM = 1,\n    // 0, 1, 2 or 3\n// The maximum value of DP and Big.DP.\nMAX_DP = 1E6,\n    // 0 to 1000000\n// The maximum magnitude of the exponent argument to the pow method.\nMAX_POWER = 1E6,\n    // 1 to 1000000\n\n/*\n * The negative exponent (NE) at and beneath which toString returns exponential notation.\n * (JavaScript numbers: -7)\n * -1000000 is the minimum recommended exponent value of a Big.\n */\nNE = -29,\n    // 0 to -1000000\n\n/*\n * The positive exponent (PE) at and above which toString returns exponential notation.\n * (JavaScript numbers: 21)\n * 1000000 is the maximum recommended exponent value of a Big.\n * (This limit is not enforced or checked.)\n */\nPE = 29,\n    // 0 to 1000000\n\n/**************************************************************************************************/\n// Error messages.\nNAME = \"[big.js] \",\n    INVALID = NAME + \"Invalid \",\n    INVALID_DP = INVALID + \"decimal places\",\n    INVALID_RM = INVALID + \"rounding mode\",\n    DIV_BY_ZERO = NAME + \"Division by zero\",\n    UNDEFINED = void 0,\n    NUMERIC = /^-?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i;\n/*\n * Create and return a Big constructor.\n *\n */\n\nfunction _Big_() {\n  /*\n   * The Big constructor and exported function.\n   * Create and return a new instance of a Big number object.\n   *\n   * n {number|string|Big} A numeric value.\n   */\n  function Big(n) {\n    var x = this; // Enable constructor usage without new.\n\n    if (!(x instanceof Big)) return n === UNDEFINED ? _Big_() : new Big(n); // Duplicate.\n\n    if (n instanceof Big) {\n      x.s = n.s;\n      x.e = n.e;\n      x.c = n.c.slice();\n      normalize(x);\n    } else {\n      parse(x, n);\n    }\n    /*\n     * Retain a reference to this Big constructor, and shadow Big.prototype.constructor which\n     * points to Object.\n     */\n\n\n    x.constructor = Big;\n  }\n\n  Big.prototype = P;\n  Big.DP = DP;\n  Big.RM = RM;\n  Big.NE = NE;\n  Big.PE = PE;\n  Big.version = \"5.2.2\";\n  return Big;\n}\n\nfunction normalize(x) {\n  x = round(x, DP, 0);\n\n  if (x.c.length > 1 && !x.c[0]) {\n    let i = x.c.findIndex(x => x);\n    x.c = x.c.slice(i);\n    x.e = x.e - i;\n  }\n}\n/*\n * Parse the number or string value passed to a Big constructor.\n *\n * x {Big} A Big number instance.\n * n {number|string} A numeric value.\n */\n\n\nfunction parse(x, n) {\n  var e, i, nl; // Minus zero?\n\n  if (n === 0 && 1 / n < 0) n = \"-0\";else if (!NUMERIC.test(n += \"\")) throw Error(INVALID + \"number\"); // Determine sign.\n\n  x.s = n.charAt(0) == \"-\" ? (n = n.slice(1), -1) : 1; // Decimal point?\n\n  if ((e = n.indexOf(\".\")) > -1) n = n.replace(\".\", \"\"); // Exponential form?\n\n  if ((i = n.search(/e/i)) > 0) {\n    // Determine exponent.\n    if (e < 0) e = i;\n    e += +n.slice(i + 1);\n    n = n.substring(0, i);\n  } else if (e < 0) {\n    // Integer.\n    e = n.length;\n  }\n\n  nl = n.length; // Determine leading zeros before decimal point.\n\n  for (i = 0; i < e && i < nl && n.charAt(i) == \"0\";) ++i; // older version (ignores decimal point).\n  // // Determine leading zeros.\n  // for (i = 0; i < nl && n.charAt(i) == '0';) ++i;\n\n\n  if (i == nl) {\n    // Zero.\n    x.c = [x.e = 0];\n  } else {\n    x.e = e - i - 1;\n    x.c = []; // Convert string to array of digits without leading zeros\n\n    for (e = 0; i < nl;) x.c[e++] = +n.charAt(i++); // older version (doesn't keep trailing zeroes).\n    // // Determine trailing zeros.\n    // for (; nl > 0 && n.charAt(--nl) == '0';);\n    // // Convert string to array of digits without leading/trailing zeros.\n    // for (e = 0; i <= nl;) x.c[e++] = +n.charAt(i++);\n\n  }\n\n  x = round(x, Big.DP, Big.RM);\n  return x;\n}\n/*\n * Round Big x to a maximum of dp decimal places using rounding mode rm.\n * Called by stringify, P.div, P.round and P.sqrt.\n *\n * x {Big} The Big to round.\n * dp {number} Integer, 0 to MAX_DP inclusive.\n * rm {number} 0, 1, 2 or 3 (DOWN, HALF_UP, HALF_EVEN, UP)\n * [more] {boolean} Whether the result of division was truncated.\n */\n\n\nfunction round(x, dp, rm, more) {\n  var xc = x.c,\n      i = x.e + dp + 1;\n\n  if (i < xc.length) {\n    if (rm === 1) {\n      // xc[i] is the digit after the digit that may be rounded up.\n      more = xc[i] >= 5;\n    } else if (rm === 2) {\n      more = xc[i] > 5 || xc[i] == 5 && (more || i < 0 || xc[i + 1] !== UNDEFINED || xc[i - 1] & 1);\n    } else if (rm === 3) {\n      more = more || !!xc[0];\n    } else {\n      more = false;\n      if (rm !== 0) throw Error(INVALID_RM);\n    }\n\n    if (i < 1) {\n      xc.length = 1;\n\n      if (more) {\n        // 1, 0.1, 0.01, 0.001, 0.0001 etc.\n        x.e = -dp;\n        xc[0] = 1;\n      } else {\n        // Zero.\n        xc[0] = x.e = 0;\n      }\n    } else {\n      // Remove any digits after the required decimal places.\n      xc.length = i--; // Round up?\n\n      if (more) {\n        // Rounding up may mean the previous digit has to be rounded up.\n        for (; ++xc[i] > 9;) {\n          xc[i] = 0;\n\n          if (!i--) {\n            ++x.e;\n            xc.unshift(1);\n          }\n        }\n      } // Remove trailing zeros.\n\n\n      for (i = xc.length; !xc[--i];) xc.pop();\n    }\n  } else if (rm < 0 || rm > 3 || rm !== ~~rm) {\n    throw Error(INVALID_RM);\n  }\n\n  return x;\n}\n/*\n * Return a string representing the value of Big x in normal or exponential notation.\n * Handles P.toExponential, P.toFixed, P.toJSON, P.toPrecision, P.toString and P.valueOf.\n *\n * x {Big}\n * id? {number} Caller id.\n *         1 toExponential\n *         2 toFixed\n *         3 toPrecision\n *         4 valueOf\n * n? {number|undefined} Caller's argument.\n * k? {number|undefined}\n */\n\n\nfunction stringify(x, id, n, k) {\n  var e,\n      s,\n      Big = x.constructor,\n      z = !x.c[0];\n\n  if (n !== UNDEFINED) {\n    if (n !== ~~n || n < (id == 3) || n > MAX_DP) {\n      throw Error(id == 3 ? INVALID + \"precision\" : INVALID_DP);\n    }\n\n    x = new Big(x); // The index of the digit that may be rounded up.\n\n    n = k - x.e; // Round?\n\n    if (x.c.length > ++k) round(x, n, Big.RM); // toFixed: recalculate k as x.e may have changed if value rounded up.\n\n    if (id == 2) k = x.e + n + 1; // Append zeros?\n\n    for (; x.c.length < k;) x.c.push(0);\n  }\n\n  e = x.e;\n  s = x.c.join(\"\");\n  n = s.length; // Exponential notation?\n\n  if (id != 2 && (id == 1 || id == 3 && k <= e || e <= Big.NE || e >= Big.PE)) {\n    s = s.charAt(0) + (n > 1 ? \".\" + s.slice(1) : \"\") + (e < 0 ? \"e\" : \"e+\") + e; // Normal notation.\n  } else if (e < 0) {\n    for (; ++e;) s = \"0\" + s;\n\n    s = \"0.\" + s;\n  } else if (e > 0) {\n    if (++e > n) for (e -= n; e--;) s += \"0\";else if (e < n) s = s.slice(0, e) + \".\" + s.slice(e);\n  } else if (n > 1) {\n    s = s.charAt(0) + \".\" + s.slice(1);\n  }\n\n  return x.s < 0 && (!z || id == 4) ? \"-\" + s : s;\n} // Prototype/instance methods\n\n/*\n * Return a new Big whose value is the absolute value of this Big.\n */\n\n\nP.abs = function () {\n  var x = new this.constructor(this);\n  x.s = 1;\n  return x;\n};\n/*\n * Return 1 if the value of this Big is greater than the value of Big y,\n *       -1 if the value of this Big is less than the value of Big y, or\n *        0 if they have the same value.\n*/\n\n\nP.cmp = function (y) {\n  var isneg,\n      Big = this.constructor,\n      x = new Big(this),\n      y = new Big(y),\n      xc = x.c,\n      yc = y.c,\n      i = x.s,\n      j = y.s,\n      k = x.e,\n      l = y.e; // Either zero?\n\n  if (!xc[0] || !yc[0]) return !xc[0] ? !yc[0] ? 0 : -j : i; // Signs differ?\n\n  if (i != j) return i;\n  isneg = i < 0; // Compare exponents.\n\n  if (k != l) return k > l ^ isneg ? 1 : -1; // Compare digit by digit.\n\n  j = Math.max(xc.length, yc.length);\n\n  for (i = 0; i < j; i++) {\n    k = i < xc.length ? xc[i] : 0;\n    l = i < yc.length ? yc[i] : 0;\n    if (k != l) return k > l ^ isneg ? 1 : -1;\n  }\n\n  return 0; // old version (doesn't compare well trailing zeroes, e.g. 1.0 with 1.00)\n  // j = (k = xc.length) < (l = yc.length) ? k : l;\n  // // Compare digit by digit.\n  // for (i = -1; ++i < j;) {\n  //   if (xc[i] != yc[i]) return xc[i] > yc[i] ^ isneg ? 1 : -1;\n  // }\n  // // Compare lengths.\n  // return k == l ? 0 : k > l ^ isneg ? 1 : -1;\n};\n/*\n * Return a new Big whose value is the value of this Big divided by the value of Big y, rounded,\n * if necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.\n */\n\n\nP.div = function (y) {\n  var Big = this.constructor,\n      x = new Big(this),\n      y = new Big(y),\n      a = x.c,\n      // dividend\n  b = y.c,\n      // divisor\n  k = x.s == y.s ? 1 : -1,\n      dp = Big.DP;\n  if (dp !== ~~dp || dp < 0 || dp > MAX_DP) throw Error(INVALID_DP); // Divisor is zero?\n\n  if (!b[0]) throw Error(DIV_BY_ZERO); // Dividend is 0? Return +-0.\n\n  if (!a[0]) return new Big(k * 0);\n  var bl,\n      bt,\n      n,\n      cmp,\n      ri,\n      bz = b.slice(),\n      ai = bl = b.length,\n      al = a.length,\n      r = a.slice(0, bl),\n      // remainder\n  rl = r.length,\n      q = y,\n      // quotient\n  qc = q.c = [],\n      qi = 0,\n      d = dp + (q.e = x.e - y.e) + 1; // number of digits of the result\n\n  q.s = k;\n  k = d < 0 ? 0 : d; // Create version of divisor with leading zero.\n\n  bz.unshift(0); // Add zeros to make remainder as long as divisor.\n\n  for (; rl++ < bl;) r.push(0);\n\n  do {\n    // n is how many times the divisor goes into current remainder.\n    for (n = 0; n < 10; n++) {\n      // Compare divisor and remainder.\n      if (bl != (rl = r.length)) {\n        cmp = bl > rl ? 1 : -1;\n      } else {\n        for (ri = -1, cmp = 0; ++ri < bl;) {\n          if (b[ri] != r[ri]) {\n            cmp = b[ri] > r[ri] ? 1 : -1;\n            break;\n          }\n        }\n      } // If divisor < remainder, subtract divisor from remainder.\n\n\n      if (cmp < 0) {\n        // Remainder can't be more than 1 digit longer than divisor.\n        // Equalise lengths using divisor with extra leading zero?\n        for (bt = rl == bl ? b : bz; rl;) {\n          if (r[--rl] < bt[rl]) {\n            ri = rl;\n\n            for (; ri && !r[--ri];) r[ri] = 9;\n\n            --r[ri];\n            r[rl] += 10;\n          }\n\n          r[rl] -= bt[rl];\n        }\n\n        for (; !r[0];) r.shift();\n      } else {\n        break;\n      }\n    } // Add the digit n to the result array.\n\n\n    qc[qi++] = cmp ? n : ++n; // Update the remainder.\n\n    if (r[0] && cmp) r[rl] = a[ai] || 0;else r = [a[ai]];\n  } while ((ai++ < al || r[0] !== UNDEFINED) && k--); // Leading zero? Do not remove if result is simply zero (qi == 1).\n\n\n  if (!qc[0] && qi != 1) {\n    // There can't be more than one zero.\n    qc.shift();\n    q.e--;\n  } // Round?\n\n\n  if (qi > d) round(q, dp, Big.RM, r[0] !== UNDEFINED);\n  return q;\n};\n/*\n * Return true if the value of this Big is equal to the value of Big y, otherwise return false.\n */\n\n\nP.eq = function (y) {\n  return !this.cmp(y);\n};\n/*\n * Return true if the value of this Big is greater than the value of Big y, otherwise return\n * false.\n */\n\n\nP.gt = function (y) {\n  return this.cmp(y) > 0;\n};\n/*\n * Return true if the value of this Big is greater than or equal to the value of Big y, otherwise\n * return false.\n */\n\n\nP.gte = function (y) {\n  return this.cmp(y) > -1;\n};\n/*\n * Return true if the value of this Big is less than the value of Big y, otherwise return false.\n */\n\n\nP.lt = function (y) {\n  return this.cmp(y) < 0;\n};\n/*\n * Return true if the value of this Big is less than or equal to the value of Big y, otherwise\n * return false.\n */\n\n\nP.lte = function (y) {\n  return this.cmp(y) < 1;\n};\n/*\n * Return a new Big whose value is the value of this Big minus the value of Big y.\n */\n\n\nP.minus = P.sub = function (y) {\n  var i,\n      j,\n      t,\n      xlty,\n      Big = this.constructor,\n      x = new Big(this),\n      y = new Big(y),\n      a = x.s,\n      b = y.s; // Signs differ?\n\n  if (a != b) {\n    y.s = -b;\n    return x.plus(y);\n  }\n\n  var xc = x.c.slice(),\n      xe = x.e,\n      yc = y.c,\n      ye = y.e; // Either zero?\n\n  if (!xc[0] || !yc[0]) {\n    // y is non-zero? x is non-zero? Or both are zero.\n    return yc[0] ? (y.s = -b, y) : new Big(xc[0] ? x : 0);\n  } // Determine which is the bigger number. Prepend zeros to equalise exponents.\n\n\n  if (a = xe - ye) {\n    if (xlty = a < 0) {\n      a = -a;\n      t = xc;\n    } else {\n      ye = xe;\n      t = yc;\n    }\n\n    t.reverse();\n\n    for (b = a; b--;) t.push(0);\n\n    t.reverse();\n  } else {\n    // Exponents equal. Check digit by digit.\n    j = ((xlty = xc.length < yc.length) ? xc : yc).length;\n\n    for (a = b = 0; b < j; b++) {\n      if (xc[b] != yc[b]) {\n        xlty = xc[b] < yc[b];\n        break;\n      }\n    }\n  } // x < y? Point xc to the array of the bigger number.\n\n\n  if (xlty) {\n    t = xc;\n    xc = yc;\n    yc = t;\n    y.s = -y.s;\n  }\n  /*\n   * Append zeros to xc if shorter. No need to add zeros to yc if shorter as subtraction only\n   * needs to start at yc.length.\n   */\n\n\n  if ((b = (j = yc.length) - (i = xc.length)) > 0) for (; b--;) xc[i++] = 0; // Subtract yc from xc.\n\n  for (b = i; j > a;) {\n    if (xc[--j] < yc[j]) {\n      for (i = j; i && !xc[--i];) xc[i] = 9;\n\n      --xc[i];\n      xc[j] += 10;\n    }\n\n    xc[j] -= yc[j];\n  } // Remove trailing zeros.\n\n\n  for (; xc[--b] === 0;) xc.pop(); // Remove leading zeros and adjust exponent accordingly.\n\n\n  for (; xc[0] === 0;) {\n    xc.shift();\n    --ye;\n  }\n\n  if (!xc[0]) {\n    // n - n = +0\n    y.s = 1; // Result must be zero.\n\n    xc = [ye = 0];\n  }\n\n  y.c = xc;\n  y.e = ye;\n  return y;\n};\n/*\n * Return a new Big whose value is the value of this Big modulo the value of Big y.\n */\n\n\nP.mod = function (y) {\n  var ygtx,\n      Big = this.constructor,\n      x = new Big(this),\n      y = new Big(y),\n      a = x.s,\n      b = y.s;\n  if (!y.c[0]) throw Error(DIV_BY_ZERO);\n  x.s = y.s = 1;\n  ygtx = y.cmp(x) == 1;\n  x.s = a;\n  y.s = b;\n  if (ygtx) return new Big(x);\n  a = Big.DP;\n  b = Big.RM;\n  Big.DP = Big.RM = 0;\n  x = x.div(y);\n  Big.DP = a;\n  Big.RM = b;\n  return this.minus(x.times(y));\n};\n/*\n * Return a new Big whose value is the value of this Big plus the value of Big y.\n */\n\n\nP.plus = P.add = function (y) {\n  var t,\n      Big = this.constructor,\n      x = new Big(this),\n      y = new Big(y),\n      a = x.s,\n      b = y.s; // Signs differ?\n\n  if (a != b) {\n    y.s = -b;\n    return x.minus(y);\n  }\n\n  var xe = x.e,\n      xc = x.c,\n      ye = y.e,\n      yc = y.c; // Either zero? y is non-zero? x is non-zero? Or both are zero.\n\n  if (!xc[0] || !yc[0]) return yc[0] ? y : new Big(xc[0] ? x : a * 0);\n  xc = xc.slice(); // Prepend zeros to equalise exponents.\n  // Note: reverse faster than unshifts.\n\n  if (a = xe - ye) {\n    if (a > 0) {\n      ye = xe;\n      t = yc;\n    } else {\n      a = -a;\n      t = xc;\n    }\n\n    t.reverse();\n\n    for (; a--;) t.push(0);\n\n    t.reverse();\n  } // Point xc to the longer array.\n\n\n  if (xc.length - yc.length < 0) {\n    t = yc;\n    yc = xc;\n    xc = t;\n  }\n\n  a = yc.length; // Only start adding at yc.length - 1 as the further digits of xc can be left as they are.\n\n  for (b = 0; a; xc[a] %= 10) b = (xc[--a] = xc[a] + yc[a] + b) / 10 | 0; // No need to check for zero, as +x + +y != 0 && -x + -y != 0\n\n\n  if (b) {\n    xc.unshift(b);\n    ++ye;\n  } // Remove trailing zeros.\n\n\n  for (a = xc.length; xc[--a] === 0;) xc.pop();\n\n  y.c = xc;\n  y.e = ye;\n  return y;\n};\n/*\n * Return a Big whose value is the value of this Big raised to the power n.\n * If n is negative, round to a maximum of Big.DP decimal places using rounding\n * mode Big.RM.\n *\n * n {number} Integer, -MAX_POWER to MAX_POWER inclusive.\n */\n\n\nP.pow = function (n) {\n  var Big = this.constructor,\n      x = new Big(this),\n      y = new Big(1),\n      one = new Big(1),\n      isneg = n < 0;\n  if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) throw Error(INVALID + \"exponent\");\n  if (isneg) n = -n;\n\n  for (;;) {\n    if (n & 1) y = y.times(x);\n    n >>= 1;\n    if (!n) break;\n    x = x.times(x);\n  }\n\n  return isneg ? one.div(y) : y;\n};\n/*\n * Return a new Big whose value is the value of this Big rounded using rounding mode rm\n * to a maximum of dp decimal places, or, if dp is negative, to an integer which is a\n * multiple of 10**-dp.\n * If dp is not specified, round to 0 decimal places.\n * If rm is not specified, use Big.RM.\n *\n * dp? {number} Integer, -MAX_DP to MAX_DP inclusive.\n * rm? 0, 1, 2 or 3 (ROUND_DOWN, ROUND_HALF_UP, ROUND_HALF_EVEN, ROUND_UP)\n */\n\n\nP.round = function (dp, rm) {\n  var Big = this.constructor;\n  if (dp === UNDEFINED) dp = 0;else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) throw Error(INVALID_DP);\n  return round(new Big(this), dp, rm === UNDEFINED ? Big.RM : rm);\n};\n/*\n * Return a new Big whose value is the square root of the value of this Big, rounded, if\n * necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.\n */\n\n\nP.sqrt = function () {\n  var r,\n      c,\n      t,\n      Big = this.constructor,\n      x = new Big(this),\n      s = x.s,\n      e = x.e,\n      half = new Big(0.5); // Zero?\n\n  if (!x.c[0]) return new Big(x); // Negative?\n\n  if (s < 0) throw Error(NAME + \"No square root\"); // Estimate.\n\n  s = Math.sqrt(x + \"\"); // Math.sqrt underflow/overflow?\n  // Re-estimate: pass x coefficient to Math.sqrt as integer, then adjust the result exponent.\n\n  if (s === 0 || s === 1 / 0) {\n    c = x.c.join(\"\");\n    if (!(c.length + e & 1)) c += \"0\";\n    s = Math.sqrt(c);\n    e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);\n    r = new Big((s == 1 / 0 ? \"1e\" : (s = s.toExponential()).slice(0, s.indexOf(\"e\") + 1)) + e);\n  } else {\n    r = new Big(s);\n  }\n\n  e = r.e + (Big.DP += 4); // Newton-Raphson iteration.\n\n  do {\n    t = r;\n    r = half.times(t.plus(x.div(t)));\n  } while (t.c.slice(0, e).join(\"\") !== r.c.slice(0, e).join(\"\"));\n\n  return round(r, Big.DP -= 4, Big.RM);\n};\n/*\n * Return a new Big whose value is the value of this Big times the value of Big y.\n */\n\n\nP.times = P.mul = function (y) {\n  var c,\n      Big = this.constructor,\n      x = new Big(this),\n      y = new Big(y),\n      xc = x.c,\n      yc = y.c,\n      a = xc.length,\n      b = yc.length,\n      i = x.e,\n      j = y.e; // Determine sign of result.\n\n  y.s = x.s == y.s ? 1 : -1; // Return signed 0 if either 0.\n\n  if (!xc[0] || !yc[0]) return new Big(y.s * 0); // Initialise exponent of result as x.e + y.e.\n\n  y.e = i + j; // If array xc has fewer digits than yc, swap xc and yc, and lengths.\n\n  if (a < b) {\n    c = xc;\n    xc = yc;\n    yc = c;\n    j = a;\n    a = b;\n    b = j;\n  } // Initialise coefficient array of result with zeros.\n\n\n  for (c = new Array(j = a + b); j--;) c[j] = 0; // Multiply.\n  // i is initially xc.length.\n\n\n  for (i = b; i--;) {\n    b = 0; // a is yc.length.\n\n    for (j = a + i; j > i;) {\n      // Current sum of products at this digit position, plus carry.\n      b = c[j] + yc[i] * xc[j - i - 1] + b;\n      c[j--] = b % 10; // carry\n\n      b = b / 10 | 0;\n    }\n\n    c[j] = (c[j] + b) % 10;\n  } // Increment result exponent if there is a final carry, otherwise remove leading zero.\n\n\n  if (b) ++y.e;else c.shift(); // Remove trailing zeros.\n\n  for (i = c.length; !c[--i];) c.pop();\n\n  y.c = c;\n  return y;\n};\n/*\n * Return a string representing the value of this Big in exponential notation to dp fixed decimal\n * places and rounded using Big.RM.\n *\n * dp? {number} Integer, 0 to MAX_DP inclusive.\n */\n\n\nP.toExponential = function (dp) {\n  return stringify(this, 1, dp, dp);\n};\n/*\n * Return a string representing the value of this Big in normal notation to dp fixed decimal\n * places and rounded using Big.RM.\n *\n * dp? {number} Integer, 0 to MAX_DP inclusive.\n *\n * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\n * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\n */\n\n\nP.toFixed = function (dp) {\n  return stringify(this, 2, dp, this.e + dp);\n};\n/*\n * Return a string representing the value of this Big rounded to sd significant digits using\n * Big.RM. Use exponential notation if sd is less than the number of digits necessary to represent\n * the integer part of the value in normal notation.\n *\n * sd {number} Integer, 1 to MAX_DP inclusive.\n */\n\n\nP.toPrecision = function (sd) {\n  return stringify(this, 3, sd, sd - 1);\n};\n/*\n * Return a string representing the value of this Big.\n * Return exponential notation if this Big has a positive exponent equal to or greater than\n * Big.PE, or a negative exponent equal to or less than Big.NE.\n * Omit the sign for negative zero.\n */\n\n\nP.toString = function () {\n  return stringify(this);\n};\n/*\n * Return a string representing the value of this Big.\n * Return exponential notation if this Big has a positive exponent equal to or greater than\n * Big.PE, or a negative exponent equal to or less than Big.NE.\n * Include the sign for negative zero.\n */\n\n\nP.valueOf = P.toJSON = function () {\n  return stringify(this, 4);\n}; // Export\n\n\nexport var Big = _Big_();\nexport default Big;","import Decimal from \"../lib/big\";\nexport default Decimal;\nexport const get_Zero = new Decimal(0);\nexport const get_One = new Decimal(1);\nexport const get_MinusOne = new Decimal(-1);\nexport const get_MaxValue = new Decimal(\"79228162514264337593543950335\");\nexport const get_MinValue = new Decimal(\"-79228162514264337593543950335\");\nexport function compare(x, y) {\n  return x.cmp(y);\n}\nexport function equals(x, y) {\n  return !x.cmp(y);\n}\nexport function abs(x) {\n  return x.abs();\n}\nexport function round(x, digits = 0) {\n  return x.round(digits, 2\n  /* ROUND_HALF_EVEN */\n  );\n}\nexport function truncate(x) {\n  return x.round(0, 0\n  /* ROUND_DOWN */\n  );\n}\nexport function ceiling(x) {\n  return x.round(0, x.cmp(0) >= 0 ? 3\n  /* ROUND_UP */\n  : 0\n  /* ROUND_DOWN */\n  );\n}\nexport function floor(x) {\n  return x.round(0, x.cmp(0) >= 0 ? 0\n  /* ROUND_DOWN */\n  : 3\n  /* ROUND_UP */\n  );\n}\nexport function pow(x, n) {\n  return x.pow(n);\n}\nexport function sqrt(x) {\n  return x.sqrt();\n}\nexport function op_Addition(x, y) {\n  return x.add(y);\n}\nexport function op_Subtraction(x, y) {\n  return x.sub(y);\n}\nexport function op_Multiply(x, y) {\n  return x.mul(y);\n}\nexport function op_Division(x, y) {\n  return x.div(y);\n}\nexport function op_Modulus(x, y) {\n  return x.mod(y);\n}\nexport function op_UnaryNegation(x) {\n  const x2 = new Decimal(x);\n  x2.s = -x2.s || 0;\n  return x2;\n}\nexport const add = op_Addition;\nexport const subtract = op_Subtraction;\nexport const multiply = op_Multiply;\nexport const divide = op_Division;\nexport const remainder = op_Modulus;\nexport const negate = op_UnaryNegation;\nexport function toString(x) {\n  return x.toString();\n}\nexport function tryParse(str) {\n  try {\n    return [true, new Decimal(str.trim())];\n  } catch (_a) {\n    return [false, get_Zero];\n  }\n}\nexport function parse(str) {\n  const [ok, value] = tryParse(str);\n\n  if (ok) {\n    return value;\n  } else {\n    throw new Error(\"Input string was not in a correct format.\");\n  }\n}\nexport function toNumber(x) {\n  return +x;\n}\n\nfunction decimalToHex(dec, bitSize) {\n  const hex = new Uint8Array(bitSize / 4 | 0);\n  let hexCount = 1;\n\n  for (let d = 0; d < dec.length; d++) {\n    let value = dec[d];\n\n    for (let i = 0; i < hexCount; i++) {\n      const digit = hex[i] * 10 + value | 0;\n      hex[i] = digit & 0xF;\n      value = digit >> 4;\n    }\n\n    if (value !== 0) {\n      hex[hexCount++] = value;\n    }\n  }\n\n  return hex.slice(0, hexCount); // digits in reverse order\n}\n\nfunction hexToDecimal(hex, bitSize) {\n  const dec = new Uint8Array(bitSize * 301 / 1000 + 1 | 0);\n  let decCount = 1;\n\n  for (let d = hex.length - 1; d >= 0; d--) {\n    let carry = hex[d];\n\n    for (let i = 0; i < decCount; i++) {\n      const val = dec[i] * 16 + carry | 0;\n      dec[i] = val % 10 | 0;\n      carry = val / 10 | 0;\n    }\n\n    while (carry > 0) {\n      dec[decCount++] = carry % 10 | 0;\n      carry = carry / 10 | 0;\n    }\n  }\n\n  return dec.slice(0, decCount); // digits in reverse order\n}\n\nfunction setInt32Bits(hexDigits, bits, offset) {\n  for (let i = 0; i < 8; i++) {\n    hexDigits[offset + i] = bits >> i * 4 & 0xF;\n  }\n}\n\nfunction getInt32Bits(hexDigits, offset) {\n  let bits = 0;\n\n  for (let i = 0; i < 8; i++) {\n    bits = bits | hexDigits[offset + i] << i * 4;\n  }\n\n  return bits;\n}\n\nexport function fromIntArray(bits) {\n  return fromInts(bits[0], bits[1], bits[2], bits[3]);\n}\nexport function fromInts(low, mid, high, signExp) {\n  const isNegative = signExp < 0;\n  const scale = signExp >> 16 & 0x7F;\n  return fromParts(low, mid, high, isNegative, scale);\n}\nexport function fromParts(low, mid, high, isNegative, scale) {\n  const bitSize = 96;\n  const hexDigits = new Uint8Array(bitSize / 4);\n  setInt32Bits(hexDigits, low, 0);\n  setInt32Bits(hexDigits, mid, 8);\n  setInt32Bits(hexDigits, high, 16);\n  const decDigits = hexToDecimal(hexDigits, bitSize);\n  scale = scale & 0x7F;\n  const big = new Decimal(0);\n  big.c = Array.from(decDigits.reverse());\n  big.e = decDigits.length - scale - 1;\n  big.s = isNegative ? -1 : 1;\n  const d = new Decimal(big);\n  return d;\n}\nexport function getBits(d) {\n  const bitSize = 96;\n  const decDigits = Uint8Array.from(d.c);\n  const hexDigits = decimalToHex(decDigits, bitSize);\n  const low = getInt32Bits(hexDigits, 0);\n  const mid = getInt32Bits(hexDigits, 8);\n  const high = getInt32Bits(hexDigits, 16);\n  const decStr = d.toString();\n  const dotPos = decStr.indexOf(\".\");\n  const scale = dotPos < 0 ? 0 : decStr.length - dotPos - 1;\n  const signExp = (scale & 0x7F) << 16 | (d.s < 0 ? 0x80000000 : 0);\n  return [low, mid, high, signExp];\n}\nexport function makeRangeStepFunction(step, last) {\n  const stepComparedWithZero = step.cmp(get_Zero);\n\n  if (stepComparedWithZero === 0) {\n    throw new Error(\"The step of a range cannot be zero\");\n  }\n\n  const stepGreaterThanZero = stepComparedWithZero > 0;\n  return x => {\n    const comparedWithLast = x.cmp(last);\n\n    if (stepGreaterThanZero && comparedWithLast <= 0 || !stepGreaterThanZero && comparedWithLast >= 0) {\n      return [x, op_Addition(x, step)];\n    } else {\n      return null;\n    }\n  };\n}","export var NumberStyles;\n\n(function (NumberStyles) {\n  // None = 0x00000000,\n  // AllowLeadingWhite = 0x00000001,\n  // AllowTrailingWhite = 0x00000002,\n  // AllowLeadingSign = 0x00000004,\n  // AllowTrailingSign = 0x00000008,\n  // AllowParentheses = 0x00000010,\n  // AllowDecimalPoint = 0x00000020,\n  // AllowThousands = 0x00000040,\n  // AllowExponent = 0x00000080,\n  // AllowCurrencySymbol = 0x00000100,\n  NumberStyles[NumberStyles[\"AllowHexSpecifier\"] = 512] = \"AllowHexSpecifier\"; // Integer = AllowLeadingWhite | AllowTrailingWhite | AllowLeadingSign,\n  // HexNumber = AllowLeadingWhite | AllowTrailingWhite | AllowHexSpecifier,\n  // Number = AllowLeadingWhite | AllowTrailingWhite | AllowLeadingSign |\n  //          AllowTrailingSign | AllowDecimalPoint | AllowThousands,\n  // Float = AllowLeadingWhite | AllowTrailingWhite | AllowLeadingSign |\n  //         AllowDecimalPoint | AllowExponent,\n  // Currency = AllowLeadingWhite | AllowTrailingWhite | AllowLeadingSign | AllowTrailingSign |\n  //            AllowParentheses | AllowDecimalPoint | AllowThousands | AllowCurrencySymbol,\n  // Any = AllowLeadingWhite | AllowTrailingWhite | AllowLeadingSign | AllowTrailingSign |\n  //       AllowParentheses | AllowDecimalPoint | AllowThousands | AllowCurrencySymbol | AllowExponent,\n})(NumberStyles || (NumberStyles = {}));\n\nfunction validResponse(regexMatch, radix) {\n  const [,\n  /*all*/\n  sign, prefix, digits] = regexMatch;\n  return {\n    sign: sign || \"\",\n    prefix: prefix || \"\",\n    digits,\n    radix\n  };\n}\n\nfunction getRange(unsigned, bitsize) {\n  switch (bitsize) {\n    case 8:\n      return unsigned ? [0, 255] : [-128, 127];\n\n    case 16:\n      return unsigned ? [0, 65535] : [-32768, 32767];\n\n    case 32:\n      return unsigned ? [0, 4294967295] : [-2147483648, 2147483647];\n\n    default:\n      throw new Error(\"Invalid bit size.\");\n  }\n}\n\nfunction getInvalidDigits(radix) {\n  switch (radix) {\n    case 2:\n      return /[^0-1]/;\n\n    case 8:\n      return /[^0-7]/;\n\n    case 10:\n      return /[^0-9]/;\n\n    case 16:\n      return /[^0-9a-fA-F]/;\n\n    default:\n      throw new Error(\"Invalid Base.\");\n  }\n}\n\nfunction getRadix(prefix, style) {\n  if (style & NumberStyles.AllowHexSpecifier) {\n    return 16;\n  } else {\n    switch (prefix) {\n      case \"0b\":\n      case \"0B\":\n        return 2;\n\n      case \"0o\":\n      case \"0O\":\n        return 8;\n\n      case \"0x\":\n      case \"0X\":\n        return 16;\n\n      default:\n        return 10;\n    }\n  }\n}\n\nexport function isValid(str, style, radix) {\n  const integerRegex = /^\\s*([\\+\\-])?(0[xXoObB])?([0-9a-fA-F]+)\\s*$/;\n  const res = integerRegex.exec(str.replace(/_/g, \"\"));\n\n  if (res != null) {\n    const [,,\n    /*all*/\n\n    /*sign*/\n    prefix, digits] = res;\n    radix = radix || getRadix(prefix, style);\n    const invalidDigits = getInvalidDigits(radix);\n\n    if (!invalidDigits.test(digits)) {\n      return validResponse(res, radix);\n    }\n  }\n\n  return null;\n}\nexport function parse(str, style, unsigned, bitsize, radix) {\n  const res = isValid(str, style, radix);\n\n  if (res != null) {\n    let v = Number.parseInt(res.sign + res.digits, res.radix);\n\n    if (!Number.isNaN(v)) {\n      const [umin, umax] = getRange(true, bitsize);\n\n      if (!unsigned && res.radix !== 10 && v >= umin && v <= umax) {\n        v = v << 32 - bitsize >> 32 - bitsize;\n      }\n\n      const [min, max] = getRange(unsigned, bitsize);\n\n      if (v >= min && v <= max) {\n        return v;\n      }\n    }\n  }\n\n  throw new Error(\"Input string was not in a correct format.\");\n}\nexport function tryParse(str, style, unsigned, bitsize) {\n  try {\n    const v = parse(str, style, unsigned, bitsize);\n    return [true, v];\n  } catch (_a) {// supress error\n  }\n\n  return [false, 0];\n}\nexport function op_UnaryNegation_Int8(x) {\n  return x === -128 ? x : -x;\n}\nexport function op_UnaryNegation_Int16(x) {\n  return x === -32768 ? x : -x;\n}\nexport function op_UnaryNegation_Int32(x) {\n  return x === -2147483648 ? x : -x;\n}","// Adapted from: https://github.com/dcodeIO/long.js/blob/master/src/long.js\n// Apache License 2.0: https://github.com/dcodeIO/long.js/blob/master/LICENSE\nexport default Long;\n/**\n * wasm optimizations, to do native i64 multiplication and divide\n */\n\nvar wasm = null;\n\ntry {\n  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;\n} catch (e) {} // no wasm support :(\n\n/**\n * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\n *  See the from* functions below for more convenient ways of constructing Longs.\n * @exports Long\n * @class A Long class for representing a 64 bit two's-complement integer value.\n * @param {number} low The low (signed) 32 bits of the long\n * @param {number} high The high (signed) 32 bits of the long\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @constructor\n */\n\n\nexport function Long(low, high, unsigned) {\n  /**\n   * The low 32 bits as a signed value.\n   * @type {number}\n   */\n  this.low = low | 0;\n  /**\n   * The high 32 bits as a signed value.\n   * @type {number}\n   */\n\n  this.high = high | 0;\n  /**\n   * Whether unsigned or not.\n   * @type {boolean}\n   */\n\n  this.unsigned = !!unsigned;\n}\n\nLong.prototype.GetHashCode = function () {\n  let h1 = this.unsigned ? 1 : 0;\n  h1 = (h1 << 5) + h1 ^ this.high;\n  h1 = (h1 << 5) + h1 ^ this.low;\n  return h1;\n};\n\nLong.prototype.Equals = function (x) {\n  return equals(this, x);\n};\n\nLong.prototype.CompareTo = function (x) {\n  return compare(this, x);\n};\n\nLong.prototype.toString = function (radix) {\n  return toString(this, radix);\n};\n\nLong.prototype.toJSON = function () {\n  return toString(this);\n}; // The internal representation of a long is the two given signed, 32-bit values.\n// We use 32-bit pieces because these are the size of integers on which\n// Javascript performs bit-operations.  For operations like addition and\n// multiplication, we split each number into 16 bit pieces, which can easily be\n// multiplied within Javascript's floating-point representation without overflow\n// or change in sign.\n//\n// In the algorithms below, we frequently reduce the negative case to the\n// positive case by negating the input(s) and then post-processing the result.\n// Note that we must ALWAYS check specially whether those values are MIN_VALUE\n// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n// a positive number, it overflows back into a negative).  Not handling this\n// case would often result in infinite recursion.\n//\n// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\n// methods on which they depend.\n\n/**\n * An indicator used to reliably determine if an object is a Long or not.\n * @type {boolean}\n * @const\n * @private\n */\n\n\nLong.prototype.__isLong__;\nObject.defineProperty(Long.prototype, \"__isLong__\", {\n  value: true\n});\n/**\n * @function\n * @param {*} obj Object\n * @returns {boolean}\n * @inner\n */\n\nexport function isLong(obj) {\n  return (obj && obj[\"__isLong__\"]) === true;\n}\n/**\n * Tests if the specified object is a Long.\n * @function\n * @param {*} obj Object\n * @returns {boolean}\n */\n// Long.isLong = isLong;\n\n/**\n * A cache of the Long representations of small integer values.\n * @type {!Object}\n * @inner\n */\n\nvar INT_CACHE = {};\n/**\n * A cache of the Long representations of small unsigned integer values.\n * @type {!Object}\n * @inner\n */\n\nvar UINT_CACHE = {};\n/**\n * @param {number} value\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\n\nexport function fromInt(value, unsigned) {\n  var obj, cachedObj, cache;\n\n  if (unsigned) {\n    value >>>= 0;\n\n    if (cache = 0 <= value && value < 256) {\n      cachedObj = UINT_CACHE[value];\n      if (cachedObj) return cachedObj;\n    }\n\n    obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);\n    if (cache) UINT_CACHE[value] = obj;\n    return obj;\n  } else {\n    value |= 0;\n\n    if (cache = -128 <= value && value < 128) {\n      cachedObj = INT_CACHE[value];\n      if (cachedObj) return cachedObj;\n    }\n\n    obj = fromBits(value, value < 0 ? -1 : 0, false);\n    if (cache) INT_CACHE[value] = obj;\n    return obj;\n  }\n}\n/**\n * Returns a Long representing the given 32 bit integer value.\n * @function\n * @param {number} value The 32 bit integer in question\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\n// Long.fromInt = fromInt;\n\n/**\n * @param {number} value\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\n\nexport function fromNumber(value, unsigned) {\n  if (isNaN(value)) return unsigned ? UZERO : ZERO;\n\n  if (unsigned) {\n    if (value < 0) return UZERO;\n    if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;\n  } else {\n    if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;\n    if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;\n  }\n\n  if (value < 0) return negate(fromNumber(-value, unsigned));\n  return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);\n}\n/**\n * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\n * @function\n * @param {number} value The number in question\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\n// Long.fromNumber = fromNumber;\n\n/**\n * @param {number} lowBits\n * @param {number} highBits\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\n\nexport function fromBits(lowBits, highBits, unsigned) {\n  return new Long(lowBits, highBits, unsigned);\n}\n/**\n * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\n *  assumed to use 32 bits.\n * @function\n * @param {number} lowBits The low 32 bits\n * @param {number} highBits The high 32 bits\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\n// Long.fromBits = fromBits;\n\n/**\n * @function\n * @param {number} base\n * @param {number} exponent\n * @returns {number}\n * @inner\n */\n\nvar pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\n\n/**\n * @param {string} str\n * @param {(boolean|number)=} unsigned\n * @param {number=} radix\n * @returns {!Long}\n * @inner\n */\n\nexport function fromString(str, unsigned, radix) {\n  if (str.length === 0) throw Error(\"empty string\");\n  if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\") return ZERO;\n\n  if (typeof unsigned === \"number\") {\n    // For goog.math.long compatibility\n    radix = unsigned, unsigned = false;\n  } else {\n    unsigned = !!unsigned;\n  }\n\n  radix = radix || 10;\n  if (radix < 2 || 36 < radix) throw RangeError(\"radix\");\n  var p = str.indexOf(\"-\");\n  if (p > 0) throw Error(\"interior hyphen\");else if (p === 0) {\n    return negate(fromString(str.substring(1), unsigned, radix));\n  } // Do several (8) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n\n  var radixToPower = fromNumber(pow_dbl(radix, 8));\n  var result = ZERO;\n\n  for (var i = 0; i < str.length; i += 8) {\n    var size = Math.min(8, str.length - i),\n        value = parseInt(str.substring(i, i + size), radix);\n\n    if (size < 8) {\n      var power = fromNumber(pow_dbl(radix, size));\n      result = add(multiply(result, power), fromNumber(value));\n    } else {\n      result = multiply(result, radixToPower);\n      result = add(result, fromNumber(value));\n    }\n  }\n\n  result.unsigned = unsigned;\n  return result;\n}\n/**\n * Returns a Long representation of the given string, written using the specified radix.\n * @function\n * @param {string} str The textual representation of the Long\n * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\n * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\n * @returns {!Long} The corresponding Long value\n */\n// Long.fromString = fromString;\n\n/**\n * @function\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\n\nexport function fromValue(val, unsigned) {\n  if (typeof val === \"number\") return fromNumber(val, unsigned);\n  if (typeof val === \"string\") return fromString(val, unsigned); // Throws for non-objects, converts non-instanceof Long:\n\n  return fromBits(val.low, val.high, typeof unsigned === \"boolean\" ? unsigned : val.unsigned);\n}\n/**\n * Converts the specified value to a Long using the appropriate from* function for its type.\n * @function\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long}\n */\n// Long.fromValue = fromValue;\n// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\n// no runtime penalty for these.\n\n/**\n * @type {number}\n * @const\n * @inner\n */\n\nvar TWO_PWR_16_DBL = 1 << 16;\n/**\n * @type {number}\n * @const\n * @inner\n */\n\nvar TWO_PWR_24_DBL = 1 << 24;\n/**\n * @type {number}\n * @const\n * @inner\n */\n\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\n/**\n * @type {number}\n * @const\n * @inner\n */\n\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\n/**\n * @type {number}\n * @const\n * @inner\n */\n\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\n/**\n * @type {!Long}\n * @const\n * @inner\n */\n\nvar TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\n/**\n * @type {!Long}\n * @inner\n */\n\nexport var ZERO = fromInt(0);\n/**\n * Signed zero.\n * @type {!Long}\n */\n// Long.ZERO = ZERO;\n\n/**\n * @type {!Long}\n * @inner\n */\n\nexport var UZERO = fromInt(0, true);\n/**\n * Unsigned zero.\n * @type {!Long}\n */\n// Long.UZERO = UZERO;\n\n/**\n * @type {!Long}\n * @inner\n */\n\nexport var ONE = fromInt(1);\n/**\n * Signed one.\n * @type {!Long}\n */\n// Long.ONE = ONE;\n\n/**\n * @type {!Long}\n * @inner\n */\n\nexport var UONE = fromInt(1, true);\n/**\n * Unsigned one.\n * @type {!Long}\n */\n// Long.UONE = UONE;\n\n/**\n * @type {!Long}\n * @inner\n */\n\nexport var NEG_ONE = fromInt(-1);\n/**\n * Signed negative one.\n * @type {!Long}\n */\n// Long.NEG_ONE = NEG_ONE;\n\n/**\n * @type {!Long}\n * @inner\n */\n\nexport var MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);\n/**\n * Maximum signed value.\n * @type {!Long}\n */\n// Long.MAX_VALUE = MAX_VALUE;\n\n/**\n * @type {!Long}\n * @inner\n */\n\nexport var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);\n/**\n * Maximum unsigned value.\n * @type {!Long}\n */\n// Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\n\n/**\n * @type {!Long}\n * @inner\n */\n\nexport var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);\n/**\n * Minimum signed value.\n * @type {!Long}\n */\n// Long.MIN_VALUE = MIN_VALUE;\n\n/**\n * @alias Long.prototype\n * @inner\n */\n// var LongPrototype = Long.prototype;\n\n/**\n * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\n * @this {!Long}\n * @returns {number}\n */\n\nexport function toInt($this) {\n  return $this.unsigned ? $this.low >>> 0 : $this.low;\n}\n;\n/**\n * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\n * @this {!Long}\n * @returns {number}\n */\n\nexport function toNumber($this) {\n  if ($this.unsigned) return ($this.high >>> 0) * TWO_PWR_32_DBL + ($this.low >>> 0);\n  return $this.high * TWO_PWR_32_DBL + ($this.low >>> 0);\n}\n;\n/**\n * Converts the Long to a string written in the specified radix.\n * @this {!Long}\n * @param {number=} radix Radix (2-36), defaults to 10\n * @returns {string}\n * @override\n * @throws {RangeError} If `radix` is out of range\n */\n\nexport function toString($this, radix) {\n  radix = radix || 10;\n  if (radix < 2 || 36 < radix) throw RangeError(\"radix\");\n  if (isZero($this)) return \"0\";\n\n  if (isNegative($this)) {\n    // Unsigned Longs are never negative\n    if (equals($this, MIN_VALUE)) {\n      // We need to change the Long value before it can be negated, so we remove\n      // the bottom-most digit in this base and then recurse to do the rest.\n      var radixLong = fromNumber(radix),\n          div = divide($this, radixLong),\n          rem1 = subtract(multiply(div, radixLong), $this);\n      return toString(div, radix) + toInt(rem1).toString(radix);\n    } else return \"-\" + toString(negate($this), radix);\n  } // Do several (6) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n\n\n  var radixToPower = fromNumber(pow_dbl(radix, 6), $this.unsigned),\n      rem = $this;\n  var result = \"\";\n\n  while (true) {\n    var remDiv = divide(rem, radixToPower),\n        intval = toInt(subtract(rem, multiply(remDiv, radixToPower))) >>> 0,\n        digits = intval.toString(radix);\n    rem = remDiv;\n    if (isZero(rem)) return digits + result;else {\n      while (digits.length < 6) digits = \"0\" + digits;\n\n      result = \"\" + digits + result;\n    }\n  }\n}\n;\n/**\n * Gets the high 32 bits as a signed integer.\n * @this {!Long}\n * @returns {number} Signed high bits\n */\n\nexport function getHighBits($this) {\n  return $this.high;\n}\n;\n/**\n * Gets the high 32 bits as an unsigned integer.\n * @this {!Long}\n * @returns {number} Unsigned high bits\n */\n\nexport function getHighBitsUnsigned($this) {\n  return $this.high >>> 0;\n}\n;\n/**\n * Gets the low 32 bits as a signed integer.\n * @this {!Long}\n * @returns {number} Signed low bits\n */\n\nexport function getLowBits($this) {\n  return $this.low;\n}\n;\n/**\n * Gets the low 32 bits as an unsigned integer.\n * @this {!Long}\n * @returns {number} Unsigned low bits\n */\n\nexport function getLowBitsUnsigned($this) {\n  return $this.low >>> 0;\n}\n;\n/**\n * Gets the number of bits needed to represent the absolute value of this Long.\n * @this {!Long}\n * @returns {number}\n */\n\nexport function getNumBitsAbs($this) {\n  if (isNegative($this)) // Unsigned Longs are never negative\n    return equals($this, MIN_VALUE) ? 64 : getNumBitsAbs(negate($this));\n  var val = $this.high != 0 ? $this.high : $this.low;\n\n  for (var bit = 31; bit > 0; bit--) if ((val & 1 << bit) != 0) break;\n\n  return $this.high != 0 ? bit + 33 : bit + 1;\n}\n;\n/**\n * Tests if this Long's value equals zero.\n * @this {!Long}\n * @returns {boolean}\n */\n\nexport function isZero($this) {\n  return $this.high === 0 && $this.low === 0;\n}\n;\n/**\n * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\n * @returns {boolean}\n */\n// LongPrototype.eqz = LongPrototype.isZero;\n\n/**\n * Tests if this Long's value is negative.\n * @this {!Long}\n * @returns {boolean}\n */\n\nexport function isNegative($this) {\n  return !$this.unsigned && $this.high < 0;\n}\n;\n/**\n * Tests if this Long's value is positive.\n * @this {!Long}\n * @returns {boolean}\n */\n\nexport function isPositive($this) {\n  return $this.unsigned || $this.high >= 0;\n}\n;\n/**\n * Tests if this Long's value is odd.\n * @this {!Long}\n * @returns {boolean}\n */\n\nexport function isOdd($this) {\n  return ($this.low & 1) === 1;\n}\n;\n/**\n * Tests if this Long's value is even.\n * @this {!Long}\n * @returns {boolean}\n */\n\nexport function isEven($this) {\n  return ($this.low & 1) === 0;\n}\n;\n/**\n * Tests if this Long's value equals the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n\nexport function equals($this, other) {\n  if (!isLong(other)) other = fromValue(other);\n  if ($this.unsigned !== other.unsigned && $this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;\n  return $this.high === other.high && $this.low === other.low;\n}\n;\n/**\n * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.eq = LongPrototype.equals;\n\n/**\n * Tests if this Long's value differs from the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n\nexport function notEquals($this, other) {\n  return !equals($this,\n  /* validates */\n  other);\n}\n;\n/**\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.neq = LongPrototype.notEquals;\n\n/**\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.ne = LongPrototype.notEquals;\n\n/**\n * Tests if this Long's value is less than the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n\nexport function lessThan($this, other) {\n  return compare($this,\n  /* validates */\n  other) < 0;\n}\n;\n/**\n * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.lt = LongPrototype.lessThan;\n\n/**\n * Tests if this Long's value is less than or equal the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n\nexport function lessThanOrEqual($this, other) {\n  return compare($this,\n  /* validates */\n  other) <= 0;\n}\n;\n/**\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.lte = LongPrototype.lessThanOrEqual;\n\n/**\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.le = LongPrototype.lessThanOrEqual;\n\n/**\n * Tests if this Long's value is greater than the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n\nexport function greaterThan($this, other) {\n  return compare($this,\n  /* validates */\n  other) > 0;\n}\n;\n/**\n * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.gt = LongPrototype.greaterThan;\n\n/**\n * Tests if this Long's value is greater than or equal the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n\nexport function greaterThanOrEqual($this, other) {\n  return compare($this,\n  /* validates */\n  other) >= 0;\n}\n;\n/**\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.gte = LongPrototype.greaterThanOrEqual;\n\n/**\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.ge = LongPrototype.greaterThanOrEqual;\n\n/**\n * Compares this Long's value with the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n *  if the given one is greater\n */\n\nexport function compare($this, other) {\n  if (!isLong(other)) other = fromValue(other);\n  if (equals($this, other)) return 0;\n  var thisNeg = isNegative($this),\n      otherNeg = isNegative(other);\n  if (thisNeg && !otherNeg) return -1;\n  if (!thisNeg && otherNeg) return 1; // At this point the sign bits are the same\n\n  if (!$this.unsigned) return isNegative(subtract($this, other)) ? -1 : 1; // Both are positive if at least one is unsigned\n\n  return other.high >>> 0 > $this.high >>> 0 || other.high === $this.high && other.low >>> 0 > $this.low >>> 0 ? -1 : 1;\n}\n;\n/**\n * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n *  if the given one is greater\n */\n// LongPrototype.comp = LongPrototype.compare;\n\n/**\n * Negates this Long's value.\n * @this {!Long}\n * @returns {!Long} Negated Long\n */\n\nexport function negate($this) {\n  if (!$this.unsigned && equals($this, MIN_VALUE)) return MIN_VALUE;\n  return add(not($this), ONE);\n}\n;\n/**\n * Negates this Long's value. This is an alias of {@link Long#negate}.\n * @function\n * @returns {!Long} Negated Long\n */\n// LongPrototype.neg = LongPrototype.negate;\n\n/**\n * Returns the sum of this and the specified Long.\n * @this {!Long}\n * @param {!Long|number|string} addend Addend\n * @returns {!Long} Sum\n */\n\nexport function add($this, addend) {\n  if (!isLong(addend)) addend = fromValue(addend); // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n\n  var a48 = $this.high >>> 16;\n  var a32 = $this.high & 0xFFFF;\n  var a16 = $this.low >>> 16;\n  var a00 = $this.low & 0xFFFF;\n  var b48 = addend.high >>> 16;\n  var b32 = addend.high & 0xFFFF;\n  var b16 = addend.low >>> 16;\n  var b00 = addend.low & 0xFFFF;\n  var c48 = 0,\n      c32 = 0,\n      c16 = 0,\n      c00 = 0;\n  c00 += a00 + b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xFFFF;\n  c16 += a16 + b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c32 += a32 + b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c48 += a48 + b48;\n  c48 &= 0xFFFF;\n  return fromBits(c16 << 16 | c00, c48 << 16 | c32, $this.unsigned);\n}\n;\n/**\n * Returns the difference of this and the specified Long.\n * @this {!Long}\n * @param {!Long|number|string} subtrahend Subtrahend\n * @returns {!Long} Difference\n */\n\nexport function subtract($this, subtrahend) {\n  if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);\n  return add($this, negate(subtrahend));\n}\n;\n/**\n * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\n * @function\n * @param {!Long|number|string} subtrahend Subtrahend\n * @returns {!Long} Difference\n */\n// LongPrototype.sub = LongPrototype.subtract;\n\n/**\n * Returns the product of this and the specified Long.\n * @this {!Long}\n * @param {!Long|number|string} multiplier Multiplier\n * @returns {!Long} Product\n */\n\nexport function multiply($this, multiplier) {\n  if (isZero($this)) return $this.unsigned ? UZERO : ZERO;\n  if (!isLong(multiplier)) multiplier = fromValue(multiplier); // use wasm support if present\n\n  if (wasm) {\n    var low = wasm.mul($this.low, $this.high, multiplier.low, multiplier.high);\n    return fromBits(low, wasm.get_high(), $this.unsigned);\n  }\n\n  if (isZero(multiplier)) return $this.unsigned ? UZERO : ZERO;\n  if (equals($this, MIN_VALUE)) return isOdd(multiplier) ? MIN_VALUE : ZERO;\n  if (equals(multiplier, MIN_VALUE)) return isOdd($this) ? MIN_VALUE : ZERO;\n\n  if (isNegative($this)) {\n    if (isNegative(multiplier)) return multiply(negate($this), negate(multiplier));else return negate(multiply(negate($this), multiplier));\n  } else if (isNegative(multiplier)) return negate(multiply($this, negate(multiplier))); // If both longs are small, use float multiplication\n\n\n  if (lessThan($this, TWO_PWR_24) && lessThan(multiplier, TWO_PWR_24)) return fromNumber(toNumber($this) * toNumber(multiplier), $this.unsigned); // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n  // We can skip products that would overflow.\n\n  var a48 = $this.high >>> 16;\n  var a32 = $this.high & 0xFFFF;\n  var a16 = $this.low >>> 16;\n  var a00 = $this.low & 0xFFFF;\n  var b48 = multiplier.high >>> 16;\n  var b32 = multiplier.high & 0xFFFF;\n  var b16 = multiplier.low >>> 16;\n  var b00 = multiplier.low & 0xFFFF;\n  var c48 = 0,\n      c32 = 0,\n      c16 = 0,\n      c00 = 0;\n  c00 += a00 * b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xFFFF;\n  c16 += a16 * b00;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c16 += a00 * b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c32 += a32 * b00;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c32 += a16 * b16;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c32 += a00 * b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n  c48 &= 0xFFFF;\n  return fromBits(c16 << 16 | c00, c48 << 16 | c32, $this.unsigned);\n}\n;\n/**\n * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\n * @function\n * @param {!Long|number|string} multiplier Multiplier\n * @returns {!Long} Product\n */\n// LongPrototype.mul = LongPrototype.multiply;\n\n/**\n * Returns this Long divided by the specified. The result is signed if this Long is signed or\n *  unsigned if this Long is unsigned.\n * @this {!Long}\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Quotient\n */\n\nexport function divide($this, divisor) {\n  if (!isLong(divisor)) divisor = fromValue(divisor);\n  if (isZero(divisor)) throw Error(\"division by zero\"); // use wasm support if present\n\n  if (wasm) {\n    // guard against signed division overflow: the largest\n    // negative number / -1 would be 1 larger than the largest\n    // positive number, due to two's complement.\n    if (!$this.unsigned && $this.high === -0x80000000 && divisor.low === -1 && divisor.high === -1) {\n      // be consistent with non-wasm code path\n      return $this;\n    }\n\n    var low = ($this.unsigned ? wasm.div_u : wasm.div_s)($this.low, $this.high, divisor.low, divisor.high);\n    return fromBits(low, wasm.get_high(), $this.unsigned);\n  }\n\n  if (isZero($this)) return $this.unsigned ? UZERO : ZERO;\n  var approx, rem, res;\n\n  if (!$this.unsigned) {\n    // This section is only relevant for signed longs and is derived from the\n    // closure library as a whole.\n    if (equals($this, MIN_VALUE)) {\n      if (equals(divisor, ONE) || equals(divisor, NEG_ONE)) return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE\n      else if (equals(divisor, MIN_VALUE)) return ONE;else {\n          // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n          var halfThis = shiftRight($this, 1);\n          approx = shiftLeft(divide(halfThis, divisor), 1);\n\n          if (equals(approx, ZERO)) {\n            return isNegative(divisor) ? ONE : NEG_ONE;\n          } else {\n            rem = subtract($this, multiply(divisor, approx));\n            res = add(approx, divide(rem, divisor));\n            return res;\n          }\n        }\n    } else if (equals(divisor, MIN_VALUE)) return $this.unsigned ? UZERO : ZERO;\n\n    if (isNegative($this)) {\n      if (isNegative(divisor)) return divide(negate($this), negate(divisor));\n      return negate(divide(negate($this), divisor));\n    } else if (isNegative(divisor)) return negate(divide($this, negate(divisor)));\n\n    res = ZERO;\n  } else {\n    // The algorithm below has not been made for unsigned longs. It's therefore\n    // required to take special care of the MSB prior to running it.\n    if (!divisor.unsigned) divisor = toUnsigned(divisor);\n    if (greaterThan(divisor, $this)) return UZERO;\n    if (greaterThan(divisor, shiftRightUnsigned($this, 1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true\n      return UONE;\n    res = UZERO;\n  } // Repeat the following until the remainder is less than other:  find a\n  // floating-point that approximates remainder / other *from below*, add this\n  // into the result, and subtract it from the remainder.  It is critical that\n  // the approximate value is less than or equal to the real value so that the\n  // remainder never becomes negative.\n\n\n  rem = $this;\n\n  while (greaterThanOrEqual(rem, divisor)) {\n    // Approximate the result of division. This may be a little greater or\n    // smaller than the actual value.\n    approx = Math.max(1, Math.floor(toNumber(rem) / toNumber(divisor))); // We will tweak the approximate result by changing it in the 48-th digit or\n    // the smallest non-fractional digit, whichever is larger.\n\n    var log2 = Math.ceil(Math.log(approx) / Math.LN2),\n        delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48),\n        // Decrease the approximation until it is smaller than the remainder.  Note\n    // that if it is too large, the product overflows and is negative.\n    approxRes = fromNumber(approx),\n        approxRem = multiply(approxRes, divisor);\n\n    while (isNegative(approxRem) || greaterThan(approxRem, rem)) {\n      approx -= delta;\n      approxRes = fromNumber(approx, $this.unsigned);\n      approxRem = multiply(approxRes, divisor);\n    } // We know the answer can't be zero... and actually, zero would cause\n    // infinite recursion since we would make no progress.\n\n\n    if (isZero(approxRes)) approxRes = ONE;\n    res = add(res, approxRes);\n    rem = subtract(rem, approxRem);\n  }\n\n  return res;\n}\n;\n/**\n * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\n * @function\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Quotient\n */\n// LongPrototype.div = LongPrototype.divide;\n\n/**\n * Returns this Long modulo the specified.\n * @this {!Long}\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Remainder\n */\n\nexport function modulo($this, divisor) {\n  if (!isLong(divisor)) divisor = fromValue(divisor); // use wasm support if present\n\n  if (wasm) {\n    var low = ($this.unsigned ? wasm.rem_u : wasm.rem_s)($this.low, $this.high, divisor.low, divisor.high);\n    return fromBits(low, wasm.get_high(), $this.unsigned);\n  }\n\n  return subtract($this, multiply(divide($this, divisor), divisor));\n}\n;\n/**\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n * @function\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Remainder\n */\n// LongPrototype.mod = LongPrototype.modulo;\n\n/**\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n * @function\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Remainder\n */\n// LongPrototype.rem = LongPrototype.modulo;\n\n/**\n * Returns the bitwise NOT of this Long.\n * @this {!Long}\n * @returns {!Long}\n */\n\nexport function not($this) {\n  return fromBits(~$this.low, ~$this.high, $this.unsigned);\n}\n;\n/**\n * Returns the bitwise AND of this Long and the specified.\n * @this {!Long}\n * @param {!Long|number|string} other Other Long\n * @returns {!Long}\n */\n\nexport function and($this, other) {\n  if (!isLong(other)) other = fromValue(other);\n  return fromBits($this.low & other.low, $this.high & other.high, $this.unsigned);\n}\n;\n/**\n * Returns the bitwise OR of this Long and the specified.\n * @this {!Long}\n * @param {!Long|number|string} other Other Long\n * @returns {!Long}\n */\n\nexport function or($this, other) {\n  if (!isLong(other)) other = fromValue(other);\n  return fromBits($this.low | other.low, $this.high | other.high, $this.unsigned);\n}\n;\n/**\n * Returns the bitwise XOR of this Long and the given one.\n * @this {!Long}\n * @param {!Long|number|string} other Other Long\n * @returns {!Long}\n */\n\nexport function xor($this, other) {\n  if (!isLong(other)) other = fromValue(other);\n  return fromBits($this.low ^ other.low, $this.high ^ other.high, $this.unsigned);\n}\n;\n/**\n * Returns this Long with bits shifted to the left by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\n\nexport function shiftLeft($this, numBits) {\n  if (isLong(numBits)) numBits = toInt(numBits);\n  if ((numBits &= 63) === 0) return $this;else if (numBits < 32) return fromBits($this.low << numBits, $this.high << numBits | $this.low >>> 32 - numBits, $this.unsigned);else return fromBits(0, $this.low << numBits - 32, $this.unsigned);\n}\n;\n/**\n * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\n// LongPrototype.shl = LongPrototype.shiftLeft;\n\n/**\n * Returns this Long with bits arithmetically shifted to the right by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\n\nexport function shiftRight($this, numBits) {\n  if (isLong(numBits)) numBits = toInt(numBits);\n  if ((numBits &= 63) === 0) return $this;else if (numBits < 32) return fromBits($this.low >>> numBits | $this.high << 32 - numBits, $this.high >> numBits, $this.unsigned);else return fromBits($this.high >> numBits - 32, $this.high >= 0 ? 0 : -1, $this.unsigned);\n}\n;\n/**\n * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\n// LongPrototype.shr = LongPrototype.shiftRight;\n\n/**\n * Returns this Long with bits logically shifted to the right by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\n\nexport function shiftRightUnsigned($this, numBits) {\n  if (isLong(numBits)) numBits = toInt(numBits);\n  numBits &= 63;\n  if (numBits === 0) return $this;else {\n    var high = $this.high;\n\n    if (numBits < 32) {\n      var low = $this.low;\n      return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, $this.unsigned);\n    } else if (numBits === 32) return fromBits(high, 0, $this.unsigned);else return fromBits(high >>> numBits - 32, 0, $this.unsigned);\n  }\n}\n;\n/**\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\n// LongPrototype.shru = LongPrototype.shiftRightUnsigned;\n\n/**\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\n// LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\n\n/**\n * Returns this Long with bits rotated to the left by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\n\nexport const rotateLeft = function rotateLeft(numBits) {\n  var b;\n  if (isLong(numBits)) numBits = numBits.toInt();\n  if ((numBits &= 63) === 0) return this;\n  if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n\n  if (numBits < 32) {\n    b = 32 - numBits;\n    return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);\n  }\n\n  numBits -= 32;\n  b = 32 - numBits;\n  return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);\n};\n/**\n * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\n// LongPrototype.rotl = LongPrototype.rotateLeft;\n\n/**\n * Returns this Long with bits rotated to the right by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\n\nexport const rotateRight = function rotateRight(numBits) {\n  var b;\n  if (isLong(numBits)) numBits = numBits.toInt();\n  if ((numBits &= 63) === 0) return this;\n  if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n\n  if (numBits < 32) {\n    b = 32 - numBits;\n    return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);\n  }\n\n  numBits -= 32;\n  b = 32 - numBits;\n  return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);\n};\n/**\n * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\n// LongPrototype.rotr = LongPrototype.rotateRight;\n\n/**\n * Converts this Long to signed.\n * @this {!Long}\n * @returns {!Long} Signed long\n */\n\nexport function toSigned($this) {\n  if (!$this.unsigned) return $this;\n  return fromBits($this.low, $this.high, false);\n}\n;\n/**\n * Converts this Long to unsigned.\n * @this {!Long}\n * @returns {!Long} Unsigned long\n */\n\nexport function toUnsigned($this) {\n  if ($this.unsigned) return $this;\n  return fromBits($this.low, $this.high, true);\n}\n;\n/**\n * Converts this Long to its byte representation.\n * @param {boolean=} le Whether little or big endian, defaults to big endian\n * @this {!Long}\n * @returns {!Array.<number>} Byte representation\n */\n\nexport function toBytes($this, le) {\n  return le ? toBytesLE($this) : toBytesBE($this);\n}\n;\n/**\n * Converts this Long to its little endian byte representation.\n * @this {!Long}\n * @returns {!Array.<number>} Little endian byte representation\n */\n\nexport function toBytesLE($this) {\n  var hi = $this.high,\n      lo = $this.low;\n  return [lo & 0xff, lo >>> 8 & 0xff, lo >>> 16 & 0xff, lo >>> 24, hi & 0xff, hi >>> 8 & 0xff, hi >>> 16 & 0xff, hi >>> 24];\n}\n;\n/**\n * Converts this Long to its big endian byte representation.\n * @this {!Long}\n * @returns {!Array.<number>} Big endian byte representation\n */\n\nexport function toBytesBE($this) {\n  var hi = $this.high,\n      lo = $this.low;\n  return [hi >>> 24, hi >>> 16 & 0xff, hi >>> 8 & 0xff, hi & 0xff, lo >>> 24, lo >>> 16 & 0xff, lo >>> 8 & 0xff, lo & 0xff];\n}\n;\n/**\n * Creates a Long from its byte representation.\n * @param {!Array.<number>} bytes Byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @param {boolean=} le Whether little or big endian, defaults to big endian\n * @returns {Long} The corresponding Long value\n */\n\nexport function fromBytes(bytes, unsigned, le) {\n  return le ? fromBytesLE(bytes, unsigned) : fromBytesBE(bytes, unsigned);\n}\n;\n/**\n * Creates a Long from its little endian byte representation.\n * @param {!Array.<number>} bytes Little endian byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {Long} The corresponding Long value\n */\n\nexport function fromBytesLE(bytes, unsigned) {\n  return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);\n}\n;\n/**\n * Creates a Long from its big endian byte representation.\n * @param {!Array.<number>} bytes Big endian byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {Long} The corresponding Long value\n */\n\nexport function fromBytesBE(bytes, unsigned) {\n  return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);\n}\n;","import { isValid } from \"./Int32\";\nimport * as Long from \"../lib/long\";\nexport default Long.Long;\nexport const get_Zero = Long.ZERO;\nexport const get_One = Long.ONE;\nexport const op_Addition = Long.add;\nexport const op_Subtraction = Long.subtract;\nexport const op_Multiply = Long.multiply;\nexport const op_Division = Long.divide;\nexport const op_Modulus = Long.modulo;\nexport const op_UnaryNegation = Long.negate;\nexport const op_LeftShift = Long.shiftLeft;\nexport const op_RightShift = Long.shiftRight;\nexport const op_RightShiftUnsigned = Long.shiftRightUnsigned;\nexport const op_BitwiseAnd = Long.and;\nexport const op_BitwiseOr = Long.or;\nexport const op_ExclusiveOr = Long.xor;\nexport const op_LogicalNot = Long.not;\nexport const op_LessThan = Long.lessThan;\nexport const op_LessThanOrEqual = Long.lessThanOrEqual;\nexport const op_GreaterThan = Long.greaterThan;\nexport const op_GreaterThanOrEqual = Long.greaterThanOrEqual;\nexport const op_Equality = Long.equals;\nexport const op_Inequality = Long.notEquals;\nexport const equals = Long.equals;\nexport const compare = Long.compare;\nexport const fromInt = Long.fromInt;\nexport const fromBits = Long.fromBits;\nexport const fromBytes = Long.fromBytes;\nexport const fromNumber = Long.fromNumber;\nexport const fromString = Long.fromString;\nexport const fromValue = Long.fromValue;\nexport const toInt = Long.toInt;\nexport const toBytes = Long.toBytes;\nexport const toNumber = Long.toNumber;\nexport const toString = Long.toString;\nexport const getLowBits = Long.getLowBits;\nexport const getHighBits = Long.getHighBits;\nexport const getLowBitsUnsigned = Long.getLowBitsUnsigned;\nexport const getHighBitsUnsigned = Long.getHighBitsUnsigned;\n\nfunction getMaxValue(unsigned, radix, isNegative) {\n  switch (radix) {\n    case 2:\n      return unsigned ? \"1111111111111111111111111111111111111111111111111111111111111111\" : isNegative ? \"1000000000000000000000000000000000000000000000000000000000000000\" : \"111111111111111111111111111111111111111111111111111111111111111\";\n\n    case 8:\n      return unsigned ? \"1777777777777777777777\" : isNegative ? \"1000000000000000000000\" : \"777777777777777777777\";\n\n    case 10:\n      return unsigned ? \"18446744073709551615\" : isNegative ? \"9223372036854775808\" : \"9223372036854775807\";\n\n    case 16:\n      return unsigned ? \"FFFFFFFFFFFFFFFF\" : isNegative ? \"8000000000000000\" : \"7FFFFFFFFFFFFFFF\";\n\n    default:\n      throw new Error(\"Invalid radix.\");\n  }\n}\n\nexport function abs(x) {\n  if (!x.unsigned && Long.isNegative(x)) {\n    return op_UnaryNegation(x);\n  } else {\n    return x;\n  }\n}\nexport function fromInteger(value, unsigned, kind) {\n  let x = value;\n  let xh = 0;\n\n  switch (kind) {\n    case 0:\n      x = value << 24 >> 24;\n      xh = x;\n      break;\n\n    case 4:\n      x = value << 24 >>> 24;\n      break;\n\n    case 1:\n      x = value << 16 >> 16;\n      xh = x;\n      break;\n\n    case 5:\n      x = value << 16 >>> 16;\n      break;\n\n    case 2:\n      x = value >> 0;\n      xh = x;\n      break;\n\n    case 6:\n      x = value >>> 0;\n      break;\n  }\n\n  return Long.fromBits(x, xh >> 31, unsigned);\n}\nexport function parse(str, style, unsigned, _bitsize, radix) {\n  const res = isValid(str, style, radix);\n\n  if (res != null) {\n    const lessOrEqual = (x, y) => {\n      const len = Math.max(x.length, y.length);\n      return x.padStart(len, \"0\") <= y.padStart(len, \"0\");\n    };\n\n    const isNegative = res.sign === \"-\";\n    const maxValue = getMaxValue(unsigned || res.radix !== 10, res.radix, isNegative);\n\n    if (lessOrEqual(res.digits.toUpperCase(), maxValue)) {\n      str = isNegative ? res.sign + res.digits : res.digits;\n      return Long.fromString(str, unsigned, res.radix);\n    }\n  }\n\n  throw new Error(\"Input string was not in a correct format.\");\n}\nexport function tryParse(str, style, unsigned, bitsize) {\n  try {\n    const v = parse(str, style, unsigned, bitsize);\n    return [true, v];\n  } catch (_a) {// supress error\n  }\n\n  return [false, Long.ZERO];\n}\nexport function unixEpochMillisecondsToTicks(ms, offset) {\n  return op_Multiply(op_Addition(op_Addition(Long.fromNumber(ms), 62135596800000), offset), 10000);\n}\nexport function ticksToUnixEpochMilliseconds(ticks) {\n  return Long.toNumber(op_Subtraction(op_Division(ticks, 10000), 62135596800000));\n}\nexport function makeRangeStepFunction(step, last, unsigned) {\n  const stepComparedWithZero = Long.compare(step, unsigned ? Long.UZERO : Long.ZERO);\n\n  if (stepComparedWithZero === 0) {\n    throw new Error(\"The step of a range cannot be zero\");\n  }\n\n  const stepGreaterThanZero = stepComparedWithZero > 0;\n  return x => {\n    const comparedWithLast = Long.compare(x, last);\n\n    if (stepGreaterThanZero && comparedWithLast <= 0 || !stepGreaterThanZero && comparedWithLast >= 0) {\n      return [x, op_Addition(x, step)];\n    } else {\n      return null;\n    }\n  };\n}","import { makeRangeStepFunction as makeDecimalRangeStepFunction } from \"./Decimal\";\nimport { makeRangeStepFunction as makeLongRangeStepFunction } from \"./Long\";\nimport { some, value } from \"./Option\";\nimport { compare, equals } from \"./Util\";\nexport class Enumerator {\n  constructor(iter) {\n    this.iter = iter;\n  }\n\n  MoveNext() {\n    const cur = this.iter.next();\n    this.current = cur.value;\n    return !cur.done;\n  }\n\n  get Current() {\n    return this.current;\n  }\n\n  Reset() {\n    throw new Error(\"JS iterators cannot be reset\");\n  }\n\n  Dispose() {\n    return;\n  }\n\n}\nexport function getEnumerator(o) {\n  return new Enumerator(o[Symbol.iterator]());\n}\nexport function toIterator(en) {\n  return {\n    next() {\n      return en.MoveNext() ? {\n        done: false,\n        value: en.Current\n      } : {\n        done: true,\n        value: null\n      };\n    }\n\n  };\n} // export function toIterable<T>(en: IEnumerable<T>): Iterable<T> {\n//   return {\n//     [Symbol.iterator]() {\n//       return toIterator(en.GetEnumerator());\n//     },\n//   };\n// }\n\nfunction __failIfNone(res) {\n  if (res == null) {\n    throw new Error(\"Seq did not contain any matching element\");\n  }\n\n  return value(res);\n}\n\nexport function ofArray(xs) {\n  return delay(() => unfold(i => i != null && i < xs.length ? [xs[i], i + 1] : null, 0));\n}\nexport function allPairs(xs, ys) {\n  let firstEl = true;\n  const ysCache = [];\n  return collect(x => {\n    if (firstEl) {\n      firstEl = false;\n      return map(y => {\n        ysCache.push(y);\n        return [x, y];\n      }, ys);\n    } else {\n      return ysCache.map(y => [x, y]); // return map(function (i) {\n      //     return [x, ysCache[i]];\n      // }, rangeNumber(0, 1, ysCache.length - 1));\n    }\n  }, xs);\n}\nexport function append(xs, ys) {\n  return delay(() => {\n    let firstDone = false;\n    const i = xs[Symbol.iterator]();\n    let iters = [i, null];\n    return unfold(() => {\n      var _a, _b;\n\n      let cur;\n\n      if (!firstDone) {\n        cur = (_a = iters[0]) === null || _a === void 0 ? void 0 : _a.next();\n\n        if (cur != null && !cur.done) {\n          return [cur.value, iters];\n        } else {\n          firstDone = true;\n          iters = [null, ys[Symbol.iterator]()];\n        }\n      }\n\n      cur = (_b = iters[1]) === null || _b === void 0 ? void 0 : _b.next();\n      return cur != null && !cur.done ? [cur.value, iters] : null;\n    }, iters);\n  });\n}\nexport function average(xs, averager) {\n  let count = 0;\n  const total = fold((acc, x) => {\n    count++;\n    return averager.Add(acc, x);\n  }, averager.GetZero(), xs);\n  return averager.DivideByInt(total, count);\n}\nexport function averageBy(f, xs, averager) {\n  let count = 0;\n  const total = fold((acc, x) => {\n    count++;\n    return averager.Add(acc, f(x));\n  }, averager.GetZero(), xs);\n  return averager.DivideByInt(total, count);\n}\nexport function concat(xs) {\n  return delay(() => {\n    const iter = xs[Symbol.iterator]();\n    let output = {\n      value: null\n    };\n    return unfold(innerIter => {\n      let hasFinished = false;\n\n      while (!hasFinished) {\n        if (innerIter == null) {\n          const cur = iter.next();\n\n          if (!cur.done) {\n            innerIter = cur.value[Symbol.iterator]();\n          } else {\n            hasFinished = true;\n          }\n        } else {\n          const cur = innerIter.next();\n\n          if (!cur.done) {\n            output = {\n              value: cur.value\n            };\n            hasFinished = true;\n          } else {\n            innerIter = null;\n          }\n        }\n      }\n\n      return innerIter != null && output != null ? [output.value, innerIter] : null;\n    }, null);\n  });\n}\nexport function collect(f, xs) {\n  return concat(map(f, xs));\n}\nexport function choose(f, xs) {\n  return delay(() => unfold(iter => {\n    let cur = iter.next();\n\n    while (!cur.done) {\n      const y = f(cur.value);\n\n      if (y != null) {\n        return [value(y), iter];\n      }\n\n      cur = iter.next();\n    }\n\n    return null;\n  }, xs[Symbol.iterator]()));\n}\nexport function compareWith(f, xs, ys) {\n  const nonZero = tryFind(i => i !== 0, map2((x, y) => f(x, y), xs, ys));\n  return nonZero != null ? value(nonZero) : length(xs) - length(ys);\n}\nexport function delay(f) {\n  return {\n    [Symbol.iterator]: () => f()[Symbol.iterator]()\n  };\n}\nexport function empty() {\n  return unfold(() => null, undefined);\n}\nexport function enumerateFromFunctions(factory, moveNext, current) {\n  return delay(() => unfold(e => moveNext(e) ? [current(e), e] : null, factory()));\n}\nexport function enumerateWhile(cond, xs) {\n  return concat(unfold(() => cond() ? [xs, true] : null, undefined));\n}\nexport function enumerateThenFinally(xs, finalFn) {\n  return delay(() => {\n    let iter;\n\n    try {\n      iter = xs[Symbol.iterator]();\n    } catch (err) {\n      return empty();\n    } finally {\n      finalFn();\n    }\n\n    return unfold(it => {\n      try {\n        const cur = it.next();\n        return !cur.done ? [cur.value, it] : null;\n      } catch (err) {\n        return null;\n      } finally {\n        finalFn();\n      }\n    }, iter);\n  });\n}\nexport function enumerateUsing(disp, work) {\n  let isDisposed = false;\n\n  const disposeOnce = () => {\n    if (!isDisposed) {\n      isDisposed = true;\n      disp.Dispose();\n    }\n  };\n\n  try {\n    return enumerateThenFinally(work(disp), disposeOnce);\n  } catch (err) {\n    return void 0;\n  } finally {\n    disposeOnce();\n  }\n}\nexport function exactlyOne(xs) {\n  const iter = xs[Symbol.iterator]();\n  const fst = iter.next();\n\n  if (fst.done) {\n    throw new Error(\"Seq was empty\");\n  }\n\n  const snd = iter.next();\n\n  if (!snd.done) {\n    throw new Error(\"Seq had multiple items\");\n  }\n\n  return fst.value;\n}\nexport function except(itemsToExclude, source) {\n  const exclusionItems = Array.from(itemsToExclude);\n\n  const testIsNotInExclusionItems = element => !exclusionItems.some(excludedItem => equals(excludedItem, element));\n\n  return filter(testIsNotInExclusionItems, source);\n}\nexport function exists(f, xs) {\n  let cur;\n\n  for (const iter = xs[Symbol.iterator]();;) {\n    cur = iter.next();\n\n    if (cur.done) {\n      break;\n    }\n\n    if (f(cur.value)) {\n      return true;\n    }\n  }\n\n  return false;\n}\nexport function exists2(f, xs, ys) {\n  let cur1;\n  let cur2;\n\n  for (const iter1 = xs[Symbol.iterator](), iter2 = ys[Symbol.iterator]();;) {\n    cur1 = iter1.next();\n    cur2 = iter2.next();\n\n    if (cur1.done || cur2.done) {\n      break;\n    }\n\n    if (f(cur1.value, cur2.value)) {\n      return true;\n    }\n  }\n\n  return false;\n}\nexport function forAll(f, xs) {\n  return !exists(x => !f(x), xs);\n}\nexport function forAll2(f, xs, ys) {\n  return !exists2((x, y) => !f(x, y), xs, ys);\n}\nexport function contains(i, xs) {\n  return exists(x => equals(x, i), xs);\n}\nexport function filter(f, xs) {\n  return delay(() => unfold(iter => {\n    let cur = iter.next();\n\n    while (!cur.done) {\n      if (f(cur.value)) {\n        return [cur.value, iter];\n      }\n\n      cur = iter.next();\n    }\n\n    return null;\n  }, xs[Symbol.iterator]()));\n}\nexport function where(f, xs) {\n  return filter(f, xs);\n}\nexport function fold(f, acc, xs) {\n  if (Array.isArray(xs) || ArrayBuffer.isView(xs)) {\n    return xs.reduce(f, acc);\n  } else {\n    let cur;\n\n    for (let i = 0, iter = xs[Symbol.iterator]();; i++) {\n      cur = iter.next();\n\n      if (cur.done) {\n        break;\n      }\n\n      acc = f(acc, cur.value, i);\n    }\n\n    return acc;\n  }\n}\nexport function foldBack(f, xs, acc) {\n  const arr = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs : Array.from(xs);\n\n  for (let i = arr.length - 1; i >= 0; i--) {\n    acc = f(arr[i], acc, i);\n  }\n\n  return acc;\n}\nexport function fold2(f, acc, xs, ys) {\n  const iter1 = xs[Symbol.iterator]();\n  const iter2 = ys[Symbol.iterator]();\n  let cur1;\n  let cur2;\n\n  for (let i = 0;; i++) {\n    cur1 = iter1.next();\n    cur2 = iter2.next();\n\n    if (cur1.done || cur2.done) {\n      break;\n    }\n\n    acc = f(acc, cur1.value, cur2.value, i);\n  }\n\n  return acc;\n}\nexport function foldBack2(f, xs, ys, acc) {\n  const ar1 = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs : Array.from(xs);\n  const ar2 = Array.isArray(ys) || ArrayBuffer.isView(ys) ? ys : Array.from(ys);\n\n  for (let i = ar1.length - 1; i >= 0; i--) {\n    acc = f(ar1[i], ar2[i], acc, i);\n  }\n\n  return acc;\n}\nexport function tryHead(xs) {\n  const iter = xs[Symbol.iterator]();\n  const cur = iter.next();\n  return cur.done ? null : some(cur.value);\n}\nexport function head(xs) {\n  return __failIfNone(tryHead(xs));\n}\nexport function initialize(n, f) {\n  return delay(() => unfold(i => i < n ? [f(i), i + 1] : null, 0));\n}\nexport function initializeInfinite(f) {\n  return delay(() => unfold(i => [f(i), i + 1], 0));\n}\nexport function tryItem(i, xs) {\n  if (i < 0) {\n    return null;\n  }\n\n  if (Array.isArray(xs) || ArrayBuffer.isView(xs)) {\n    return i < xs.length ? some(xs[i]) : null;\n  }\n\n  for (let j = 0, iter = xs[Symbol.iterator]();; j++) {\n    const cur = iter.next();\n\n    if (cur.done) {\n      break;\n    }\n\n    if (j === i) {\n      return some(cur.value);\n    }\n  }\n\n  return null;\n}\nexport function item(i, xs) {\n  return __failIfNone(tryItem(i, xs));\n}\nexport function iterate(f, xs) {\n  fold((_, x) => (f(x), null), null, xs);\n}\nexport function iterate2(f, xs, ys) {\n  fold2((_, x, y) => (f(x, y), null), null, xs, ys);\n}\nexport function iterateIndexed(f, xs) {\n  fold((_, x, i) => (f(i !== null && i !== void 0 ? i : 0, x), null), null, xs);\n}\nexport function iterateIndexed2(f, xs, ys) {\n  fold2((_, x, y, i) => (f(i !== null && i !== void 0 ? i : 0, x, y), null), null, xs, ys);\n}\nexport function isEmpty(xs) {\n  const i = xs[Symbol.iterator]();\n  return i.next().done;\n}\nexport function tryLast(xs) {\n  return isEmpty(xs) ? null : some(reduce((_, x) => x, xs));\n}\nexport function last(xs) {\n  return __failIfNone(tryLast(xs));\n}\nexport function length(xs) {\n  return Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs.length : fold((acc, _x) => acc + 1, 0, xs);\n}\nexport function map(f, xs) {\n  return delay(() => unfold(iter => {\n    const cur = iter.next();\n    return !cur.done ? [f(cur.value), iter] : null;\n  }, xs[Symbol.iterator]()));\n}\nexport function mapIndexed(f, xs) {\n  return delay(() => {\n    let i = 0;\n    return unfold(iter => {\n      const cur = iter.next();\n      return !cur.done ? [f(i++, cur.value), iter] : null;\n    }, xs[Symbol.iterator]());\n  });\n}\nexport function indexed(xs) {\n  return mapIndexed((i, x) => [i, x], xs);\n}\nexport function map2(f, xs, ys) {\n  return delay(() => {\n    const iter1 = xs[Symbol.iterator]();\n    const iter2 = ys[Symbol.iterator]();\n    return unfold(() => {\n      const cur1 = iter1.next();\n      const cur2 = iter2.next();\n      return !cur1.done && !cur2.done ? [f(cur1.value, cur2.value), null] : null;\n    }, undefined);\n  });\n}\nexport function mapIndexed2(f, xs, ys) {\n  return delay(() => {\n    let i = 0;\n    const iter1 = xs[Symbol.iterator]();\n    const iter2 = ys[Symbol.iterator]();\n    return unfold(() => {\n      const cur1 = iter1.next();\n      const cur2 = iter2.next();\n      return !cur1.done && !cur2.done ? [f(i++, cur1.value, cur2.value), null] : null;\n    }, undefined);\n  });\n}\nexport function map3(f, xs, ys, zs) {\n  return delay(() => {\n    const iter1 = xs[Symbol.iterator]();\n    const iter2 = ys[Symbol.iterator]();\n    const iter3 = zs[Symbol.iterator]();\n    return unfold(() => {\n      const cur1 = iter1.next();\n      const cur2 = iter2.next();\n      const cur3 = iter3.next();\n      return !cur1.done && !cur2.done && !cur3.done ? [f(cur1.value, cur2.value, cur3.value), null] : null;\n    }, undefined);\n  });\n}\nexport function mapFold(f, acc, xs, transform) {\n  const result = [];\n  let r;\n  let cur;\n\n  for (let i = 0, iter = xs[Symbol.iterator]();; i++) {\n    cur = iter.next();\n\n    if (cur.done) {\n      break;\n    }\n\n    [r, acc] = f(acc, cur.value);\n    result.push(r);\n  }\n\n  return transform !== void 0 ? [transform(result), acc] : [result, acc];\n}\nexport function mapFoldBack(f, xs, acc, transform) {\n  const arr = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs : Array.from(xs);\n  const result = [];\n  let r;\n\n  for (let i = arr.length - 1; i >= 0; i--) {\n    [r, acc] = f(arr[i], acc);\n    result.push(r);\n  }\n\n  return transform !== void 0 ? [transform(result), acc] : [result, acc];\n}\nexport function max(xs, comparer) {\n  const compareFn = comparer != null ? comparer.Compare : compare;\n  return reduce((acc, x) => compareFn(acc, x) === 1 ? acc : x, xs);\n}\nexport function maxBy(f, xs, comparer) {\n  const compareFn = comparer != null ? comparer.Compare : compare;\n  return reduce((acc, x) => compareFn(f(acc), f(x)) === 1 ? acc : x, xs);\n}\nexport function min(xs, comparer) {\n  const compareFn = comparer != null ? comparer.Compare : compare;\n  return reduce((acc, x) => compareFn(acc, x) === -1 ? acc : x, xs);\n}\nexport function minBy(f, xs, comparer) {\n  const compareFn = comparer != null ? comparer.Compare : compare;\n  return reduce((acc, x) => compareFn(f(acc), f(x)) === -1 ? acc : x, xs);\n}\nexport function pairwise(xs) {\n  const res = Array.from(scan((last, next) => [last[1], next], [0, 0], xs));\n  return res.length < 2 ? [] : skip(2, res);\n}\nexport function rangeChar(first, last) {\n  return delay(() => unfold(x => x <= last ? [x, String.fromCharCode(x.charCodeAt(0) + 1)] : null, first));\n}\nexport function rangeLong(first, step, last, unsigned) {\n  const stepFn = makeLongRangeStepFunction(step, last, unsigned);\n  return delay(() => unfold(stepFn, first));\n}\nexport function rangeDecimal(first, step, last) {\n  const stepFn = makeDecimalRangeStepFunction(step, last);\n  return delay(() => unfold(stepFn, first));\n}\nexport function rangeNumber(first, step, last) {\n  if (step === 0) {\n    throw new Error(\"Step cannot be 0\");\n  }\n\n  return delay(() => unfold(x => step > 0 && x <= last || step < 0 && x >= last ? [x, x + step] : null, first));\n}\nexport function readOnly(xs) {\n  return map(x => x, xs);\n}\nexport function reduce(f, xs) {\n  if (Array.isArray(xs) || ArrayBuffer.isView(xs)) {\n    return xs.reduce(f);\n  }\n\n  const iter = xs[Symbol.iterator]();\n  let cur = iter.next();\n\n  if (cur.done) {\n    throw new Error(\"Seq was empty\");\n  }\n\n  let acc = cur.value;\n\n  while (true) {\n    cur = iter.next();\n\n    if (cur.done) {\n      break;\n    }\n\n    acc = f(acc, cur.value);\n  }\n\n  return acc;\n}\nexport function reduceBack(f, xs) {\n  const ar = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs : Array.from(xs);\n\n  if (ar.length === 0) {\n    throw new Error(\"Seq was empty\");\n  }\n\n  let acc = ar[ar.length - 1];\n\n  for (let i = ar.length - 2; i >= 0; i--) {\n    acc = f(ar[i], acc, i);\n  }\n\n  return acc;\n}\nexport function replicate(n, x) {\n  return initialize(n, () => x);\n}\nexport function reverse(xs) {\n  const ar = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs.slice(0) : Array.from(xs);\n  return ofArray(ar.reverse());\n}\nexport function scan(f, seed, xs) {\n  return delay(() => {\n    const iter = xs[Symbol.iterator]();\n    return unfold(acc => {\n      if (acc == null) {\n        return [seed, seed];\n      }\n\n      const cur = iter.next();\n\n      if (!cur.done) {\n        acc = f(acc, cur.value);\n        return [acc, acc];\n      }\n\n      return null;\n    }, null);\n  });\n}\nexport function scanBack(f, xs, seed) {\n  return reverse(scan((acc, x) => f(x, acc), seed, reverse(xs)));\n}\nexport function singleton(y) {\n  return [y];\n}\nexport function skip(n, xs) {\n  return {\n    [Symbol.iterator]: () => {\n      const iter = xs[Symbol.iterator]();\n\n      for (let i = 1; i <= n; i++) {\n        if (iter.next().done) {\n          throw new Error(\"Seq has not enough elements\");\n        }\n      }\n\n      return iter;\n    }\n  };\n}\nexport function skipWhile(f, xs) {\n  return delay(() => {\n    let hasPassed = false;\n    return filter(x => hasPassed || (hasPassed = !f(x)), xs);\n  });\n}\nexport function sortWith(f, xs) {\n  const ys = Array.from(xs);\n  return ofArray(ys.sort(f));\n}\nexport function sum(xs, adder) {\n  return fold((acc, x) => adder.Add(acc, x), adder.GetZero(), xs);\n}\nexport function sumBy(f, xs, adder) {\n  return fold((acc, x) => adder.Add(acc, f(x)), adder.GetZero(), xs);\n}\nexport function tail(xs) {\n  const iter = xs[Symbol.iterator]();\n  const cur = iter.next();\n\n  if (cur.done) {\n    throw new Error(\"Seq was empty\");\n  }\n\n  return {\n    [Symbol.iterator]: () => iter\n  };\n}\nexport function take(n, xs, truncate = false) {\n  return delay(() => {\n    const iter = xs[Symbol.iterator]();\n    return unfold(i => {\n      if (i < n) {\n        const cur = iter.next();\n\n        if (!cur.done) {\n          return [cur.value, i + 1];\n        }\n\n        if (!truncate) {\n          throw new Error(\"Seq has not enough elements\");\n        }\n      }\n\n      return null;\n    }, 0);\n  });\n}\nexport function truncate(n, xs) {\n  return take(n, xs, true);\n}\nexport function takeWhile(f, xs) {\n  return delay(() => {\n    const iter = xs[Symbol.iterator]();\n    return unfold(() => {\n      const cur = iter.next();\n\n      if (!cur.done && f(cur.value)) {\n        return [cur.value, null];\n      }\n\n      return null;\n    }, 0);\n  });\n}\nexport function tryFind(f, xs, defaultValue) {\n  for (let i = 0, iter = xs[Symbol.iterator]();; i++) {\n    const cur = iter.next();\n\n    if (cur.done) {\n      break;\n    }\n\n    if (f(cur.value, i)) {\n      return some(cur.value);\n    }\n  }\n\n  return defaultValue === void 0 ? null : some(defaultValue);\n}\nexport function find(f, xs) {\n  return __failIfNone(tryFind(f, xs));\n}\nexport function tryFindBack(f, xs, defaultValue) {\n  const arr = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs.slice(0) : Array.from(xs);\n  return tryFind(f, arr.reverse(), defaultValue);\n}\nexport function findBack(f, xs) {\n  return __failIfNone(tryFindBack(f, xs));\n}\nexport function tryFindIndex(f, xs) {\n  for (let i = 0, iter = xs[Symbol.iterator]();; i++) {\n    const cur = iter.next();\n\n    if (cur.done) {\n      break;\n    }\n\n    if (f(cur.value, i)) {\n      return i;\n    }\n  }\n\n  return null;\n}\nexport function findIndex(f, xs) {\n  return __failIfNone(tryFindIndex(f, xs));\n}\nexport function tryFindIndexBack(f, xs) {\n  const arr = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs.slice(0) : Array.from(xs);\n\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (f(arr[i], i)) {\n      return i;\n    }\n  }\n\n  return null;\n}\nexport function findIndexBack(f, xs) {\n  return __failIfNone(tryFindIndexBack(f, xs));\n}\nexport function tryPick(f, xs) {\n  for (let i = 0, iter = xs[Symbol.iterator]();; i++) {\n    const cur = iter.next();\n\n    if (cur.done) {\n      break;\n    }\n\n    const y = f(cur.value, i);\n\n    if (y != null) {\n      return y;\n    }\n  }\n\n  return null;\n}\nexport function pick(f, xs) {\n  return __failIfNone(tryPick(f, xs));\n}\nexport function unfold(f, fst) {\n  return {\n    [Symbol.iterator]: () => {\n      // Capture a copy of the first value in the closure\n      // so the sequence is restarted every time, see #1230\n      let acc = fst;\n      const iter = {\n        next: () => {\n          const res = f(acc);\n\n          if (res != null) {\n            const v = value(res);\n\n            if (v != null) {\n              acc = v[1];\n              return {\n                done: false,\n                value: v[0]\n              };\n            }\n          }\n\n          return {\n            done: true,\n            value: undefined\n          };\n        }\n      };\n      return iter;\n    }\n  };\n}\nexport function zip(xs, ys) {\n  return map2((x, y) => [x, y], xs, ys);\n}\nexport function zip3(xs, ys, zs) {\n  return map3((x, y, z) => [x, y, z], xs, ys, zs);\n}\nexport function windowed(windowSize, source) {\n  if (windowSize <= 0) {\n    throw new Error(\"windowSize must be positive\");\n  }\n\n  return {\n    [Symbol.iterator]: () => {\n      let window = [];\n      const iter = source[Symbol.iterator]();\n      const iter2 = {\n        next: () => {\n          let cur;\n\n          while (window.length < windowSize) {\n            if ((cur = iter.next()).done) {\n              return {\n                done: true,\n                value: undefined\n              };\n            }\n\n            window.push(cur.value);\n          }\n\n          const value = window;\n          window = window.slice(1);\n          return {\n            done: false,\n            value\n          };\n        }\n      };\n      return iter2;\n    }\n  };\n}\nexport function transpose(source) {\n  return {\n    [Symbol.iterator]: () => {\n      const iters = Array.from(source, x => x[Symbol.iterator]());\n      const iter = {\n        next: () => {\n          if (iters.length === 0) {\n            return {\n              done: true,\n              value: undefined\n            }; // empty sequence\n          }\n\n          const results = Array.from(iters, iter => iter.next());\n\n          if (results[0].done) {\n            if (!results.every(x => x.done)) {\n              throw new Error(\"Sequences have different lengths\");\n            }\n\n            return {\n              done: true,\n              value: undefined\n            };\n          } else {\n            if (!results.every(x => !x.done)) {\n              throw new Error(\"Sequences have different lengths\");\n            }\n\n            const values = results.map(x => x.value);\n            return {\n              done: false,\n              value: values\n            };\n          }\n        }\n      };\n      return iter;\n    }\n  };\n}","import { toString as dateToString } from \"./Date\";\nimport Decimal from \"./Decimal\";\nimport Long, * as _Long from \"./Long\";\nimport { escape } from \"./RegExp\";\nconst fsFormatRegExp = /(^|[^%])%([0+\\- ]*)(\\d+)?(?:\\.(\\d+))?(\\w)/;\nconst formatRegExp = /\\{(\\d+)(,-?\\d+)?(?:\\:([a-zA-Z])(\\d{0,2})|\\:(.+?))?\\}/g; // RFC 4122 compliant. From https://stackoverflow.com/a/13653180/3922220\n// const guidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/;\n// Relax GUID parsing, see #1637\n\nconst guidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/; // These are used for formatting and only take longs and decimals into account (no bigint)\n\nfunction isNumeric(x) {\n  return typeof x === \"number\" || x instanceof Long || x instanceof Decimal;\n}\n\nfunction isLessThan(x, y) {\n  if (x instanceof Long) {\n    return _Long.compare(x, y) < 0;\n  } else if (x instanceof Decimal) {\n    return x.cmp(y) < 0;\n  } else {\n    return x < y;\n  }\n}\n\nfunction multiply(x, y) {\n  if (x instanceof Long) {\n    return _Long.op_Multiply(x, y);\n  } else if (x instanceof Decimal) {\n    return x.mul(y);\n  } else {\n    return x * y;\n  }\n}\n\nfunction toFixed(x, dp) {\n  if (x instanceof Long) {\n    return String(x) + 0 .toFixed(dp).substr(1);\n  } else {\n    return x.toFixed(dp);\n  }\n}\n\nfunction toPrecision(x, sd) {\n  if (x instanceof Long) {\n    return String(x) + 0 .toPrecision(sd).substr(1);\n  } else {\n    return x.toPrecision(sd);\n  }\n}\n\nfunction toExponential(x, dp) {\n  if (x instanceof Long) {\n    return String(x) + 0 .toExponential(dp).substr(1);\n  } else {\n    return x.toExponential(dp);\n  }\n}\n\nfunction cmp(x, y, ic) {\n  function isIgnoreCase(i) {\n    return i === true || i === 1\n    /* CurrentCultureIgnoreCase */\n    || i === 3\n    /* InvariantCultureIgnoreCase */\n    || i === 5\n    /* OrdinalIgnoreCase */\n    ;\n  }\n\n  function isOrdinal(i) {\n    return i === 4\n    /* Ordinal */\n    || i === 5\n    /* OrdinalIgnoreCase */\n    ;\n  }\n\n  if (x == null) {\n    return y == null ? 0 : -1;\n  }\n\n  if (y == null) {\n    return 1;\n  } // everything is bigger than null\n\n\n  if (isOrdinal(ic)) {\n    if (isIgnoreCase(ic)) {\n      x = x.toLowerCase();\n      y = y.toLowerCase();\n    }\n\n    return x === y ? 0 : x < y ? -1 : 1;\n  } else {\n    if (isIgnoreCase(ic)) {\n      x = x.toLocaleLowerCase();\n      y = y.toLocaleLowerCase();\n    }\n\n    return x.localeCompare(y);\n  }\n}\n\nexport function compare(...args) {\n  switch (args.length) {\n    case 2:\n      return cmp(args[0], args[1], false);\n\n    case 3:\n      return cmp(args[0], args[1], args[2]);\n\n    case 4:\n      return cmp(args[0], args[1], args[2] === true);\n\n    case 5:\n      return cmp(args[0].substr(args[1], args[4]), args[2].substr(args[3], args[4]), false);\n\n    case 6:\n      return cmp(args[0].substr(args[1], args[4]), args[2].substr(args[3], args[4]), args[5]);\n\n    case 7:\n      return cmp(args[0].substr(args[1], args[4]), args[2].substr(args[3], args[4]), args[5] === true);\n\n    default:\n      throw new Error(\"String.compare: Unsupported number of parameters\");\n  }\n}\nexport function compareOrdinal(x, y) {\n  return cmp(x, y, 4\n  /* Ordinal */\n  );\n}\nexport function compareTo(x, y) {\n  return cmp(x, y, 0\n  /* CurrentCulture */\n  );\n}\nexport function startsWith(str, pattern, ic) {\n  if (str.length >= pattern.length) {\n    return cmp(str.substr(0, pattern.length), pattern, ic) === 0;\n  }\n\n  return false;\n}\nexport function indexOfAny(str, anyOf, ...args) {\n  if (str == null || str === \"\") {\n    return -1;\n  }\n\n  const startIndex = args.length > 0 ? args[0] : 0;\n\n  if (startIndex < 0) {\n    throw new Error(\"Start index cannot be negative\");\n  }\n\n  const length = args.length > 1 ? args[1] : str.length - startIndex;\n\n  if (length < 0) {\n    throw new Error(\"Length cannot be negative\");\n  }\n\n  if (length > str.length - startIndex) {\n    throw new Error(\"Invalid startIndex and length\");\n  }\n\n  str = str.substr(startIndex, length);\n\n  for (const c of anyOf) {\n    const index = str.indexOf(c);\n\n    if (index > -1) {\n      return index + startIndex;\n    }\n  }\n\n  return -1;\n}\n\nfunction toHex(x) {\n  if (x instanceof Long) {\n    return _Long.toString(x.unsigned ? x : _Long.fromBytes(_Long.toBytes(x), true), 16);\n  } else {\n    return (Number(x) >>> 0).toString(16);\n  }\n}\n\nexport function printf(input) {\n  return {\n    input,\n    cont: fsFormat(input)\n  };\n}\nexport function toConsole(arg) {\n  // Don't remove the lambda here, see #1357\n  return arg.cont(x => {\n    console.log(x);\n  });\n}\nexport function toConsoleError(arg) {\n  return arg.cont(x => {\n    console.error(x);\n  });\n}\nexport function toText(arg) {\n  return arg.cont(x => x);\n}\nexport function toFail(arg) {\n  return arg.cont(x => {\n    throw new Error(x);\n  });\n}\n\nfunction formatOnce(str2, rep) {\n  return str2.replace(fsFormatRegExp, (_, prefix, flags, padLength, precision, format) => {\n    let sign = \"\";\n\n    if (isNumeric(rep)) {\n      if (format.toLowerCase() !== \"x\") {\n        if (isLessThan(rep, 0)) {\n          rep = multiply(rep, -1);\n          sign = \"-\";\n        } else {\n          if (flags.indexOf(\" \") >= 0) {\n            sign = \" \";\n          } else if (flags.indexOf(\"+\") >= 0) {\n            sign = \"+\";\n          }\n        }\n      }\n\n      precision = precision == null ? null : parseInt(precision, 10);\n\n      switch (format) {\n        case \"f\":\n        case \"F\":\n          precision = precision != null ? precision : 6;\n          rep = toFixed(rep, precision);\n          break;\n\n        case \"g\":\n        case \"G\":\n          rep = precision != null ? toPrecision(rep, precision) : toPrecision(rep);\n          break;\n\n        case \"e\":\n        case \"E\":\n          rep = precision != null ? toExponential(rep, precision) : toExponential(rep);\n          break;\n\n        case \"x\":\n          rep = toHex(rep);\n          break;\n\n        case \"X\":\n          rep = toHex(rep).toUpperCase();\n          break;\n\n        default:\n          // AOid\n          rep = String(rep);\n          break;\n      }\n    }\n\n    padLength = parseInt(padLength, 10);\n\n    if (!isNaN(padLength)) {\n      const zeroFlag = flags.indexOf(\"0\") >= 0; // Use '0' for left padding\n\n      const minusFlag = flags.indexOf(\"-\") >= 0; // Right padding\n\n      const ch = minusFlag || !zeroFlag ? \" \" : \"0\";\n\n      if (ch === \"0\") {\n        rep = padLeft(rep, padLength - sign.length, ch, minusFlag);\n        rep = sign + rep;\n      } else {\n        rep = padLeft(sign + rep, padLength, ch, minusFlag);\n      }\n    } else {\n      rep = sign + rep;\n    }\n\n    const once = prefix + rep;\n    return once.replace(/%/g, \"%%\");\n  });\n}\n\nfunction createPrinter(str, cont) {\n  return (...args) => {\n    // Make a copy as the function may be used several times\n    let strCopy = str;\n\n    for (const arg of args) {\n      strCopy = formatOnce(strCopy, arg);\n    }\n\n    return fsFormatRegExp.test(strCopy) ? createPrinter(strCopy, cont) : cont(strCopy.replace(/%%/g, \"%\"));\n  };\n}\n\nexport function fsFormat(str) {\n  return cont => {\n    return fsFormatRegExp.test(str) ? createPrinter(str, cont) : cont(str);\n  };\n}\nexport function format(str, ...args) {\n  if (typeof str === \"object\" && args.length > 0) {\n    // Called with culture info\n    str = args[0];\n    args.shift();\n  }\n\n  return str.replace(formatRegExp, (_, idx, padLength, format, precision, pattern) => {\n    let rep = args[idx];\n\n    if (isNumeric(rep)) {\n      precision = precision == null ? null : parseInt(precision, 10);\n\n      switch (format) {\n        case \"f\":\n        case \"F\":\n          precision = precision != null ? precision : 2;\n          rep = toFixed(rep, precision);\n          break;\n\n        case \"g\":\n        case \"G\":\n          rep = precision != null ? toPrecision(rep, precision) : toPrecision(rep);\n          break;\n\n        case \"e\":\n        case \"E\":\n          rep = precision != null ? toExponential(rep, precision) : toExponential(rep);\n          break;\n\n        case \"p\":\n        case \"P\":\n          precision = precision != null ? precision : 2;\n          rep = toFixed(multiply(rep, 100), precision) + \" %\";\n          break;\n\n        case \"d\":\n        case \"D\":\n          rep = precision != null ? padLeft(String(rep), precision, \"0\") : String(rep);\n          break;\n\n        case \"x\":\n        case \"X\":\n          rep = precision != null ? padLeft(toHex(rep), precision, \"0\") : toHex(rep);\n\n          if (format === \"X\") {\n            rep = rep.toUpperCase();\n          }\n\n          break;\n\n        default:\n          if (pattern) {\n            let sign = \"\";\n            rep = pattern.replace(/(0+)(\\.0+)?/, (_, intPart, decimalPart) => {\n              if (isLessThan(rep, 0)) {\n                rep = multiply(rep, -1);\n                sign = \"-\";\n              }\n\n              rep = toFixed(rep, decimalPart != null ? decimalPart.length - 1 : 0);\n              return padLeft(rep, (intPart || \"\").length - sign.length + (decimalPart != null ? decimalPart.length : 0), \"0\");\n            });\n            rep = sign + rep;\n          }\n\n      }\n    } else if (rep instanceof Date) {\n      rep = dateToString(rep, pattern || format);\n    }\n\n    padLength = parseInt((padLength || \" \").substring(1), 10);\n\n    if (!isNaN(padLength)) {\n      rep = padLeft(String(rep), Math.abs(padLength), \" \", padLength < 0);\n    }\n\n    return rep;\n  });\n}\nexport function endsWith(str, search) {\n  const idx = str.lastIndexOf(search);\n  return idx >= 0 && idx === str.length - search.length;\n}\nexport function initialize(n, f) {\n  if (n < 0) {\n    throw new Error(\"String length must be non-negative\");\n  }\n\n  const xs = new Array(n);\n\n  for (let i = 0; i < n; i++) {\n    xs[i] = f(i);\n  }\n\n  return xs.join(\"\");\n}\nexport function insert(str, startIndex, value) {\n  if (startIndex < 0 || startIndex > str.length) {\n    throw new Error(\"startIndex is negative or greater than the length of this instance.\");\n  }\n\n  return str.substring(0, startIndex) + value + str.substring(startIndex);\n}\nexport function isNullOrEmpty(str) {\n  return typeof str !== \"string\" || str.length === 0;\n}\nexport function isNullOrWhiteSpace(str) {\n  return typeof str !== \"string\" || /^\\s*$/.test(str);\n}\nexport function concat(...xs) {\n  return xs.map(x => String(x)).join(\"\");\n}\nexport function join(delimiter, xs) {\n  if (Array.isArray(xs)) {\n    return xs.join(delimiter);\n  } else {\n    return Array.from(xs).join(delimiter);\n  }\n}\nexport function joinWithIndices(delimiter, xs, startIndex, count) {\n  const endIndexPlusOne = startIndex + count;\n\n  if (endIndexPlusOne > xs.length) {\n    throw new Error(\"Index and count must refer to a location within the buffer.\");\n  }\n\n  return xs.slice(startIndex, endIndexPlusOne).join(delimiter);\n}\n/** Validates UUID as specified in RFC4122 (versions 1-5). Trims braces. */\n\nexport function validateGuid(str, doNotThrow) {\n  const trimmedAndLowered = trim(str, \"{\", \"}\").toLowerCase();\n\n  if (guidRegex.test(trimmedAndLowered)) {\n    return doNotThrow ? [true, trimmedAndLowered] : trimmedAndLowered;\n  } else if (doNotThrow) {\n    return [false, \"00000000-0000-0000-0000-000000000000\"];\n  }\n\n  throw new Error(\"Guid should contain 32 digits with 4 dashes: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\");\n} // From https://gist.github.com/LeverOne/1308368\n\nexport function newGuid() {\n  let b = \"\";\n\n  for (let a = 0; a++ < 36;) {\n    b += a * 51 & 52 ? (a ^ 15 ? 8 ^ Math.random() * (a ^ 20 ? 16 : 4) : 4).toString(16) : \"-\";\n  }\n\n  return b;\n} // Maps for number <-> hex string conversion\n\nlet _convertMapsInitialized = false;\n\nlet _byteToHex;\n\nlet _hexToByte;\n\nfunction initConvertMaps() {\n  _byteToHex = new Array(256);\n  _hexToByte = {};\n\n  for (let i = 0; i < 256; i++) {\n    _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n    _hexToByte[_byteToHex[i]] = i;\n  }\n\n  _convertMapsInitialized = true;\n}\n/** Parse a UUID into it's component bytes */\n// Adapted from https://github.com/zefferus/uuid-parse\n\n\nexport function guidToArray(s) {\n  if (!_convertMapsInitialized) {\n    initConvertMaps();\n  }\n\n  let i = 0;\n  const buf = new Uint8Array(16);\n  s.toLowerCase().replace(/[0-9a-f]{2}/g, oct => {\n    switch (i) {\n      // .NET saves first three byte groups with different endianness\n      // See https://stackoverflow.com/a/16722909/3922220\n      case 0:\n      case 1:\n      case 2:\n      case 3:\n        buf[3 - i++] = _hexToByte[oct];\n        break;\n\n      case 4:\n      case 5:\n        buf[9 - i++] = _hexToByte[oct];\n        break;\n\n      case 6:\n      case 7:\n        buf[13 - i++] = _hexToByte[oct];\n        break;\n\n      case 8:\n      case 9:\n      case 10:\n      case 11:\n      case 12:\n      case 13:\n      case 14:\n      case 15:\n        buf[i++] = _hexToByte[oct];\n        break;\n    }\n  }); // Zero out remaining bytes if string was short\n\n  while (i < 16) {\n    buf[i++] = 0;\n  }\n\n  return buf;\n}\n/** Convert UUID byte array into a string */\n\nexport function arrayToGuid(buf) {\n  if (buf.length !== 16) {\n    throw new Error(\"Byte array for GUID must be exactly 16 bytes long\");\n  }\n\n  if (!_convertMapsInitialized) {\n    initConvertMaps();\n  }\n\n  const guid = _byteToHex[buf[3]] + _byteToHex[buf[2]] + _byteToHex[buf[1]] + _byteToHex[buf[0]] + \"-\" + _byteToHex[buf[5]] + _byteToHex[buf[4]] + \"-\" + _byteToHex[buf[7]] + _byteToHex[buf[6]] + \"-\" + _byteToHex[buf[8]] + _byteToHex[buf[9]] + \"-\" + _byteToHex[buf[10]] + _byteToHex[buf[11]] + _byteToHex[buf[12]] + _byteToHex[buf[13]] + _byteToHex[buf[14]] + _byteToHex[buf[15]];\n  return guid;\n}\n\nfunction notSupported(name) {\n  throw new Error(\"The environment doesn't support '\" + name + \"', please use a polyfill.\");\n}\n\nexport function toBase64String(inArray) {\n  let str = \"\";\n\n  for (let i = 0; i < inArray.length; i++) {\n    str += String.fromCharCode(inArray[i]);\n  }\n\n  return typeof btoa === \"function\" ? btoa(str) : notSupported(\"btoa\");\n}\nexport function fromBase64String(b64Encoded) {\n  const binary = typeof atob === \"function\" ? atob(b64Encoded) : notSupported(\"atob\");\n  const bytes = new Uint8Array(binary.length);\n\n  for (let i = 0; i < binary.length; i++) {\n    bytes[i] = binary.charCodeAt(i);\n  }\n\n  return bytes;\n}\nexport function padLeft(str, len, ch, isRight) {\n  ch = ch || \" \";\n  len = len - str.length;\n\n  for (let i = 0; i < len; i++) {\n    str = isRight ? str + ch : ch + str;\n  }\n\n  return str;\n}\nexport function padRight(str, len, ch) {\n  return padLeft(str, len, ch, true);\n}\nexport function remove(str, startIndex, count) {\n  if (startIndex >= str.length) {\n    throw new Error(\"startIndex must be less than length of string\");\n  }\n\n  if (typeof count === \"number\" && startIndex + count > str.length) {\n    throw new Error(\"Index and count must refer to a location within the string.\");\n  }\n\n  return str.slice(0, startIndex) + (typeof count === \"number\" ? str.substr(startIndex + count) : \"\");\n}\nexport function replace(str, search, replace) {\n  return str.replace(new RegExp(escape(search), \"g\"), replace);\n}\nexport function replicate(n, x) {\n  return initialize(n, () => x);\n}\nexport function getCharAtIndex(input, index) {\n  if (index < 0 || index >= input.length) {\n    throw new Error(\"Index was outside the bounds of the array.\");\n  }\n\n  return input[index];\n}\nexport function split(str, splitters, count, removeEmpty) {\n  count = typeof count === \"number\" ? count : undefined;\n  removeEmpty = typeof removeEmpty === \"number\" ? removeEmpty : undefined;\n\n  if (count && count < 0) {\n    throw new Error(\"Count cannot be less than zero\");\n  }\n\n  if (count === 0) {\n    return [];\n  }\n\n  if (!Array.isArray(splitters)) {\n    if (removeEmpty === 0) {\n      return str.split(splitters, count);\n    }\n\n    const len = arguments.length;\n    splitters = Array(len - 1);\n\n    for (let key = 1; key < len; key++) {\n      splitters[key - 1] = arguments[key];\n    }\n  }\n\n  splitters = splitters.map(x => escape(x));\n  splitters = splitters.length > 0 ? splitters : [\" \"];\n  let i = 0;\n  const splits = [];\n  const reg = new RegExp(splitters.join(\"|\"), \"g\");\n\n  while (count == null || count > 1) {\n    const m = reg.exec(str);\n\n    if (m === null) {\n      break;\n    }\n\n    if (!removeEmpty || m.index - i > 0) {\n      count = count != null ? count - 1 : count;\n      splits.push(str.substring(i, m.index));\n    }\n\n    i = reg.lastIndex;\n  }\n\n  if (!removeEmpty || str.length - i > 0) {\n    splits.push(str.substring(i));\n  }\n\n  return splits;\n}\nexport function trim(str, ...chars) {\n  if (chars.length === 0) {\n    return str.trim();\n  }\n\n  const pattern = \"[\" + escape(chars.join(\"\")) + \"]+\";\n  return str.replace(new RegExp(\"^\" + pattern), \"\").replace(new RegExp(pattern + \"$\"), \"\");\n}\nexport function trimStart(str, ...chars) {\n  return chars.length === 0 ? str.trimStart() : str.replace(new RegExp(\"^[\" + escape(chars.join(\"\")) + \"]+\"), \"\");\n}\nexport function trimEnd(str, ...chars) {\n  return chars.length === 0 ? str.trimEnd() : str.replace(new RegExp(\"[\" + escape(chars.join(\"\")) + \"]+$\"), \"\");\n}\nexport function filter(pred, x) {\n  return x.split(\"\").filter(c => pred(c)).join(\"\");\n}\nexport function substring(str, startIndex, length) {\n  if (startIndex + (length || 0) > str.length) {\n    throw new Error(\"Invalid startIndex and/or length\");\n  }\n\n  return length != null ? str.substr(startIndex, length) : str.substr(startIndex);\n}","import { declare, FSharpRef } from \"./Types\";\nimport { iterateIndexed, toIterator, getEnumerator, delay, collect, map, sumBy, iterate } from \"./Seq\";\nimport { type } from \"./Reflection\";\nimport { equals, getItemFromDict, tryGetValue } from \"./Util\";\nimport { toText, printf } from \"./String\";\nexport const MutableMap$00602 = declare(function Fable_Collections_MutableMap(pairs, comparer) {\n  const $this$$1 = this;\n  const this$ = new FSharpRef(null);\n  $this$$1.comparer = comparer;\n  this$.contents = $this$$1;\n  $this$$1.hashMap = new Map([]);\n  $this$$1[\"init@20-1\"] = 1;\n  iterate(function (pair) {\n    MutableMap$00602$$Add$$5BDDA1(this$.contents, pair[0], pair[1]);\n  }, pairs);\n});\nexport function MutableMap$00602$reflection($gen$$4, $gen$$5) {\n  return type(\"Fable.Collections.MutableMap`2\", [$gen$$4, $gen$$5]);\n}\nexport function MutableMap$00602$$$$002Ector$$6623D9B3(pairs, comparer) {\n  return this instanceof MutableMap$00602 ? MutableMap$00602.call(this, pairs, comparer) : new MutableMap$00602(pairs, comparer);\n}\n\nfunction MutableMap$00602$$TryFindIndex$$2B595(this$$$1, k) {\n  const h = this$$$1.comparer.GetHashCode(k) | 0;\n  const matchValue = tryGetValue(this$$$1.hashMap, h, null);\n\n  if (matchValue[0]) {\n    return [true, h, matchValue[1].findIndex(function (pair$$1) {\n      return this$$$1.comparer.Equals(k, pair$$1[0]);\n    })];\n  } else {\n    return [false, h, -1];\n  }\n}\n\nexport function MutableMap$00602$$TryFind$$2B595(this$$$2, k$$1) {\n  const matchValue$$1 = MutableMap$00602$$TryFindIndex$$2B595(this$$$2, k$$1);\n  var $target$$10;\n\n  if (matchValue$$1[0]) {\n    if (matchValue$$1[2] > -1) {\n      $target$$10 = 0;\n    } else {\n      $target$$10 = 1;\n    }\n  } else {\n    $target$$10 = 1;\n  }\n\n  switch ($target$$10) {\n    case 0:\n      {\n        return getItemFromDict(this$$$2.hashMap, matchValue$$1[1])[matchValue$$1[2]];\n      }\n\n    case 1:\n      {\n        return null;\n      }\n  }\n}\nexport function MutableMap$00602$$get_Comparer(this$$$3) {\n  return this$$$3.comparer;\n}\nexport function MutableMap$00602$$Clear(this$$$4) {\n  this$$$4.hashMap.clear();\n}\nexport function MutableMap$00602$$get_Count(this$$$5) {\n  const source = this$$$5.hashMap.values();\n  return sumBy(function projection(pairs$$2) {\n    return pairs$$2.length;\n  }, source, {\n    GetZero() {\n      return 0;\n    },\n\n    Add($x$$2, $y$$3) {\n      return $x$$2 + $y$$3;\n    }\n\n  }) | 0;\n}\nexport function MutableMap$00602$$get_Item$$2B595(this$$$6, k$$2) {\n  const matchValue$$2 = MutableMap$00602$$TryFind$$2B595(this$$$6, k$$2);\n\n  if (matchValue$$2 != null) {\n    const pair$$2 = matchValue$$2;\n    return pair$$2[1];\n  } else {\n    throw new Error(\"The item was not found in collection\");\n  }\n}\nexport function MutableMap$00602$$set_Item$$5BDDA1(this$$$7, k$$3, v) {\n  const matchValue$$3 = MutableMap$00602$$TryFindIndex$$2B595(this$$$7, k$$3);\n  var $target$$20;\n\n  if (matchValue$$3[0]) {\n    if (matchValue$$3[2] > -1) {\n      $target$$20 = 0;\n    } else {\n      $target$$20 = 1;\n    }\n  } else {\n    $target$$20 = 1;\n  }\n\n  switch ($target$$20) {\n    case 0:\n      {\n        getItemFromDict(this$$$7.hashMap, matchValue$$3[1])[matchValue$$3[2]] = [k$$3, v];\n        break;\n      }\n\n    case 1:\n      {\n        if (matchValue$$3[0]) {\n          const value = getItemFromDict(this$$$7.hashMap, matchValue$$3[1]).push([k$$3, v]);\n          void null;\n        } else {\n          this$$$7.hashMap.set(matchValue$$3[1], [[k$$3, v]]);\n        }\n\n        break;\n      }\n  }\n}\nexport function MutableMap$00602$$Add$$5BDDA1(this$$$8, k$$4, v$$1) {\n  const matchValue$$4 = MutableMap$00602$$TryFindIndex$$2B595(this$$$8, k$$4);\n  var $target$$24;\n\n  if (matchValue$$4[0]) {\n    if (matchValue$$4[2] > -1) {\n      $target$$24 = 0;\n    } else {\n      $target$$24 = 1;\n    }\n  } else {\n    $target$$24 = 1;\n  }\n\n  switch ($target$$24) {\n    case 0:\n      {\n        let msg;\n        const clo1 = toText(printf(\"An item with the same key has already been added. Key: %A\"));\n        msg = clo1(k$$4);\n        throw new Error(msg);\n        break;\n      }\n\n    case 1:\n      {\n        if (matchValue$$4[0]) {\n          const value$$1 = getItemFromDict(this$$$8.hashMap, matchValue$$4[1]).push([k$$4, v$$1]);\n          void null;\n        } else {\n          this$$$8.hashMap.set(matchValue$$4[1], [[k$$4, v$$1]]);\n        }\n\n        break;\n      }\n  }\n}\nexport function MutableMap$00602$$ContainsKey$$2B595(this$$$9, k$$5) {\n  const matchValue$$5 = MutableMap$00602$$TryFindIndex$$2B595(this$$$9, k$$5);\n  var $target$$27;\n\n  if (matchValue$$5[0]) {\n    if (matchValue$$5[2] > -1) {\n      $target$$27 = 0;\n    } else {\n      $target$$27 = 1;\n    }\n  } else {\n    $target$$27 = 1;\n  }\n\n  switch ($target$$27) {\n    case 0:\n      {\n        return true;\n      }\n\n    case 1:\n      {\n        return false;\n      }\n  }\n}\nexport function MutableMap$00602$$Remove$$2B595(this$$$10, k$$6) {\n  const matchValue$$6 = MutableMap$00602$$TryFindIndex$$2B595(this$$$10, k$$6);\n  var $target$$30;\n\n  if (matchValue$$6[0]) {\n    if (matchValue$$6[2] > -1) {\n      $target$$30 = 0;\n    } else {\n      $target$$30 = 1;\n    }\n  } else {\n    $target$$30 = 1;\n  }\n\n  switch ($target$$30) {\n    case 0:\n      {\n        getItemFromDict(this$$$10.hashMap, matchValue$$6[1]).splice(matchValue$$6[2], 1);\n        return true;\n      }\n\n    case 1:\n      {\n        return false;\n      }\n  }\n}\n\nMutableMap$00602.prototype[Symbol.iterator] = function () {\n  var elems;\n  const this$$$11 = this;\n  return toIterator((elems = delay(function () {\n    return collect(function (pairs$$3) {\n      return map(function (pair$$3) {\n        return pair$$3;\n      }, pairs$$3);\n    }, this$$$11.hashMap.values());\n  }), getEnumerator(elems)));\n};\n\nMutableMap$00602.prototype.Add = function (item) {\n  const this$$$12 = this;\n  MutableMap$00602$$Add$$5BDDA1(this$$$12, item[0], item[1]);\n};\n\nMutableMap$00602.prototype.Clear = function () {\n  const this$$$13 = this;\n  MutableMap$00602$$Clear(this$$$13);\n};\n\nMutableMap$00602.prototype.Contains = function (item$$1) {\n  var p;\n  const this$$$14 = this;\n  const matchValue$$7 = MutableMap$00602$$TryFind$$2B595(this$$$14, item$$1[0]);\n  var $target$$31;\n\n  if (matchValue$$7 != null) {\n    if (p = matchValue$$7, equals(p[1], item$$1[1])) {\n      $target$$31 = 0;\n    } else {\n      $target$$31 = 1;\n    }\n  } else {\n    $target$$31 = 1;\n  }\n\n  switch ($target$$31) {\n    case 0:\n      {\n        return true;\n      }\n\n    case 1:\n      {\n        return false;\n      }\n  }\n};\n\nMutableMap$00602.prototype.CopyTo = function (array, arrayIndex) {\n  const this$$$15 = this;\n  iterateIndexed(function action(i$$10, e) {\n    array[arrayIndex + i$$10] = e;\n  }, this$$$15);\n};\n\nObject.defineProperty(MutableMap$00602.prototype, \"Count\", {\n  \"get\": function () {\n    const this$$$16 = this;\n    return MutableMap$00602$$get_Count(this$$$16) | 0;\n  }\n});\nObject.defineProperty(MutableMap$00602.prototype, \"IsReadOnly\", {\n  \"get\": function () {\n    return false;\n  }\n});\n\nMutableMap$00602.prototype.Remove = function (item$$2) {\n  const this$$$18 = this;\n  const matchValue$$8 = MutableMap$00602$$TryFind$$2B595(this$$$18, item$$2[0]);\n\n  if (matchValue$$8 != null) {\n    const pair$$4 = matchValue$$8;\n\n    if (equals(pair$$4[1], item$$2[1])) {\n      const value$$2 = MutableMap$00602$$Remove$$2B595(this$$$18, item$$2[0]);\n      void value$$2;\n    }\n\n    return true;\n  } else {\n    return false;\n  }\n};\n\nObject.defineProperty(MutableMap$00602.prototype, \"size\", {\n  \"get\": function () {\n    const this$$$19 = this;\n    return MutableMap$00602$$get_Count(this$$$19) | 0;\n  }\n});\n\nMutableMap$00602.prototype.clear = function () {\n  const this$$$20 = this;\n  MutableMap$00602$$Clear(this$$$20);\n};\n\nMutableMap$00602.prototype.delete = function (k$$7) {\n  const this$$$21 = this;\n  return MutableMap$00602$$Remove$$2B595(this$$$21, k$$7);\n};\n\nMutableMap$00602.prototype.entries = function () {\n  const this$$$22 = this;\n  return map(function mapping(x) {\n    return x;\n  }, this$$$22);\n};\n\nMutableMap$00602.prototype.get = function (k$$8) {\n  const this$$$23 = this;\n  return MutableMap$00602$$get_Item$$2B595(this$$$23, k$$8);\n};\n\nMutableMap$00602.prototype.has = function (k$$9) {\n  const this$$$24 = this;\n  return MutableMap$00602$$ContainsKey$$2B595(this$$$24, k$$9);\n};\n\nMutableMap$00602.prototype.keys = function () {\n  const this$$$25 = this;\n  return map(function mapping$$1(pair$$5) {\n    return pair$$5[0];\n  }, this$$$25);\n};\n\nMutableMap$00602.prototype.set = function (k$$10, v$$2) {\n  const this$$$26 = this;\n  MutableMap$00602$$set_Item$$5BDDA1(this$$$26, k$$10, v$$2);\n  return this$$$26;\n};\n\nMutableMap$00602.prototype.values = function () {\n  const this$$$27 = this;\n  return map(function mapping$$2(pair$$6) {\n    return pair$$6[1];\n  }, this$$$27);\n};","import { Record, List, declare, Union } from \"./Types\";\nimport { type, record, bool, list, union, int32 } from \"./Reflection\";\nimport { value as value$$3, some } from \"./Option\";\nimport { iterate as iterate$$1, empty as empty$$1, toIterator, map as map$$2, unfold, getEnumerator, fold as fold$$1 } from \"./Seq\";\nimport { compare, structuralHash, isDisposable } from \"./Util\";\nimport { join, toText, printf } from \"./String\";\nimport { MutableMap$00602$$$$002Ector$$6623D9B3 as MutableMap$002400602$0024$0024$0024$0024002Ector$0024$00246623D9B3 } from \"./MutableMap\";\nexport const MapTree$00602 = declare(function Map_MapTree(tag, name, ...fields) {\n  Union.call(this, tag, name, ...fields);\n}, Union);\nexport function MapTree$00602$reflection($gen$$3, $gen$$4) {\n  return union(\"Map.MapTree`2\", [$gen$$3, $gen$$4], MapTree$00602, () => [\"MapEmpty\", [\"MapOne\", [$gen$$3, $gen$$4]], [\"MapNode\", [$gen$$3, $gen$$4, MapTree$00602$reflection($gen$$3, $gen$$4), MapTree$00602$reflection($gen$$3, $gen$$4), int32]]]);\n}\nexport function MapTreeModule$$$sizeAux($acc$$5, $m$$6) {\n  MapTreeModule$$$sizeAux: while (true) {\n    const acc = $acc$$5,\n          m = $m$$6;\n\n    switch (m.tag) {\n      case 1:\n        {\n          return acc + 1 | 0;\n        }\n\n      case 2:\n        {\n          $acc$$5 = MapTreeModule$$$sizeAux(acc + 1, m.fields[2]);\n          $m$$6 = m.fields[3];\n          continue MapTreeModule$$$sizeAux;\n        }\n\n      default:\n        {\n          return acc | 0;\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$size(x) {\n  return MapTreeModule$$$sizeAux(0, x);\n}\nexport function MapTreeModule$$$empty() {\n  return new MapTree$00602(0, \"MapEmpty\");\n}\nexport function MapTreeModule$$$height(_arg1) {\n  switch (_arg1.tag) {\n    case 1:\n      {\n        return 1;\n      }\n\n    case 2:\n      {\n        return _arg1.fields[4] | 0;\n      }\n\n    default:\n      {\n        return 0;\n      }\n  }\n}\nexport function MapTreeModule$$$isEmpty(m$$1) {\n  if (m$$1.tag === 0) {\n    return true;\n  } else {\n    return false;\n  }\n}\nexport function MapTreeModule$$$mk(l$$1, k, v, r$$1) {\n  var $target$$14;\n\n  if (l$$1.tag === 0) {\n    if (r$$1.tag === 0) {\n      $target$$14 = 0;\n    } else {\n      $target$$14 = 1;\n    }\n  } else {\n    $target$$14 = 1;\n  }\n\n  switch ($target$$14) {\n    case 0:\n      {\n        return new MapTree$00602(1, \"MapOne\", k, v);\n      }\n\n    case 1:\n      {\n        const hl = MapTreeModule$$$height(l$$1) | 0;\n        const hr = MapTreeModule$$$height(r$$1) | 0;\n        const m$$2 = (hl < hr ? hr : hl) | 0;\n        return new MapTree$00602(2, \"MapNode\", k, v, l$$1, r$$1, m$$2 + 1);\n      }\n  }\n}\nexport function MapTreeModule$$$rebalance(t1, k$$1, v$$1, t2) {\n  const t1h = MapTreeModule$$$height(t1) | 0;\n  const t2h = MapTreeModule$$$height(t2) | 0;\n\n  if (t2h > t1h + 2) {\n    if (t2.tag === 2) {\n      if (MapTreeModule$$$height(t2.fields[2]) > t1h + 1) {\n        if (t2.fields[2].tag === 2) {\n          return MapTreeModule$$$mk(MapTreeModule$$$mk(t1, k$$1, v$$1, t2.fields[2].fields[2]), t2.fields[2].fields[0], t2.fields[2].fields[1], MapTreeModule$$$mk(t2.fields[2].fields[3], t2.fields[0], t2.fields[1], t2.fields[3]));\n        } else {\n          throw new Error(\"rebalance\");\n        }\n      } else {\n        return MapTreeModule$$$mk(MapTreeModule$$$mk(t1, k$$1, v$$1, t2.fields[2]), t2.fields[0], t2.fields[1], t2.fields[3]);\n      }\n    } else {\n      throw new Error(\"rebalance\");\n    }\n  } else if (t1h > t2h + 2) {\n    if (t1.tag === 2) {\n      if (MapTreeModule$$$height(t1.fields[3]) > t2h + 1) {\n        if (t1.fields[3].tag === 2) {\n          return MapTreeModule$$$mk(MapTreeModule$$$mk(t1.fields[2], t1.fields[0], t1.fields[1], t1.fields[3].fields[2]), t1.fields[3].fields[0], t1.fields[3].fields[1], MapTreeModule$$$mk(t1.fields[3].fields[3], k$$1, v$$1, t2));\n        } else {\n          throw new Error(\"re  balance\");\n        }\n      } else {\n        return MapTreeModule$$$mk(t1.fields[2], t1.fields[0], t1.fields[1], MapTreeModule$$$mk(t1.fields[3], k$$1, v$$1, t2));\n      }\n    } else {\n      throw new Error(\"rebalance\");\n    }\n  } else {\n    return MapTreeModule$$$mk(t1, k$$1, v$$1, t2);\n  }\n}\nexport function MapTreeModule$$$add(comparer, k$$2, v$$2, m$$3) {\n  switch (m$$3.tag) {\n    case 1:\n      {\n        const c = comparer.Compare(k$$2, m$$3.fields[0]) | 0;\n\n        if (c < 0) {\n          return new MapTree$00602(2, \"MapNode\", k$$2, v$$2, new MapTree$00602(0, \"MapEmpty\"), m$$3, 2);\n        } else if (c === 0) {\n          return new MapTree$00602(1, \"MapOne\", k$$2, v$$2);\n        } else {\n          return new MapTree$00602(2, \"MapNode\", k$$2, v$$2, m$$3, new MapTree$00602(0, \"MapEmpty\"), 2);\n        }\n      }\n\n    case 2:\n      {\n        const c$$1 = comparer.Compare(k$$2, m$$3.fields[0]) | 0;\n\n        if (c$$1 < 0) {\n          return MapTreeModule$$$rebalance(MapTreeModule$$$add(comparer, k$$2, v$$2, m$$3.fields[2]), m$$3.fields[0], m$$3.fields[1], m$$3.fields[3]);\n        } else if (c$$1 === 0) {\n          return new MapTree$00602(2, \"MapNode\", k$$2, v$$2, m$$3.fields[2], m$$3.fields[3], m$$3.fields[4]);\n        } else {\n          return MapTreeModule$$$rebalance(m$$3.fields[2], m$$3.fields[0], m$$3.fields[1], MapTreeModule$$$add(comparer, k$$2, v$$2, m$$3.fields[3]));\n        }\n      }\n\n    default:\n      {\n        return new MapTree$00602(1, \"MapOne\", k$$2, v$$2);\n      }\n  }\n}\nexport function MapTreeModule$$$find($comparer$$1$$23, $k$$3$$24, $m$$4$$25) {\n  MapTreeModule$$$find: while (true) {\n    const comparer$$1 = $comparer$$1$$23,\n          k$$3 = $k$$3$$24,\n          m$$4 = $m$$4$$25;\n\n    switch (m$$4.tag) {\n      case 1:\n        {\n          const c$$2 = comparer$$1.Compare(k$$3, m$$4.fields[0]) | 0;\n\n          if (c$$2 === 0) {\n            return m$$4.fields[1];\n          } else {\n            throw new Error(\"key not found\");\n          }\n        }\n\n      case 2:\n        {\n          const c$$3 = comparer$$1.Compare(k$$3, m$$4.fields[0]) | 0;\n\n          if (c$$3 < 0) {\n            $comparer$$1$$23 = comparer$$1;\n            $k$$3$$24 = k$$3;\n            $m$$4$$25 = m$$4.fields[2];\n            continue MapTreeModule$$$find;\n          } else if (c$$3 === 0) {\n            return m$$4.fields[1];\n          } else {\n            $comparer$$1$$23 = comparer$$1;\n            $k$$3$$24 = k$$3;\n            $m$$4$$25 = m$$4.fields[3];\n            continue MapTreeModule$$$find;\n          }\n        }\n\n      default:\n        {\n          throw new Error(\"key not found\");\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$tryFind($comparer$$2$$26, $k$$4$$27, $m$$5$$28) {\n  MapTreeModule$$$tryFind: while (true) {\n    const comparer$$2 = $comparer$$2$$26,\n          k$$4 = $k$$4$$27,\n          m$$5 = $m$$5$$28;\n\n    switch (m$$5.tag) {\n      case 1:\n        {\n          const c$$4 = comparer$$2.Compare(k$$4, m$$5.fields[0]) | 0;\n\n          if (c$$4 === 0) {\n            return some(m$$5.fields[1]);\n          } else {\n            return null;\n          }\n        }\n\n      case 2:\n        {\n          const c$$5 = comparer$$2.Compare(k$$4, m$$5.fields[0]) | 0;\n\n          if (c$$5 < 0) {\n            $comparer$$2$$26 = comparer$$2;\n            $k$$4$$27 = k$$4;\n            $m$$5$$28 = m$$5.fields[2];\n            continue MapTreeModule$$$tryFind;\n          } else if (c$$5 === 0) {\n            return some(m$$5.fields[1]);\n          } else {\n            $comparer$$2$$26 = comparer$$2;\n            $k$$4$$27 = k$$4;\n            $m$$5$$28 = m$$5.fields[3];\n            continue MapTreeModule$$$tryFind;\n          }\n        }\n\n      default:\n        {\n          return null;\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$partition1(comparer$$3, f, k$$5, v$$3, acc1, acc2) {\n  if (f(k$$5, v$$3)) {\n    return [MapTreeModule$$$add(comparer$$3, k$$5, v$$3, acc1), acc2];\n  } else {\n    return [acc1, MapTreeModule$$$add(comparer$$3, k$$5, v$$3, acc2)];\n  }\n}\nexport function MapTreeModule$$$partitionAux($comparer$$4$$35, $f$$1$$36, $s$$37, $acc_0$$38, $acc_1$$39) {\n  MapTreeModule$$$partitionAux: while (true) {\n    const comparer$$4 = $comparer$$4$$35,\n          f$$1 = $f$$1$$36,\n          s = $s$$37,\n          acc_0 = $acc_0$$38,\n          acc_1 = $acc_1$$39;\n\n    switch (s.tag) {\n      case 1:\n        {\n          return MapTreeModule$$$partition1(comparer$$4, f$$1, s.fields[0], s.fields[1], acc_0, acc_1);\n        }\n\n      case 2:\n        {\n          const acc$$2 = MapTreeModule$$$partitionAux(comparer$$4, f$$1, s.fields[3], acc_0, acc_1);\n          const acc$$3 = MapTreeModule$$$partition1(comparer$$4, f$$1, s.fields[0], s.fields[1], acc$$2[0], acc$$2[1]);\n          $comparer$$4$$35 = comparer$$4;\n          $f$$1$$36 = f$$1;\n          $s$$37 = s.fields[2];\n          $acc_0$$38 = acc$$3[0];\n          $acc_1$$39 = acc$$3[1];\n          continue MapTreeModule$$$partitionAux;\n        }\n\n      default:\n        {\n          return [acc_0, acc_1];\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$partition(comparer$$5, f$$2, s$$1) {\n  return MapTreeModule$$$partitionAux(comparer$$5, f$$2, s$$1, MapTreeModule$$$empty(), MapTreeModule$$$empty());\n}\nexport function MapTreeModule$$$filter1(comparer$$6, f$$3, k$$8, v$$6, acc$$4) {\n  if (f$$3(k$$8, v$$6)) {\n    return MapTreeModule$$$add(comparer$$6, k$$8, v$$6, acc$$4);\n  } else {\n    return acc$$4;\n  }\n}\nexport function MapTreeModule$$$filterAux($comparer$$7$$48, $f$$4$$49, $s$$2$$50, $acc$$5$$51) {\n  MapTreeModule$$$filterAux: while (true) {\n    const comparer$$7 = $comparer$$7$$48,\n          f$$4 = $f$$4$$49,\n          s$$2 = $s$$2$$50,\n          acc$$5 = $acc$$5$$51;\n\n    switch (s$$2.tag) {\n      case 1:\n        {\n          return MapTreeModule$$$filter1(comparer$$7, f$$4, s$$2.fields[0], s$$2.fields[1], acc$$5);\n        }\n\n      case 2:\n        {\n          const acc$$6 = MapTreeModule$$$filterAux(comparer$$7, f$$4, s$$2.fields[2], acc$$5);\n          const acc$$7 = MapTreeModule$$$filter1(comparer$$7, f$$4, s$$2.fields[0], s$$2.fields[1], acc$$6);\n          $comparer$$7$$48 = comparer$$7;\n          $f$$4$$49 = f$$4;\n          $s$$2$$50 = s$$2.fields[3];\n          $acc$$5$$51 = acc$$7;\n          continue MapTreeModule$$$filterAux;\n        }\n\n      default:\n        {\n          return acc$$5;\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$filter(comparer$$8, f$$5, s$$3) {\n  return MapTreeModule$$$filterAux(comparer$$8, f$$5, s$$3, MapTreeModule$$$empty());\n}\nexport function MapTreeModule$$$spliceOutSuccessor(m$$6) {\n  switch (m$$6.tag) {\n    case 1:\n      {\n        return [m$$6.fields[0], m$$6.fields[1], new MapTree$00602(0, \"MapEmpty\")];\n      }\n\n    case 2:\n      {\n        if (m$$6.fields[2].tag === 0) {\n          return [m$$6.fields[0], m$$6.fields[1], m$$6.fields[3]];\n        } else {\n          const patternInput = MapTreeModule$$$spliceOutSuccessor(m$$6.fields[2]);\n          return [patternInput[0], patternInput[1], MapTreeModule$$$mk(patternInput[2], m$$6.fields[0], m$$6.fields[1], m$$6.fields[3])];\n        }\n      }\n\n    default:\n      {\n        throw new Error(\"internal error: Map.spliceOutSuccessor\");\n      }\n  }\n}\nexport function MapTreeModule$$$remove(comparer$$9, k$$11, m$$7) {\n  switch (m$$7.tag) {\n    case 1:\n      {\n        const c$$6 = comparer$$9.Compare(k$$11, m$$7.fields[0]) | 0;\n\n        if (c$$6 === 0) {\n          return new MapTree$00602(0, \"MapEmpty\");\n        } else {\n          return m$$7;\n        }\n      }\n\n    case 2:\n      {\n        const c$$7 = comparer$$9.Compare(k$$11, m$$7.fields[0]) | 0;\n\n        if (c$$7 < 0) {\n          return MapTreeModule$$$rebalance(MapTreeModule$$$remove(comparer$$9, k$$11, m$$7.fields[2]), m$$7.fields[0], m$$7.fields[1], m$$7.fields[3]);\n        } else if (c$$7 === 0) {\n          if (m$$7.fields[2].tag === 0) {\n            return m$$7.fields[3];\n          } else if (m$$7.fields[3].tag === 0) {\n            return m$$7.fields[2];\n          } else {\n            const patternInput$$1 = MapTreeModule$$$spliceOutSuccessor(m$$7.fields[3]);\n            return MapTreeModule$$$mk(m$$7.fields[2], patternInput$$1[0], patternInput$$1[1], patternInput$$1[2]);\n          }\n        } else {\n          return MapTreeModule$$$rebalance(m$$7.fields[2], m$$7.fields[0], m$$7.fields[1], MapTreeModule$$$remove(comparer$$9, k$$11, m$$7.fields[3]));\n        }\n      }\n\n    default:\n      {\n        return MapTreeModule$$$empty();\n      }\n  }\n}\nexport function MapTreeModule$$$mem($comparer$$10$$59, $k$$12$$60, $m$$8$$61) {\n  MapTreeModule$$$mem: while (true) {\n    const comparer$$10 = $comparer$$10$$59,\n          k$$12 = $k$$12$$60,\n          m$$8 = $m$$8$$61;\n\n    switch (m$$8.tag) {\n      case 1:\n        {\n          return comparer$$10.Compare(k$$12, m$$8.fields[0]) === 0;\n        }\n\n      case 2:\n        {\n          const c$$8 = comparer$$10.Compare(k$$12, m$$8.fields[0]) | 0;\n\n          if (c$$8 < 0) {\n            $comparer$$10$$59 = comparer$$10;\n            $k$$12$$60 = k$$12;\n            $m$$8$$61 = m$$8.fields[2];\n            continue MapTreeModule$$$mem;\n          } else if (c$$8 === 0) {\n            return true;\n          } else {\n            $comparer$$10$$59 = comparer$$10;\n            $k$$12$$60 = k$$12;\n            $m$$8$$61 = m$$8.fields[3];\n            continue MapTreeModule$$$mem;\n          }\n        }\n\n      default:\n        {\n          return false;\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$iter($f$$6$$62, $m$$9$$63) {\n  MapTreeModule$$$iter: while (true) {\n    const f$$6 = $f$$6$$62,\n          m$$9 = $m$$9$$63;\n\n    switch (m$$9.tag) {\n      case 1:\n        {\n          f$$6(m$$9.fields[0], m$$9.fields[1]);\n          break;\n        }\n\n      case 2:\n        {\n          MapTreeModule$$$iter(f$$6, m$$9.fields[2]);\n          f$$6(m$$9.fields[0], m$$9.fields[1]);\n          $f$$6$$62 = f$$6;\n          $m$$9$$63 = m$$9.fields[3];\n          continue MapTreeModule$$$iter;\n          break;\n        }\n\n      default:\n        {}\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$tryPick($f$$7$$64, $m$$10$$65) {\n  MapTreeModule$$$tryPick: while (true) {\n    const f$$7 = $f$$7$$64,\n          m$$10 = $m$$10$$65;\n\n    switch (m$$10.tag) {\n      case 1:\n        {\n          return f$$7(m$$10.fields[0], m$$10.fields[1]);\n        }\n\n      case 2:\n        {\n          const matchValue$$2 = MapTreeModule$$$tryPick(f$$7, m$$10.fields[2]);\n\n          if (matchValue$$2 == null) {\n            const matchValue$$3 = f$$7(m$$10.fields[0], m$$10.fields[1]);\n\n            if (matchValue$$3 == null) {\n              $f$$7$$64 = f$$7;\n              $m$$10$$65 = m$$10.fields[3];\n              continue MapTreeModule$$$tryPick;\n            } else {\n              return matchValue$$3;\n            }\n          } else {\n            return matchValue$$2;\n          }\n        }\n\n      default:\n        {\n          return null;\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$exists($f$$8$$66, $m$$11$$67) {\n  MapTreeModule$$$exists: while (true) {\n    const f$$8 = $f$$8$$66,\n          m$$11 = $m$$11$$67;\n\n    switch (m$$11.tag) {\n      case 1:\n        {\n          return f$$8(m$$11.fields[0], m$$11.fields[1]);\n        }\n\n      case 2:\n        {\n          if (MapTreeModule$$$exists(f$$8, m$$11.fields[2]) ? true : f$$8(m$$11.fields[0], m$$11.fields[1])) {\n            return true;\n          } else {\n            $f$$8$$66 = f$$8;\n            $m$$11$$67 = m$$11.fields[3];\n            continue MapTreeModule$$$exists;\n          }\n        }\n\n      default:\n        {\n          return false;\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$forall($f$$9$$68, $m$$12$$69) {\n  MapTreeModule$$$forall: while (true) {\n    const f$$9 = $f$$9$$68,\n          m$$12 = $m$$12$$69;\n\n    switch (m$$12.tag) {\n      case 1:\n        {\n          return f$$9(m$$12.fields[0], m$$12.fields[1]);\n        }\n\n      case 2:\n        {\n          if (MapTreeModule$$$forall(f$$9, m$$12.fields[2]) ? f$$9(m$$12.fields[0], m$$12.fields[1]) : false) {\n            $f$$9$$68 = f$$9;\n            $m$$12$$69 = m$$12.fields[3];\n            continue MapTreeModule$$$forall;\n          } else {\n            return false;\n          }\n        }\n\n      default:\n        {\n          return true;\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$map(f$$10, m$$13) {\n  switch (m$$13.tag) {\n    case 1:\n      {\n        return new MapTree$00602(1, \"MapOne\", m$$13.fields[0], f$$10(m$$13.fields[1]));\n      }\n\n    case 2:\n      {\n        const l2 = MapTreeModule$$$map(f$$10, m$$13.fields[2]);\n        const v2$$16 = f$$10(m$$13.fields[1]);\n        const r2 = MapTreeModule$$$map(f$$10, m$$13.fields[3]);\n        return new MapTree$00602(2, \"MapNode\", m$$13.fields[0], v2$$16, l2, r2, m$$13.fields[4]);\n      }\n\n    default:\n      {\n        return MapTreeModule$$$empty();\n      }\n  }\n}\nexport function MapTreeModule$$$mapi(f$$11, m$$14) {\n  switch (m$$14.tag) {\n    case 1:\n      {\n        return new MapTree$00602(1, \"MapOne\", m$$14.fields[0], f$$11(m$$14.fields[0], m$$14.fields[1]));\n      }\n\n    case 2:\n      {\n        const l2$$1 = MapTreeModule$$$mapi(f$$11, m$$14.fields[2]);\n        const v2$$17 = f$$11(m$$14.fields[0], m$$14.fields[1]);\n        const r2$$1 = MapTreeModule$$$mapi(f$$11, m$$14.fields[3]);\n        return new MapTree$00602(2, \"MapNode\", m$$14.fields[0], v2$$17, l2$$1, r2$$1, m$$14.fields[4]);\n      }\n\n    default:\n      {\n        return MapTreeModule$$$empty();\n      }\n  }\n}\nexport function MapTreeModule$$$foldBack($f$$12$$74, $m$$15$$75, $x$$1$$76) {\n  MapTreeModule$$$foldBack: while (true) {\n    const f$$12 = $f$$12$$74,\n          m$$15 = $m$$15$$75,\n          x$$1 = $x$$1$$76;\n\n    switch (m$$15.tag) {\n      case 1:\n        {\n          return f$$12(m$$15.fields[0], m$$15.fields[1], x$$1);\n        }\n\n      case 2:\n        {\n          const x$$2 = MapTreeModule$$$foldBack(f$$12, m$$15.fields[3], x$$1);\n          const x$$3 = f$$12(m$$15.fields[0], m$$15.fields[1], x$$2);\n          $f$$12$$74 = f$$12;\n          $m$$15$$75 = m$$15.fields[2];\n          $x$$1$$76 = x$$3;\n          continue MapTreeModule$$$foldBack;\n        }\n\n      default:\n        {\n          return x$$1;\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$fold($f$$13$$77, $x$$4$$78, $m$$16$$79) {\n  MapTreeModule$$$fold: while (true) {\n    const f$$13 = $f$$13$$77,\n          x$$4 = $x$$4$$78,\n          m$$16 = $m$$16$$79;\n\n    switch (m$$16.tag) {\n      case 1:\n        {\n          return f$$13(x$$4, m$$16.fields[0], m$$16.fields[1]);\n        }\n\n      case 2:\n        {\n          const x$$5 = MapTreeModule$$$fold(f$$13, x$$4, m$$16.fields[2]);\n          const x$$6 = f$$13(x$$5, m$$16.fields[0], m$$16.fields[1]);\n          $f$$13$$77 = f$$13;\n          $x$$4$$78 = x$$6;\n          $m$$16$$79 = m$$16.fields[3];\n          continue MapTreeModule$$$fold;\n        }\n\n      default:\n        {\n          return x$$4;\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$foldFromTo(comparer$$11, lo, hi, f$$14, m$$17, x$$7) {\n  switch (m$$17.tag) {\n    case 1:\n      {\n        const cLoKey = comparer$$11.Compare(lo, m$$17.fields[0]) | 0;\n        const cKeyHi = comparer$$11.Compare(m$$17.fields[0], hi) | 0;\n        const x$$8 = (cLoKey <= 0 ? cKeyHi <= 0 : false) ? f$$14(m$$17.fields[0], m$$17.fields[1], x$$7) : x$$7;\n        return x$$8;\n      }\n\n    case 2:\n      {\n        const cLoKey$$1 = comparer$$11.Compare(lo, m$$17.fields[0]) | 0;\n        const cKeyHi$$1 = comparer$$11.Compare(m$$17.fields[0], hi) | 0;\n        const x$$9 = cLoKey$$1 < 0 ? MapTreeModule$$$foldFromTo(comparer$$11, lo, hi, f$$14, m$$17.fields[2], x$$7) : x$$7;\n        const x$$10 = (cLoKey$$1 <= 0 ? cKeyHi$$1 <= 0 : false) ? f$$14(m$$17.fields[0], m$$17.fields[1], x$$9) : x$$9;\n        const x$$11 = cKeyHi$$1 < 0 ? MapTreeModule$$$foldFromTo(comparer$$11, lo, hi, f$$14, m$$17.fields[3], x$$10) : x$$10;\n        return x$$11;\n      }\n\n    default:\n      {\n        return x$$7;\n      }\n  }\n}\nexport function MapTreeModule$$$foldSection(comparer$$12, lo$$1, hi$$1, f$$15, m$$18, x$$12) {\n  if (comparer$$12.Compare(lo$$1, hi$$1) === 1) {\n    return x$$12;\n  } else {\n    return MapTreeModule$$$foldFromTo(comparer$$12, lo$$1, hi$$1, f$$15, m$$18, x$$12);\n  }\n}\nexport function MapTreeModule$$$loop($m$$19$$92, $acc$$8$$93) {\n  MapTreeModule$$$loop: while (true) {\n    const m$$19 = $m$$19$$92,\n          acc$$8 = $acc$$8$$93;\n\n    switch (m$$19.tag) {\n      case 1:\n        {\n          return new List([m$$19.fields[0], m$$19.fields[1]], acc$$8);\n        }\n\n      case 2:\n        {\n          $m$$19$$92 = m$$19.fields[2];\n          $acc$$8$$93 = new List([m$$19.fields[0], m$$19.fields[1]], MapTreeModule$$$loop(m$$19.fields[3], acc$$8));\n          continue MapTreeModule$$$loop;\n        }\n\n      default:\n        {\n          return acc$$8;\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$toList(m$$20) {\n  return MapTreeModule$$$loop(m$$20, new List());\n}\nexport function MapTreeModule$$$ofList(comparer$$13, l$$20) {\n  return fold$$1(function (acc$$9, tupledArg) {\n    return MapTreeModule$$$add(comparer$$13, tupledArg[0], tupledArg[1], acc$$9);\n  }, MapTreeModule$$$empty(), l$$20);\n}\nexport function MapTreeModule$$$mkFromEnumerator($comparer$$14$$97, $acc$$10$$98, $e$$99) {\n  MapTreeModule$$$mkFromEnumerator: while (true) {\n    const comparer$$14 = $comparer$$14$$97,\n          acc$$10 = $acc$$10$$98,\n          e = $e$$99;\n\n    if (e.MoveNext()) {\n      const patternInput$$2 = e.Current;\n      $comparer$$14$$97 = comparer$$14;\n      $acc$$10$$98 = MapTreeModule$$$add(comparer$$14, patternInput$$2[0], patternInput$$2[1], acc$$10);\n      $e$$99 = e;\n      continue MapTreeModule$$$mkFromEnumerator;\n    } else {\n      return acc$$10;\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$ofArray(comparer$$15, arr) {\n  let res$$2 = MapTreeModule$$$empty();\n\n  for (let i = 0; i <= arr.length - 1; i++) {\n    const patternInput$$3 = arr[i];\n    res$$2 = MapTreeModule$$$add(comparer$$15, patternInput$$3[0], patternInput$$3[1], res$$2);\n  }\n\n  return res$$2;\n}\nexport function MapTreeModule$$$ofSeq(comparer$$16, c$$9) {\n  const ie = getEnumerator(c$$9);\n\n  try {\n    return MapTreeModule$$$mkFromEnumerator(comparer$$16, MapTreeModule$$$empty(), ie);\n  } finally {\n    if (isDisposable(ie)) {\n      ie.Dispose();\n    }\n  }\n}\nexport function MapTreeModule$$$copyToArray(s$$4, arr$$1, i$$1) {\n  let j = i$$1 | 0;\n  MapTreeModule$$$iter(function f$$16(x$$15, y$$2) {\n    arr$$1[j] = [x$$15, y$$2];\n    j = j + 1;\n  }, s$$4);\n}\nexport const MapTreeModule$002EMapIterator$00602 = declare(function Map_MapTreeModule_MapIterator(arg1, arg2) {\n  this.stack = arg1;\n  this.started = arg2;\n}, Record);\nexport function MapTreeModule$002EMapIterator$00602$reflection($gen$$109, $gen$$110) {\n  return record(\"Map.MapTreeModule.MapIterator`2\", [$gen$$109, $gen$$110], MapTreeModule$002EMapIterator$00602, () => [[\"stack\", list(MapTree$00602$reflection($gen$$109, $gen$$110))], [\"started\", bool]]);\n}\nexport function MapTreeModule$$$collapseLHS($stack$$111) {\n  MapTreeModule$$$collapseLHS: while (true) {\n    const stack = $stack$$111;\n\n    if (stack.tail != null) {\n      if (stack.head.tag === 1) {\n        return stack;\n      } else if (stack.head.tag === 2) {\n        $stack$$111 = new List(stack.head.fields[2], new List(new MapTree$00602(1, \"MapOne\", stack.head.fields[0], stack.head.fields[1]), new List(stack.head.fields[3], stack.tail)));\n        continue MapTreeModule$$$collapseLHS;\n      } else {\n        $stack$$111 = stack.tail;\n        continue MapTreeModule$$$collapseLHS;\n      }\n    } else {\n      return new List();\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$mkIterator(s$$5) {\n  return new MapTreeModule$002EMapIterator$00602(MapTreeModule$$$collapseLHS(new List(s$$5, new List())), false);\n}\nexport function MapTreeModule$$$notStarted() {\n  throw new Error(\"enumeration not started\");\n}\nexport function MapTreeModule$$$alreadyFinished() {\n  throw new Error(\"enumeration already finished\");\n}\nexport function MapTreeModule$$$current(i$$2) {\n  if (i$$2.started) {\n    const matchValue$$4 = i$$2.stack;\n\n    if (matchValue$$4.tail == null) {\n      return MapTreeModule$$$alreadyFinished();\n    } else if (matchValue$$4.head.tag === 1) {\n      return [matchValue$$4.head.fields[0], matchValue$$4.head.fields[1]];\n    } else {\n      throw new Error(\"Please report error: Map iterator, unexpected stack for current\");\n    }\n  } else {\n    return MapTreeModule$$$notStarted();\n  }\n}\nexport function MapTreeModule$$$moveNext(i$$3) {\n  if (i$$3.started) {\n    const matchValue$$5 = i$$3.stack;\n\n    if (matchValue$$5.tail == null) {\n      return false;\n    } else if (matchValue$$5.head.tag === 1) {\n      i$$3.stack = MapTreeModule$$$collapseLHS(matchValue$$5.tail);\n      return !(i$$3.stack.tail == null);\n    } else {\n      throw new Error(\"Please report error: Map iterator, unexpected stack for moveNext\");\n    }\n  } else {\n    i$$3.started = true;\n    return !(i$$3.stack.tail == null);\n  }\n}\nexport const MapTreeModule$002EmkIEnumerator$0027$00602 = declare(function Map_MapTreeModule_mkIEnumerator_(s$$6) {\n  const $this$$1 = this;\n  $this$$1.s = s$$6;\n  $this$$1.i = MapTreeModule$$$mkIterator($this$$1.s);\n});\nexport function MapTreeModule$002EmkIEnumerator$0027$00602$reflection($gen$$115, $gen$$116) {\n  return type(\"Map.MapTreeModule.mkIEnumerator'`2\", [$gen$$115, $gen$$116]);\n}\nexport function MapTreeModule$002EmkIEnumerator$0027$00602$$$$002Ector$$Z26BC498C(s$$6) {\n  return this instanceof MapTreeModule$002EmkIEnumerator$0027$00602 ? MapTreeModule$002EmkIEnumerator$0027$00602.call(this, s$$6) : new MapTreeModule$002EmkIEnumerator$0027$00602(s$$6);\n}\nObject.defineProperty(MapTreeModule$002EmkIEnumerator$0027$00602.prototype, \"Current\", {\n  \"get\": function () {\n    const __ = this;\n\n    return MapTreeModule$$$current(__.i);\n  }\n});\n\nMapTreeModule$002EmkIEnumerator$0027$00602.prototype.MoveNext = function () {\n  const __$$1 = this;\n\n  return MapTreeModule$$$moveNext(__$$1.i);\n};\n\nMapTreeModule$002EmkIEnumerator$0027$00602.prototype.Reset = function () {\n  const __$$2 = this;\n\n  __$$2.i = MapTreeModule$$$mkIterator(__$$2.s);\n};\n\nMapTreeModule$002EmkIEnumerator$0027$00602.prototype.Dispose = function () {};\n\nexport function MapTreeModule$$$mkIEnumerator(s$$7) {\n  return MapTreeModule$002EmkIEnumerator$0027$00602$$$$002Ector$$Z26BC498C(s$$7);\n}\nexport function MapTreeModule$$$toSeq(s$$8) {\n  const en = MapTreeModule$$$mkIEnumerator(s$$8);\n  return unfold(function generator(en$$1) {\n    if (en$$1.MoveNext()) {\n      return [en$$1.Current, en$$1];\n    } else {\n      return null;\n    }\n  }, en);\n}\nexport const FSharpMap = declare(function Map_Map(comparer$$17, tree) {\n  const $this$$2 = this;\n  $this$$2.comparer = comparer$$17;\n  $this$$2.tree = tree;\n});\nexport function FSharpMap$reflection($gen$$120, $gen$$121) {\n  return type(\"Map.FSharpMap\", [$gen$$120, $gen$$121]);\n}\nexport function FSharpMap$$$$002Ector$$58ADD115(comparer$$17, tree) {\n  return this instanceof FSharpMap ? FSharpMap.call(this, comparer$$17, tree) : new FSharpMap(comparer$$17, tree);\n}\nexport function FSharpMap$$get_Comparer(__$$4) {\n  return __$$4.comparer;\n}\nexport function FSharpMap$$get_Tree(__$$5) {\n  return __$$5.tree;\n}\nexport function FSharpMap$$Add$$5BDDA1(__$$6, k$$28, v$$24) {\n  return FSharpMap$$$$002Ector$$58ADD115(__$$6.comparer, MapTreeModule$$$add(__$$6.comparer, k$$28, v$$24, __$$6.tree));\n}\nexport function FSharpMap$$get_IsEmpty(__$$7) {\n  return MapTreeModule$$$isEmpty(__$$7.tree);\n}\nexport function FSharpMap$$get_Item$$2B595(__$$8, k$$29) {\n  return MapTreeModule$$$find(__$$8.comparer, k$$29, __$$8.tree);\n}\nexport function FSharpMap$$TryGetValue$$5BDDA1(__$$9, k$$30, defValue) {\n  const matchValue$$6 = MapTreeModule$$$tryFind(__$$9.comparer, k$$30, __$$9.tree);\n\n  if (matchValue$$6 == null) {\n    return [false, defValue];\n  } else {\n    const v$$25 = value$$3(matchValue$$6);\n    return [true, v$$25];\n  }\n}\nexport function FSharpMap$$TryPick$$72321DD7(__$$10, f$$17) {\n  return MapTreeModule$$$tryPick(f$$17, __$$10.tree);\n}\nexport function FSharpMap$$Exists$$Z395DDC35(__$$11, f$$18) {\n  return MapTreeModule$$$exists(f$$18, __$$11.tree);\n}\nexport function FSharpMap$$Filter$$Z395DDC35(__$$12, f$$19) {\n  return FSharpMap$$$$002Ector$$58ADD115(__$$12.comparer, MapTreeModule$$$filter(__$$12.comparer, f$$19, __$$12.tree));\n}\nexport function FSharpMap$$ForAll$$Z395DDC35(__$$13, f$$20) {\n  return MapTreeModule$$$forall(f$$20, __$$13.tree);\n}\nexport function FSharpMap$$Fold(__$$14, f$$21, acc$$11) {\n  return MapTreeModule$$$foldBack(f$$21, __$$14.tree, acc$$11);\n}\nexport function FSharpMap$$FoldSection(__$$15, lo$$2, hi$$2, f$$22, acc$$12) {\n  return MapTreeModule$$$foldSection(__$$15.comparer, lo$$2, hi$$2, f$$22, __$$15.tree, acc$$12);\n}\nexport function FSharpMap$$Iterate$$1DCFB91D(__$$16, f$$23) {\n  MapTreeModule$$$iter(f$$23, __$$16.tree);\n}\nexport function FSharpMap$$MapRange$$6DC7247(__$$17, f$$24) {\n  return FSharpMap$$$$002Ector$$58ADD115(__$$17.comparer, MapTreeModule$$$map(f$$24, __$$17.tree));\n}\nexport function FSharpMap$$Map$$Z6F6B671C(__$$18, f$$25) {\n  return FSharpMap$$$$002Ector$$58ADD115(__$$18.comparer, MapTreeModule$$$mapi(f$$25, __$$18.tree));\n}\nexport function FSharpMap$$Partition$$Z395DDC35(__$$19, f$$26) {\n  const patternInput$$4 = MapTreeModule$$$partition(__$$19.comparer, f$$26, __$$19.tree);\n  return [FSharpMap$$$$002Ector$$58ADD115(__$$19.comparer, patternInput$$4[0]), FSharpMap$$$$002Ector$$58ADD115(__$$19.comparer, patternInput$$4[1])];\n}\nexport function FSharpMap$$get_Count(__$$20) {\n  return MapTreeModule$$$size(__$$20.tree);\n}\nexport function FSharpMap$$ContainsKey$$2B595(__$$21, k$$31) {\n  return MapTreeModule$$$mem(__$$21.comparer, k$$31, __$$21.tree);\n}\nexport function FSharpMap$$Remove$$2B595(__$$22, k$$32) {\n  return FSharpMap$$$$002Ector$$58ADD115(__$$22.comparer, MapTreeModule$$$remove(__$$22.comparer, k$$32, __$$22.tree));\n}\nexport function FSharpMap$$TryFind$$2B595(__$$23, k$$33) {\n  return MapTreeModule$$$tryFind(__$$23.comparer, k$$33, __$$23.tree);\n}\nexport function FSharpMap$$ToList(__$$24) {\n  return MapTreeModule$$$toList(__$$24.tree);\n}\n\nFSharpMap.prototype.toString = function () {\n  var strings;\n  const this$ = this;\n  return \"map [\" + (strings = map$$2(function mapping(kv) {\n    const clo1 = toText(printf(\"(%A, %A)\"));\n    const clo2 = clo1(kv[0]);\n    return clo2(kv[1]);\n  }, this$), join(\"; \", strings)) + \"]\";\n};\n\nFSharpMap.prototype.GetHashCode = function () {\n  const this$$$1 = this;\n\n  const combineHash = function combineHash(x$$16, y$$3) {\n    return (x$$16 << 1) + y$$3 + 631;\n  };\n\n  let res$$3 = 0;\n  const e$$1 = MapTreeModule$$$mkIEnumerator(FSharpMap$$get_Tree(this$$$1));\n\n  while (e$$1.MoveNext()) {\n    const patternInput$$5 = e$$1.Current;\n    const activePatternResult3703 = patternInput$$5;\n    res$$3 = combineHash(res$$3, structuralHash(activePatternResult3703[0]));\n    res$$3 = combineHash(res$$3, structuralHash(activePatternResult3703[1]));\n  }\n\n  return Math.abs(res$$3) | 0;\n};\n\nFSharpMap.prototype.Equals = function (that) {\n  const this$$$2 = this;\n  return this$$$2.CompareTo(that) === 0;\n};\n\nFSharpMap.prototype[Symbol.iterator] = function () {\n  const __$$25 = this;\n\n  return toIterator(MapTreeModule$$$mkIEnumerator(__$$25.tree));\n};\n\nFSharpMap.prototype.CompareTo = function (obj) {\n  const m$$22 = this;\n  let res$$4 = 0;\n  let finished = false;\n  const e1 = MapTreeModule$$$mkIEnumerator(FSharpMap$$get_Tree(m$$22));\n\n  try {\n    const e2 = MapTreeModule$$$mkIEnumerator(FSharpMap$$get_Tree(obj));\n\n    try {\n      while (!finished ? res$$4 === 0 : false) {\n        const matchValue$$7 = [e1.MoveNext(), e2.MoveNext()];\n\n        if (matchValue$$7[0]) {\n          if (matchValue$$7[1]) {\n            const kvp1 = e1.Current;\n            const kvp2 = e2.Current;\n            const c$$10 = m$$22.comparer.Compare(kvp1[0], kvp2[0]) | 0;\n            res$$4 = c$$10 !== 0 ? c$$10 : compare(kvp1[1], kvp2[1]);\n          } else {\n            res$$4 = 1;\n          }\n        } else if (matchValue$$7[1]) {\n          res$$4 = -1;\n        } else {\n          finished = true;\n        }\n      }\n\n      return res$$4 | 0;\n    } finally {\n      if (isDisposable(e2)) {\n        e2.Dispose();\n      }\n    }\n  } finally {\n    if (isDisposable(e1)) {\n      e1.Dispose();\n    }\n  }\n};\n\nObject.defineProperty(FSharpMap.prototype, \"size\", {\n  \"get\": function () {\n    const this$$$3 = this;\n    return FSharpMap$$get_Count(this$$$3) | 0;\n  }\n});\n\nFSharpMap.prototype.clear = function () {\n  throw new Error(\"Map cannot be mutated\");\n};\n\nFSharpMap.prototype.delete = function (_arg1$$1) {\n  throw new Error(\"Map cannot be mutated\");\n};\n\nFSharpMap.prototype.entries = function () {\n  const this$$$4 = this;\n  return MapTreeModule$$$toSeq(FSharpMap$$get_Tree(this$$$4));\n};\n\nFSharpMap.prototype.get = function (k$$34) {\n  const this$$$5 = this;\n  return FSharpMap$$get_Item$$2B595(this$$$5, k$$34);\n};\n\nFSharpMap.prototype.has = function (k$$35) {\n  const this$$$6 = this;\n  return FSharpMap$$ContainsKey$$2B595(this$$$6, k$$35);\n};\n\nFSharpMap.prototype.keys = function () {\n  const this$$$7 = this;\n  const source$$1 = MapTreeModule$$$toSeq(FSharpMap$$get_Tree(this$$$7));\n  return map$$2(function mapping$$1(kv$$1) {\n    return kv$$1[0];\n  }, source$$1);\n};\n\nFSharpMap.prototype.set = function (k$$36, v$$26) {\n  throw new Error(\"Map cannot be mutated\");\n};\n\nFSharpMap.prototype.values = function () {\n  const this$$$8 = this;\n  const source$$2 = MapTreeModule$$$toSeq(FSharpMap$$get_Tree(this$$$8));\n  return map$$2(function mapping$$2(kv$$2) {\n    return kv$$2[1];\n  }, source$$2);\n};\n\nexport function isEmpty(m$$23) {\n  return FSharpMap$$get_IsEmpty(m$$23);\n}\nexport function add(k$$37, v$$27, m$$24) {\n  return FSharpMap$$Add$$5BDDA1(m$$24, k$$37, v$$27);\n}\nexport function find(k$$38, m$$25) {\n  return FSharpMap$$get_Item$$2B595(m$$25, k$$38);\n}\nexport function tryFind(k$$39, m$$26) {\n  return FSharpMap$$TryFind$$2B595(m$$26, k$$39);\n}\nexport function remove(k$$40, m$$27) {\n  return FSharpMap$$Remove$$2B595(m$$27, k$$40);\n}\nexport function containsKey(k$$41, m$$28) {\n  return FSharpMap$$ContainsKey$$2B595(m$$28, k$$41);\n}\nexport function iterate(f$$27, m$$29) {\n  FSharpMap$$Iterate$$1DCFB91D(m$$29, f$$27);\n}\nexport function tryPick(f$$28, m$$30) {\n  return FSharpMap$$TryPick$$72321DD7(m$$30, f$$28);\n}\nexport function pick(f$$29, m$$31) {\n  const matchValue$$8 = tryPick(f$$29, m$$31);\n\n  if (matchValue$$8 != null) {\n    const res$$5 = value$$3(matchValue$$8);\n    return res$$5;\n  } else {\n    throw new Error(\"key not found\");\n  }\n}\nexport function exists(f$$30, m$$32) {\n  return FSharpMap$$Exists$$Z395DDC35(m$$32, f$$30);\n}\nexport function filter(f$$31, m$$33) {\n  return FSharpMap$$Filter$$Z395DDC35(m$$33, f$$31);\n}\nexport function partition(f$$32, m$$34) {\n  return FSharpMap$$Partition$$Z395DDC35(m$$34, f$$32);\n}\nexport function forAll(f$$33, m$$35) {\n  return FSharpMap$$ForAll$$Z395DDC35(m$$35, f$$33);\n}\nexport function mapRange(f$$34, m$$36) {\n  return FSharpMap$$MapRange$$6DC7247(m$$36, f$$34);\n}\nexport function map(f$$35, m$$37) {\n  return FSharpMap$$Map$$Z6F6B671C(m$$37, f$$35);\n}\nexport function fold(f$$36, z, m$$38) {\n  return MapTreeModule$$$fold(f$$36, z, FSharpMap$$get_Tree(m$$38));\n}\nexport function foldBack(f$$37, m$$39, z$$1) {\n  return MapTreeModule$$$foldBack(f$$37, FSharpMap$$get_Tree(m$$39), z$$1);\n}\nexport function toSeq(m$$40) {\n  return MapTreeModule$$$toSeq(FSharpMap$$get_Tree(m$$40));\n}\nexport function findKey(f$$38, m$$41) {\n  let _arg1$$2;\n\n  const m$$42 = FSharpMap$$get_Tree(m$$41);\n  _arg1$$2 = MapTreeModule$$$tryPick(function f$$39(k$$42, v$$28) {\n    if (f$$38(k$$42, v$$28)) {\n      return some(k$$42);\n    } else {\n      return null;\n    }\n  }, m$$42);\n\n  if (_arg1$$2 == null) {\n    throw new Error(\"Key not found\");\n  } else {\n    const k$$43 = value$$3(_arg1$$2);\n    return k$$43;\n  }\n}\nexport function tryFindKey(f$$40, m$$43) {\n  const m$$44 = FSharpMap$$get_Tree(m$$43);\n  return MapTreeModule$$$tryPick(function f$$41(k$$44, v$$29) {\n    if (f$$40(k$$44, v$$29)) {\n      return some(k$$44);\n    } else {\n      return null;\n    }\n  }, m$$44);\n}\nexport function ofList(l$$22, comparer$$18) {\n  return FSharpMap$$$$002Ector$$58ADD115(comparer$$18, MapTreeModule$$$ofList(comparer$$18, l$$22));\n}\nexport function ofSeq(l$$23, comparer$$19) {\n  return FSharpMap$$$$002Ector$$58ADD115(comparer$$19, MapTreeModule$$$ofSeq(comparer$$19, l$$23));\n}\nexport function ofArray(array, comparer$$20) {\n  return FSharpMap$$$$002Ector$$58ADD115(comparer$$20, MapTreeModule$$$ofArray(comparer$$20, array));\n}\nexport function toList(m$$45) {\n  return FSharpMap$$ToList(m$$45);\n}\nexport function toArray(m$$46) {\n  let res$$6;\n  const len = FSharpMap$$get_Count(m$$46) | 0;\n  res$$6 = new Array(len);\n  MapTreeModule$$$copyToArray(FSharpMap$$get_Tree(m$$46), res$$6, 0);\n  return res$$6;\n}\nexport function empty(comparer$$21) {\n  return FSharpMap$$$$002Ector$$58ADD115(comparer$$21, new MapTree$00602(0, \"MapEmpty\"));\n}\n\nfunction createMutablePrivate(comparer$$22, tree$0027) {\n  let tree$$1 = tree$0027;\n  return {\n    get size() {\n      return MapTreeModule$$$size(tree$$1);\n    },\n\n    clear() {\n      tree$$1 = new MapTree$00602(0, \"MapEmpty\");\n    },\n\n    delete(x$$18) {\n      if (MapTreeModule$$$mem(comparer$$22, x$$18, tree$$1)) {\n        tree$$1 = MapTreeModule$$$remove(comparer$$22, x$$18, tree$$1);\n        return true;\n      } else {\n        return false;\n      }\n    },\n\n    entries() {\n      return MapTreeModule$$$toSeq(tree$$1);\n    },\n\n    get(k$$45) {\n      return MapTreeModule$$$find(comparer$$22, k$$45, tree$$1);\n    },\n\n    has(x$$19) {\n      return MapTreeModule$$$mem(comparer$$22, x$$19, tree$$1);\n    },\n\n    keys() {\n      const source$$3 = MapTreeModule$$$toSeq(tree$$1);\n      return map$$2(function mapping$$3(kv$$3) {\n        return kv$$3[0];\n      }, source$$3);\n    },\n\n    set(k$$46, v$$30) {\n      const this$$$9 = this;\n      tree$$1 = MapTreeModule$$$add(comparer$$22, k$$46, v$$30, tree$$1);\n      return this$$$9;\n    },\n\n    values() {\n      const source$$4 = MapTreeModule$$$toSeq(tree$$1);\n      return map$$2(function mapping$$4(kv$$4) {\n        return kv$$4[1];\n      }, source$$4);\n    },\n\n    [Symbol.iterator]() {\n      return toIterator(MapTreeModule$$$mkIEnumerator(tree$$1));\n    },\n\n    GetEnumerator() {\n      return MapTreeModule$$$mkIEnumerator(tree$$1);\n    }\n\n  };\n}\n\nexport function createMutable(source$$5, comparer$$23) {\n  const map$$1 = MutableMap$002400602$0024$0024$0024$0024002Ector$0024$00246623D9B3(source$$5, comparer$$23);\n  return map$$1;\n}\nexport function groupBy(projection, xs, comparer$$24) {\n  const dict = createMutable(empty$$1(), comparer$$24);\n  iterate$$1(function (v$$31) {\n    const key = projection(v$$31);\n\n    if (dict.has(key)) {\n      dict.get(key).push(v$$31);\n    } else {\n      const value = dict.set(key, [v$$31]);\n      void value;\n    }\n  }, xs);\n  return map$$2(function mapping$$5(kv$$5) {\n    return [kv$$5[0], kv$$5[1]];\n  }, dict);\n}\nexport function countBy(projection$$1, xs$$1, comparer$$25) {\n  const dict$$1 = createMutable(empty$$1(), comparer$$25);\n  iterate$$1(function (value$$1) {\n    const key$$1 = projection$$1(value$$1);\n    const value$$2 = dict$$1.has(key$$1) ? dict$$1.set(key$$1, dict$$1.get(key$$1) + 1) : dict$$1.set(key$$1, 1);\n    void value$$2;\n  }, xs$$1);\n  return map$$2(function mapping$$6(kv$$6) {\n    return [kv$$6[0], kv$$6[1]];\n  }, dict$$1);\n}\nexport function count(m$$47) {\n  return FSharpMap$$get_Count(m$$47);\n}","import { declare, FSharpRef } from \"./Types\";\nimport { iterateIndexed, toIterator, getEnumerator, delay, collect, map, sumBy, iterate } from \"./Seq\";\nimport { type } from \"./Reflection\";\nimport { getItemFromDict, tryGetValue } from \"./Util\";\nimport { some } from \"./Option\";\nexport const MutableSet$00601 = declare(function Fable_Collections_MutableSet(items, comparer) {\n  const $this$$1 = this;\n  const this$ = new FSharpRef(null);\n  $this$$1.comparer = comparer;\n  this$.contents = $this$$1;\n  $this$$1.hashMap = new Map([]);\n  $this$$1[\"init@21-2\"] = 1;\n  iterate(function (item) {\n    const value = MutableSet$00601$$Add$$2B595(this$.contents, item);\n    void value;\n  }, items);\n});\nexport function MutableSet$00601$reflection($gen$$4) {\n  return type(\"Fable.Collections.MutableSet`1\", [$gen$$4]);\n}\nexport function MutableSet$00601$$$$002Ector$$Z6150332D(items, comparer) {\n  return this instanceof MutableSet$00601 ? MutableSet$00601.call(this, items, comparer) : new MutableSet$00601(items, comparer);\n}\n\nfunction MutableSet$00601$$TryFindIndex$$2B595(this$$$1, k) {\n  const h = this$$$1.comparer.GetHashCode(k) | 0;\n  const matchValue = tryGetValue(this$$$1.hashMap, h, null);\n\n  if (matchValue[0]) {\n    return [true, h, matchValue[1].findIndex(function (v) {\n      return this$$$1.comparer.Equals(k, v);\n    })];\n  } else {\n    return [false, h, -1];\n  }\n}\n\nfunction MutableSet$00601$$TryFind$$2B595(this$$$2, k$$1) {\n  const matchValue$$1 = MutableSet$00601$$TryFindIndex$$2B595(this$$$2, k$$1);\n  var $target$$9;\n\n  if (matchValue$$1[0]) {\n    if (matchValue$$1[2] > -1) {\n      $target$$9 = 0;\n    } else {\n      $target$$9 = 1;\n    }\n  } else {\n    $target$$9 = 1;\n  }\n\n  switch ($target$$9) {\n    case 0:\n      {\n        return some(getItemFromDict(this$$$2.hashMap, matchValue$$1[1])[matchValue$$1[2]]);\n      }\n\n    case 1:\n      {\n        return null;\n      }\n  }\n}\n\nexport function MutableSet$00601$$get_Comparer(this$$$3) {\n  return this$$$3.comparer;\n}\nexport function MutableSet$00601$$Clear(this$$$4) {\n  this$$$4.hashMap.clear();\n}\nexport function MutableSet$00601$$get_Count(this$$$5) {\n  const source = this$$$5.hashMap.values();\n  return sumBy(function projection(pairs) {\n    return pairs.length;\n  }, source, {\n    GetZero() {\n      return 0;\n    },\n\n    Add($x$$2, $y$$3) {\n      return $x$$2 + $y$$3;\n    }\n\n  }) | 0;\n}\nexport function MutableSet$00601$$Add$$2B595(this$$$6, k$$2) {\n  const matchValue$$2 = MutableSet$00601$$TryFindIndex$$2B595(this$$$6, k$$2);\n  var $target$$16;\n\n  if (matchValue$$2[0]) {\n    if (matchValue$$2[2] > -1) {\n      $target$$16 = 0;\n    } else {\n      $target$$16 = 1;\n    }\n  } else {\n    $target$$16 = 1;\n  }\n\n  switch ($target$$16) {\n    case 0:\n      {\n        return false;\n      }\n\n    case 1:\n      {\n        if (matchValue$$2[0]) {\n          const value$$1 = getItemFromDict(this$$$6.hashMap, matchValue$$2[1]).push(k$$2);\n          void null;\n          return true;\n        } else {\n          this$$$6.hashMap.set(matchValue$$2[1], [k$$2]);\n          return true;\n        }\n      }\n  }\n}\nexport function MutableSet$00601$$Contains$$2B595(this$$$7, k$$3) {\n  const matchValue$$3 = MutableSet$00601$$TryFindIndex$$2B595(this$$$7, k$$3);\n  var $target$$19;\n\n  if (matchValue$$3[0]) {\n    if (matchValue$$3[2] > -1) {\n      $target$$19 = 0;\n    } else {\n      $target$$19 = 1;\n    }\n  } else {\n    $target$$19 = 1;\n  }\n\n  switch ($target$$19) {\n    case 0:\n      {\n        return true;\n      }\n\n    case 1:\n      {\n        return false;\n      }\n  }\n}\nexport function MutableSet$00601$$Remove$$2B595(this$$$8, k$$4) {\n  const matchValue$$4 = MutableSet$00601$$TryFindIndex$$2B595(this$$$8, k$$4);\n  var $target$$22;\n\n  if (matchValue$$4[0]) {\n    if (matchValue$$4[2] > -1) {\n      $target$$22 = 0;\n    } else {\n      $target$$22 = 1;\n    }\n  } else {\n    $target$$22 = 1;\n  }\n\n  switch ($target$$22) {\n    case 0:\n      {\n        getItemFromDict(this$$$8.hashMap, matchValue$$4[1]).splice(matchValue$$4[2], 1);\n        return true;\n      }\n\n    case 1:\n      {\n        return false;\n      }\n  }\n}\n\nMutableSet$00601.prototype[Symbol.iterator] = function () {\n  var elems;\n  const this$$$9 = this;\n  return toIterator((elems = delay(function () {\n    return collect(function (values$$1) {\n      return map(function (value$$2) {\n        return value$$2;\n      }, values$$1);\n    }, this$$$9.hashMap.values());\n  }), getEnumerator(elems)));\n};\n\nMutableSet$00601.prototype.Add = function (item$$1) {\n  const this$$$10 = this;\n  const value$$3 = MutableSet$00601$$Add$$2B595(this$$$10, item$$1);\n  void value$$3;\n};\n\nMutableSet$00601.prototype.Clear = function () {\n  const this$$$11 = this;\n  MutableSet$00601$$Clear(this$$$11);\n};\n\nMutableSet$00601.prototype.Contains = function (item$$2) {\n  const this$$$12 = this;\n  return MutableSet$00601$$Contains$$2B595(this$$$12, item$$2);\n};\n\nMutableSet$00601.prototype.CopyTo = function (array, arrayIndex) {\n  const this$$$13 = this;\n  iterateIndexed(function action(i$$8, e) {\n    array[arrayIndex + i$$8] = e;\n  }, this$$$13);\n};\n\nObject.defineProperty(MutableSet$00601.prototype, \"Count\", {\n  \"get\": function () {\n    const this$$$14 = this;\n    return MutableSet$00601$$get_Count(this$$$14) | 0;\n  }\n});\nObject.defineProperty(MutableSet$00601.prototype, \"IsReadOnly\", {\n  \"get\": function () {\n    return false;\n  }\n});\n\nMutableSet$00601.prototype.Remove = function (item$$3) {\n  const this$$$16 = this;\n  return MutableSet$00601$$Remove$$2B595(this$$$16, item$$3);\n};\n\nObject.defineProperty(MutableSet$00601.prototype, \"size\", {\n  \"get\": function () {\n    const this$$$17 = this;\n    return MutableSet$00601$$get_Count(this$$$17) | 0;\n  }\n});\n\nMutableSet$00601.prototype.add = function (k$$5) {\n  const this$$$18 = this;\n  const value$$4 = MutableSet$00601$$Add$$2B595(this$$$18, k$$5);\n  void value$$4;\n  return this$$$18;\n};\n\nMutableSet$00601.prototype.add_ = function (k$$6) {\n  const this$$$19 = this;\n  return MutableSet$00601$$Add$$2B595(this$$$19, k$$6);\n};\n\nMutableSet$00601.prototype.clear = function () {\n  const this$$$20 = this;\n  MutableSet$00601$$Clear(this$$$20);\n};\n\nMutableSet$00601.prototype.delete = function (k$$7) {\n  const this$$$21 = this;\n  return MutableSet$00601$$Remove$$2B595(this$$$21, k$$7);\n};\n\nMutableSet$00601.prototype.has = function (k$$8) {\n  const this$$$22 = this;\n  return MutableSet$00601$$Contains$$2B595(this$$$22, k$$8);\n};\n\nMutableSet$00601.prototype.keys = function () {\n  const this$$$23 = this;\n  return map(function mapping(x) {\n    return x;\n  }, this$$$23);\n};\n\nMutableSet$00601.prototype.values = function () {\n  const this$$$24 = this;\n  return map(function mapping$$1(x$$1) {\n    return x$$1;\n  }, this$$$24);\n};\n\nMutableSet$00601.prototype.entries = function () {\n  const this$$$25 = this;\n  return map(function mapping$$2(v$$1) {\n    return [v$$1, v$$1];\n  }, this$$$25);\n};","import { List, Record, declare, Union } from \"./Types\";\nimport { type, record, bool, list, union as union$$1, int32 } from \"./Reflection\";\nimport { value as value$$2, some, Choice } from \"./Option\";\nimport { iterate as iterate$$1, delay, collect, singleton as singleton$$1, empty as empty$$1, fold as fold$$1, toIterator, map as map$$1, reduce, getEnumerator, unfold } from \"./Seq\";\nimport { structuralHash, isDisposable } from \"./Util\";\nimport { join } from \"./String\";\nimport { MutableSet$00601$$Add$$2B595 as MutableSet$002400601$0024$0024Add$0024$00242B595, MutableSet$00601$$$$002Ector$$Z6150332D as MutableSet$002400601$0024$0024$0024$0024002Ector$0024$0024Z6150332D } from \"./MutableSet\";\nexport const SetTree$00601 = declare(function Set_SetTree(tag, name, ...fields) {\n  Union.call(this, tag, name, ...fields);\n}, Union);\nexport function SetTree$00601$reflection($gen$$3) {\n  return union$$1(\"Set.SetTree`1\", [$gen$$3], SetTree$00601, () => [\"SetEmpty\", [\"SetNode\", [$gen$$3, SetTree$00601$reflection($gen$$3), SetTree$00601$reflection($gen$$3), int32]], [\"SetOne\", [$gen$$3]]]);\n}\nexport function SetTreeModule$$$countAux($s$$4, $acc$$5) {\n  SetTreeModule$$$countAux: while (true) {\n    const s = $s$$4,\n          acc = $acc$$5;\n\n    switch (s.tag) {\n      case 2:\n        {\n          return acc + 1 | 0;\n        }\n\n      case 0:\n        {\n          return acc | 0;\n        }\n\n      default:\n        {\n          $s$$4 = s.fields[1];\n          $acc$$5 = SetTreeModule$$$countAux(s.fields[2], acc + 1);\n          continue SetTreeModule$$$countAux;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$count(s$$1) {\n  return SetTreeModule$$$countAux(s$$1, 0);\n}\nexport function SetTreeModule$$$SetOne(n) {\n  return new SetTree$00601(2, \"SetOne\", n);\n}\nexport function SetTreeModule$$$SetNode(x, l$$1, r$$1, h) {\n  return new SetTree$00601(1, \"SetNode\", x, l$$1, r$$1, h);\n}\nexport function SetTreeModule$$$height(t) {\n  switch (t.tag) {\n    case 2:\n      {\n        return 1;\n      }\n\n    case 1:\n      {\n        return t.fields[3] | 0;\n      }\n\n    default:\n      {\n        return 0;\n      }\n  }\n}\nexport const SetTreeModule$$$tolerance = 2;\nexport function SetTreeModule$$$mk(l$$2, k, r$$2) {\n  var $target$$16;\n\n  if (l$$2.tag === 0) {\n    if (r$$2.tag === 0) {\n      $target$$16 = 0;\n    } else {\n      $target$$16 = 1;\n    }\n  } else {\n    $target$$16 = 1;\n  }\n\n  switch ($target$$16) {\n    case 0:\n      {\n        return SetTreeModule$$$SetOne(k);\n      }\n\n    case 1:\n      {\n        const hl = SetTreeModule$$$height(l$$2) | 0;\n        const hr = SetTreeModule$$$height(r$$2) | 0;\n        const m = (hl < hr ? hr : hl) | 0;\n        return SetTreeModule$$$SetNode(k, l$$2, r$$2, m + 1);\n      }\n  }\n}\nexport function SetTreeModule$$$rebalance(t1, k$$1, t2) {\n  const t1h = SetTreeModule$$$height(t1) | 0;\n  const t2h = SetTreeModule$$$height(t2) | 0;\n\n  if (t2h > t1h + SetTreeModule$$$tolerance) {\n    if (t2.tag === 1) {\n      if (SetTreeModule$$$height(t2.fields[1]) > t1h + 1) {\n        if (t2.fields[1].tag === 1) {\n          return SetTreeModule$$$mk(SetTreeModule$$$mk(t1, k$$1, t2.fields[1].fields[1]), t2.fields[1].fields[0], SetTreeModule$$$mk(t2.fields[1].fields[2], t2.fields[0], t2.fields[2]));\n        } else {\n          throw new Error(\"rebalance\");\n        }\n      } else {\n        return SetTreeModule$$$mk(SetTreeModule$$$mk(t1, k$$1, t2.fields[1]), t2.fields[0], t2.fields[2]);\n      }\n    } else {\n      throw new Error(\"rebalance\");\n    }\n  } else if (t1h > t2h + SetTreeModule$$$tolerance) {\n    if (t1.tag === 1) {\n      if (SetTreeModule$$$height(t1.fields[2]) > t2h + 1) {\n        if (t1.fields[2].tag === 1) {\n          return SetTreeModule$$$mk(SetTreeModule$$$mk(t1.fields[1], t1.fields[0], t1.fields[2].fields[1]), t1.fields[2].fields[0], SetTreeModule$$$mk(t1.fields[2].fields[2], k$$1, t2));\n        } else {\n          throw new Error(\"rebalance\");\n        }\n      } else {\n        return SetTreeModule$$$mk(t1.fields[1], t1.fields[0], SetTreeModule$$$mk(t1.fields[2], k$$1, t2));\n      }\n    } else {\n      throw new Error(\"rebalance\");\n    }\n  } else {\n    return SetTreeModule$$$mk(t1, k$$1, t2);\n  }\n}\nexport function SetTreeModule$$$add(comparer, k$$2, t$$1) {\n  switch (t$$1.tag) {\n    case 2:\n      {\n        const c$$1 = comparer.Compare(k$$2, t$$1.fields[0]) | 0;\n\n        if (c$$1 < 0) {\n          return SetTreeModule$$$SetNode(k$$2, new SetTree$00601(0, \"SetEmpty\"), t$$1, 2);\n        } else if (c$$1 === 0) {\n          return t$$1;\n        } else {\n          return SetTreeModule$$$SetNode(k$$2, t$$1, new SetTree$00601(0, \"SetEmpty\"), 2);\n        }\n      }\n\n    case 0:\n      {\n        return SetTreeModule$$$SetOne(k$$2);\n      }\n\n    default:\n      {\n        const c = comparer.Compare(k$$2, t$$1.fields[0]) | 0;\n\n        if (c < 0) {\n          return SetTreeModule$$$rebalance(SetTreeModule$$$add(comparer, k$$2, t$$1.fields[1]), t$$1.fields[0], t$$1.fields[2]);\n        } else if (c === 0) {\n          return t$$1;\n        } else {\n          return SetTreeModule$$$rebalance(t$$1.fields[1], t$$1.fields[0], SetTreeModule$$$add(comparer, k$$2, t$$1.fields[2]));\n        }\n      }\n  }\n}\nexport function SetTreeModule$$$balance(comparer$$1, t1$$1, k$$3, t2$$1) {\n  var $target$$27, t2$$2, t1$$2, k1, t2$$3, k2$$2, t1$$3, h1, h2, k1$$1, k2$$3, t11, t12, t21, t22;\n\n  if (t1$$1.tag === 2) {\n    if (t2$$1.tag === 0) {\n      $target$$27 = 1;\n      t1$$2 = t1$$1;\n    } else if (t2$$1.tag === 2) {\n      $target$$27 = 2;\n      k1 = t1$$1.fields[0];\n      t2$$3 = t2$$1;\n    } else {\n      $target$$27 = 2;\n      k1 = t1$$1.fields[0];\n      t2$$3 = t2$$1;\n    }\n  } else if (t1$$1.tag === 1) {\n    if (t2$$1.tag === 2) {\n      $target$$27 = 3;\n      k2$$2 = t2$$1.fields[0];\n      t1$$3 = t1$$1;\n    } else if (t2$$1.tag === 1) {\n      $target$$27 = 4;\n      h1 = t1$$1.fields[3];\n      h2 = t2$$1.fields[3];\n      k1$$1 = t1$$1.fields[0];\n      k2$$3 = t2$$1.fields[0];\n      t11 = t1$$1.fields[1];\n      t12 = t1$$1.fields[2];\n      t21 = t2$$1.fields[1];\n      t22 = t2$$1.fields[2];\n    } else {\n      $target$$27 = 1;\n      t1$$2 = t1$$1;\n    }\n  } else {\n    $target$$27 = 0;\n    t2$$2 = t2$$1;\n  }\n\n  switch ($target$$27) {\n    case 0:\n      {\n        return SetTreeModule$$$add(comparer$$1, k$$3, t2$$2);\n      }\n\n    case 1:\n      {\n        return SetTreeModule$$$add(comparer$$1, k$$3, t1$$2);\n      }\n\n    case 2:\n      {\n        return SetTreeModule$$$add(comparer$$1, k$$3, SetTreeModule$$$add(comparer$$1, k1, t2$$3));\n      }\n\n    case 3:\n      {\n        return SetTreeModule$$$add(comparer$$1, k$$3, SetTreeModule$$$add(comparer$$1, k2$$2, t1$$3));\n      }\n\n    case 4:\n      {\n        if (h1 + SetTreeModule$$$tolerance < h2) {\n          return SetTreeModule$$$rebalance(SetTreeModule$$$balance(comparer$$1, t1$$1, k$$3, t21), k2$$3, t22);\n        } else if (h2 + SetTreeModule$$$tolerance < h1) {\n          return SetTreeModule$$$rebalance(t11, k1$$1, SetTreeModule$$$balance(comparer$$1, t12, k$$3, t2$$1));\n        } else {\n          return SetTreeModule$$$mk(t1$$1, k$$3, t2$$1);\n        }\n      }\n  }\n}\nexport function SetTreeModule$$$split(comparer$$2, pivot, t$$2) {\n  switch (t$$2.tag) {\n    case 2:\n      {\n        const c$$3 = comparer$$2.Compare(t$$2.fields[0], pivot) | 0;\n\n        if (c$$3 < 0) {\n          return [t$$2, false, new SetTree$00601(0, \"SetEmpty\")];\n        } else if (c$$3 === 0) {\n          return [new SetTree$00601(0, \"SetEmpty\"), true, new SetTree$00601(0, \"SetEmpty\")];\n        } else {\n          return [new SetTree$00601(0, \"SetEmpty\"), false, t$$2];\n        }\n      }\n\n    case 0:\n      {\n        return [new SetTree$00601(0, \"SetEmpty\"), false, new SetTree$00601(0, \"SetEmpty\")];\n      }\n\n    default:\n      {\n        const c$$2 = comparer$$2.Compare(pivot, t$$2.fields[0]) | 0;\n\n        if (c$$2 < 0) {\n          const patternInput = SetTreeModule$$$split(comparer$$2, pivot, t$$2.fields[1]);\n          return [patternInput[0], patternInput[1], SetTreeModule$$$balance(comparer$$2, patternInput[2], t$$2.fields[0], t$$2.fields[2])];\n        } else if (c$$2 === 0) {\n          return [t$$2.fields[1], true, t$$2.fields[2]];\n        } else {\n          const patternInput$$1 = SetTreeModule$$$split(comparer$$2, pivot, t$$2.fields[2]);\n          return [SetTreeModule$$$balance(comparer$$2, t$$2.fields[1], t$$2.fields[0], patternInput$$1[0]), patternInput$$1[1], patternInput$$1[2]];\n        }\n      }\n  }\n}\nexport function SetTreeModule$$$spliceOutSuccessor(t$$3) {\n  switch (t$$3.tag) {\n    case 2:\n      {\n        return [t$$3.fields[0], new SetTree$00601(0, \"SetEmpty\")];\n      }\n\n    case 1:\n      {\n        if (t$$3.fields[1].tag === 0) {\n          return [t$$3.fields[0], t$$3.fields[2]];\n        } else {\n          const patternInput$$2 = SetTreeModule$$$spliceOutSuccessor(t$$3.fields[1]);\n          return [patternInput$$2[0], SetTreeModule$$$mk(patternInput$$2[1], t$$3.fields[0], t$$3.fields[2])];\n        }\n      }\n\n    default:\n      {\n        throw new Error(\"internal error: Set.spliceOutSuccessor\");\n      }\n  }\n}\nexport function SetTreeModule$$$remove(comparer$$3, k$$4, t$$4) {\n  switch (t$$4.tag) {\n    case 2:\n      {\n        const c$$4 = comparer$$3.Compare(k$$4, t$$4.fields[0]) | 0;\n\n        if (c$$4 === 0) {\n          return new SetTree$00601(0, \"SetEmpty\");\n        } else {\n          return t$$4;\n        }\n      }\n\n    case 1:\n      {\n        const c$$5 = comparer$$3.Compare(k$$4, t$$4.fields[0]) | 0;\n\n        if (c$$5 < 0) {\n          return SetTreeModule$$$rebalance(SetTreeModule$$$remove(comparer$$3, k$$4, t$$4.fields[1]), t$$4.fields[0], t$$4.fields[2]);\n        } else if (c$$5 === 0) {\n          if (t$$4.fields[1].tag === 0) {\n            return t$$4.fields[2];\n          } else if (t$$4.fields[2].tag === 0) {\n            return t$$4.fields[1];\n          } else {\n            const patternInput$$3 = SetTreeModule$$$spliceOutSuccessor(t$$4.fields[2]);\n            return SetTreeModule$$$mk(t$$4.fields[1], patternInput$$3[0], patternInput$$3[1]);\n          }\n        } else {\n          return SetTreeModule$$$rebalance(t$$4.fields[1], t$$4.fields[0], SetTreeModule$$$remove(comparer$$3, k$$4, t$$4.fields[2]));\n        }\n      }\n\n    default:\n      {\n        return t$$4;\n      }\n  }\n}\nexport function SetTreeModule$$$mem($comparer$$4$$35, $k$$5$$36, $t$$5$$37) {\n  SetTreeModule$$$mem: while (true) {\n    const comparer$$4 = $comparer$$4$$35,\n          k$$5 = $k$$5$$36,\n          t$$5 = $t$$5$$37;\n\n    switch (t$$5.tag) {\n      case 2:\n        {\n          return comparer$$4.Compare(k$$5, t$$5.fields[0]) === 0;\n        }\n\n      case 0:\n        {\n          return false;\n        }\n\n      default:\n        {\n          const c$$6 = comparer$$4.Compare(k$$5, t$$5.fields[0]) | 0;\n\n          if (c$$6 < 0) {\n            $comparer$$4$$35 = comparer$$4;\n            $k$$5$$36 = k$$5;\n            $t$$5$$37 = t$$5.fields[1];\n            continue SetTreeModule$$$mem;\n          } else if (c$$6 === 0) {\n            return true;\n          } else {\n            $comparer$$4$$35 = comparer$$4;\n            $k$$5$$36 = k$$5;\n            $t$$5$$37 = t$$5.fields[2];\n            continue SetTreeModule$$$mem;\n          }\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$iter($f$$38, $t$$6$$39) {\n  SetTreeModule$$$iter: while (true) {\n    const f = $f$$38,\n          t$$6 = $t$$6$$39;\n\n    switch (t$$6.tag) {\n      case 2:\n        {\n          f(t$$6.fields[0]);\n          break;\n        }\n\n      case 0:\n        {\n          break;\n        }\n\n      default:\n        {\n          SetTreeModule$$$iter(f, t$$6.fields[1]);\n          f(t$$6.fields[0]);\n          $f$$38 = f;\n          $t$$6$$39 = t$$6.fields[2];\n          continue SetTreeModule$$$iter;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$foldBack($f$$1$$40, $m$$1$$41, $x$$1$$42) {\n  SetTreeModule$$$foldBack: while (true) {\n    const f$$1 = $f$$1$$40,\n          m$$1 = $m$$1$$41,\n          x$$1 = $x$$1$$42;\n\n    switch (m$$1.tag) {\n      case 2:\n        {\n          return f$$1(m$$1.fields[0], x$$1);\n        }\n\n      case 0:\n        {\n          return x$$1;\n        }\n\n      default:\n        {\n          $f$$1$$40 = f$$1;\n          $m$$1$$41 = m$$1.fields[1];\n          $x$$1$$42 = f$$1(m$$1.fields[0], SetTreeModule$$$foldBack(f$$1, m$$1.fields[2], x$$1));\n          continue SetTreeModule$$$foldBack;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$fold($f$$2$$43, $x$$2$$44, $m$$2$$45) {\n  SetTreeModule$$$fold: while (true) {\n    const f$$2 = $f$$2$$43,\n          x$$2 = $x$$2$$44,\n          m$$2 = $m$$2$$45;\n\n    switch (m$$2.tag) {\n      case 2:\n        {\n          return f$$2(x$$2, m$$2.fields[0]);\n        }\n\n      case 0:\n        {\n          return x$$2;\n        }\n\n      default:\n        {\n          const x$$3 = SetTreeModule$$$fold(f$$2, x$$2, m$$2.fields[1]);\n          const x$$4 = f$$2(x$$3, m$$2.fields[0]);\n          $f$$2$$43 = f$$2;\n          $x$$2$$44 = x$$4;\n          $m$$2$$45 = m$$2.fields[2];\n          continue SetTreeModule$$$fold;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$forall($f$$3$$46, $m$$3$$47) {\n  SetTreeModule$$$forall: while (true) {\n    const f$$3 = $f$$3$$46,\n          m$$3 = $m$$3$$47;\n\n    switch (m$$3.tag) {\n      case 2:\n        {\n          return f$$3(m$$3.fields[0]);\n        }\n\n      case 0:\n        {\n          return true;\n        }\n\n      default:\n        {\n          if (f$$3(m$$3.fields[0]) ? SetTreeModule$$$forall(f$$3, m$$3.fields[1]) : false) {\n            $f$$3$$46 = f$$3;\n            $m$$3$$47 = m$$3.fields[2];\n            continue SetTreeModule$$$forall;\n          } else {\n            return false;\n          }\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$exists($f$$4$$48, $m$$4$$49) {\n  SetTreeModule$$$exists: while (true) {\n    const f$$4 = $f$$4$$48,\n          m$$4 = $m$$4$$49;\n\n    switch (m$$4.tag) {\n      case 2:\n        {\n          return f$$4(m$$4.fields[0]);\n        }\n\n      case 0:\n        {\n          return false;\n        }\n\n      default:\n        {\n          if (f$$4(m$$4.fields[0]) ? true : SetTreeModule$$$exists(f$$4, m$$4.fields[1])) {\n            return true;\n          } else {\n            $f$$4$$48 = f$$4;\n            $m$$4$$49 = m$$4.fields[2];\n            continue SetTreeModule$$$exists;\n          }\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$isEmpty(m$$5) {\n  if (m$$5.tag === 0) {\n    return true;\n  } else {\n    return false;\n  }\n}\nexport function SetTreeModule$$$subset(comparer$$5, a, b) {\n  return SetTreeModule$$$forall(function (x$$5) {\n    return SetTreeModule$$$mem(comparer$$5, x$$5, b);\n  }, a);\n}\nexport function SetTreeModule$$$psubset(comparer$$6, a$$1, b$$1) {\n  if (SetTreeModule$$$forall(function (x$$6) {\n    return SetTreeModule$$$mem(comparer$$6, x$$6, b$$1);\n  }, a$$1)) {\n    return SetTreeModule$$$exists(function (x$$7) {\n      return !SetTreeModule$$$mem(comparer$$6, x$$7, a$$1);\n    }, b$$1);\n  } else {\n    return false;\n  }\n}\nexport function SetTreeModule$$$filterAux($comparer$$7$$57, $f$$5$$58, $s$$2$$59, $acc$$1$$60) {\n  SetTreeModule$$$filterAux: while (true) {\n    const comparer$$7 = $comparer$$7$$57,\n          f$$5 = $f$$5$$58,\n          s$$2 = $s$$2$$59,\n          acc$$1 = $acc$$1$$60;\n\n    switch (s$$2.tag) {\n      case 2:\n        {\n          if (f$$5(s$$2.fields[0])) {\n            return SetTreeModule$$$add(comparer$$7, s$$2.fields[0], acc$$1);\n          } else {\n            return acc$$1;\n          }\n        }\n\n      case 0:\n        {\n          return acc$$1;\n        }\n\n      default:\n        {\n          const acc$$2 = f$$5(s$$2.fields[0]) ? SetTreeModule$$$add(comparer$$7, s$$2.fields[0], acc$$1) : acc$$1;\n          $comparer$$7$$57 = comparer$$7;\n          $f$$5$$58 = f$$5;\n          $s$$2$$59 = s$$2.fields[1];\n          $acc$$1$$60 = SetTreeModule$$$filterAux(comparer$$7, f$$5, s$$2.fields[2], acc$$2);\n          continue SetTreeModule$$$filterAux;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$filter(comparer$$8, f$$6, s$$3) {\n  return SetTreeModule$$$filterAux(comparer$$8, f$$6, s$$3, new SetTree$00601(0, \"SetEmpty\"));\n}\nexport function SetTreeModule$$$diffAux($comparer$$9$$64, $m$$6$$65, $acc$$3$$66) {\n  SetTreeModule$$$diffAux: while (true) {\n    const comparer$$9 = $comparer$$9$$64,\n          m$$6 = $m$$6$$65,\n          acc$$3 = $acc$$3$$66;\n\n    switch (m$$6.tag) {\n      case 2:\n        {\n          return SetTreeModule$$$remove(comparer$$9, m$$6.fields[0], acc$$3);\n        }\n\n      case 0:\n        {\n          return acc$$3;\n        }\n\n      default:\n        {\n          $comparer$$9$$64 = comparer$$9;\n          $m$$6$$65 = m$$6.fields[1];\n          $acc$$3$$66 = SetTreeModule$$$diffAux(comparer$$9, m$$6.fields[2], SetTreeModule$$$remove(comparer$$9, m$$6.fields[0], acc$$3));\n          continue SetTreeModule$$$diffAux;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$diff(comparer$$10, a$$2, b$$2) {\n  return SetTreeModule$$$diffAux(comparer$$10, b$$2, a$$2);\n}\nexport function SetTreeModule$$$union(comparer$$11, t1$$4, t2$$4) {\n  var $target$$73, h1$$1, h2$$1, k1$$4, k2$$16, t11$$2, t12$$2, t21$$1, t22$$1, t$$7, t$$8, k1$$5, t2$$5, k2$$17, t1$$5;\n\n  if (t1$$4.tag === 0) {\n    $target$$73 = 1;\n    t$$7 = t2$$4;\n  } else if (t1$$4.tag === 2) {\n    if (t2$$4.tag === 0) {\n      $target$$73 = 2;\n      t$$8 = t1$$4;\n    } else if (t2$$4.tag === 2) {\n      $target$$73 = 3;\n      k1$$5 = t1$$4.fields[0];\n      t2$$5 = t2$$4;\n    } else {\n      $target$$73 = 3;\n      k1$$5 = t1$$4.fields[0];\n      t2$$5 = t2$$4;\n    }\n  } else if (t2$$4.tag === 0) {\n    $target$$73 = 2;\n    t$$8 = t1$$4;\n  } else if (t2$$4.tag === 2) {\n    $target$$73 = 4;\n    k2$$17 = t2$$4.fields[0];\n    t1$$5 = t1$$4;\n  } else {\n    $target$$73 = 0;\n    h1$$1 = t1$$4.fields[3];\n    h2$$1 = t2$$4.fields[3];\n    k1$$4 = t1$$4.fields[0];\n    k2$$16 = t2$$4.fields[0];\n    t11$$2 = t1$$4.fields[1];\n    t12$$2 = t1$$4.fields[2];\n    t21$$1 = t2$$4.fields[1];\n    t22$$1 = t2$$4.fields[2];\n  }\n\n  switch ($target$$73) {\n    case 0:\n      {\n        if (h1$$1 > h2$$1) {\n          const patternInput$$4 = SetTreeModule$$$split(comparer$$11, k1$$4, t2$$4);\n          return SetTreeModule$$$balance(comparer$$11, SetTreeModule$$$union(comparer$$11, t11$$2, patternInput$$4[0]), k1$$4, SetTreeModule$$$union(comparer$$11, t12$$2, patternInput$$4[2]));\n        } else {\n          const patternInput$$5 = SetTreeModule$$$split(comparer$$11, k2$$16, t1$$4);\n          return SetTreeModule$$$balance(comparer$$11, SetTreeModule$$$union(comparer$$11, t21$$1, patternInput$$5[0]), k2$$16, SetTreeModule$$$union(comparer$$11, t22$$1, patternInput$$5[2]));\n        }\n      }\n\n    case 1:\n      {\n        return t$$7;\n      }\n\n    case 2:\n      {\n        return t$$8;\n      }\n\n    case 3:\n      {\n        return SetTreeModule$$$add(comparer$$11, k1$$5, t2$$5);\n      }\n\n    case 4:\n      {\n        return SetTreeModule$$$add(comparer$$11, k2$$17, t1$$5);\n      }\n  }\n}\nexport function SetTreeModule$$$intersectionAux($comparer$$12$$74, $b$$3$$75, $m$$7$$76, $acc$$4$$77) {\n  SetTreeModule$$$intersectionAux: while (true) {\n    const comparer$$12 = $comparer$$12$$74,\n          b$$3 = $b$$3$$75,\n          m$$7 = $m$$7$$76,\n          acc$$4 = $acc$$4$$77;\n\n    switch (m$$7.tag) {\n      case 2:\n        {\n          if (SetTreeModule$$$mem(comparer$$12, m$$7.fields[0], b$$3)) {\n            return SetTreeModule$$$add(comparer$$12, m$$7.fields[0], acc$$4);\n          } else {\n            return acc$$4;\n          }\n        }\n\n      case 0:\n        {\n          return acc$$4;\n        }\n\n      default:\n        {\n          const acc$$5 = SetTreeModule$$$intersectionAux(comparer$$12, b$$3, m$$7.fields[2], acc$$4);\n          const acc$$6 = SetTreeModule$$$mem(comparer$$12, m$$7.fields[0], b$$3) ? SetTreeModule$$$add(comparer$$12, m$$7.fields[0], acc$$5) : acc$$5;\n          $comparer$$12$$74 = comparer$$12;\n          $b$$3$$75 = b$$3;\n          $m$$7$$76 = m$$7.fields[1];\n          $acc$$4$$77 = acc$$6;\n          continue SetTreeModule$$$intersectionAux;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$intersection(comparer$$13, a$$3, b$$4) {\n  return SetTreeModule$$$intersectionAux(comparer$$13, b$$4, a$$3, new SetTree$00601(0, \"SetEmpty\"));\n}\nexport function SetTreeModule$$$partition1(comparer$$14, f$$7, k$$16, acc1, acc2) {\n  if (f$$7(k$$16)) {\n    return [SetTreeModule$$$add(comparer$$14, k$$16, acc1), acc2];\n  } else {\n    return [acc1, SetTreeModule$$$add(comparer$$14, k$$16, acc2)];\n  }\n}\nexport function SetTreeModule$$$partitionAux($comparer$$15$$86, $f$$8$$87, $s$$4$$88, $acc_0$$89, $acc_1$$90) {\n  SetTreeModule$$$partitionAux: while (true) {\n    const comparer$$15 = $comparer$$15$$86,\n          f$$8 = $f$$8$$87,\n          s$$4 = $s$$4$$88,\n          acc_0 = $acc_0$$89,\n          acc_1 = $acc_1$$90;\n\n    switch (s$$4.tag) {\n      case 2:\n        {\n          return SetTreeModule$$$partition1(comparer$$15, f$$8, s$$4.fields[0], acc_0, acc_1);\n        }\n\n      case 0:\n        {\n          return [acc_0, acc_1];\n        }\n\n      default:\n        {\n          const acc$$8 = SetTreeModule$$$partitionAux(comparer$$15, f$$8, s$$4.fields[2], acc_0, acc_1);\n          const acc$$9 = SetTreeModule$$$partition1(comparer$$15, f$$8, s$$4.fields[0], acc$$8[0], acc$$8[1]);\n          $comparer$$15$$86 = comparer$$15;\n          $f$$8$$87 = f$$8;\n          $s$$4$$88 = s$$4.fields[1];\n          $acc_0$$89 = acc$$9[0];\n          $acc_1$$90 = acc$$9[1];\n          continue SetTreeModule$$$partitionAux;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$partition(comparer$$16, f$$9, s$$5) {\n  const seed = [new SetTree$00601(0, \"SetEmpty\"), new SetTree$00601(0, \"SetEmpty\")];\n  return SetTreeModule$$$partitionAux(comparer$$16, f$$9, s$$5, seed[0], seed[1]);\n}\nexport function SetTreeModule$$$$007CMatchSetNode$007CMatchSetEmpty$007C(s$$6) {\n  switch (s$$6.tag) {\n    case 2:\n      {\n        return new Choice(0, \"Choice1Of2\", [s$$6.fields[0], new SetTree$00601(0, \"SetEmpty\"), new SetTree$00601(0, \"SetEmpty\")]);\n      }\n\n    case 0:\n      {\n        return new Choice(1, \"Choice2Of2\", null);\n      }\n\n    default:\n      {\n        return new Choice(0, \"Choice1Of2\", [s$$6.fields[0], s$$6.fields[1], s$$6.fields[2]]);\n      }\n  }\n}\nexport function SetTreeModule$$$minimumElementAux($s$$7$$95, $n$$1$$96) {\n  SetTreeModule$$$minimumElementAux: while (true) {\n    const s$$7 = $s$$7$$95,\n          n$$1 = $n$$1$$96;\n\n    switch (s$$7.tag) {\n      case 2:\n        {\n          return s$$7.fields[0];\n        }\n\n      case 0:\n        {\n          return n$$1;\n        }\n\n      default:\n        {\n          $s$$7$$95 = s$$7.fields[1];\n          $n$$1$$96 = s$$7.fields[0];\n          continue SetTreeModule$$$minimumElementAux;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$minimumElementOpt(s$$8) {\n  switch (s$$8.tag) {\n    case 2:\n      {\n        return some(s$$8.fields[0]);\n      }\n\n    case 0:\n      {\n        return null;\n      }\n\n    default:\n      {\n        return some(SetTreeModule$$$minimumElementAux(s$$8.fields[1], s$$8.fields[0]));\n      }\n  }\n}\nexport function SetTreeModule$$$maximumElementAux($s$$9$$98, $n$$2$$99) {\n  SetTreeModule$$$maximumElementAux: while (true) {\n    const s$$9 = $s$$9$$98,\n          n$$2 = $n$$2$$99;\n\n    switch (s$$9.tag) {\n      case 2:\n        {\n          return s$$9.fields[0];\n        }\n\n      case 0:\n        {\n          return n$$2;\n        }\n\n      default:\n        {\n          $s$$9$$98 = s$$9.fields[2];\n          $n$$2$$99 = s$$9.fields[0];\n          continue SetTreeModule$$$maximumElementAux;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$maximumElementOpt(s$$10) {\n  switch (s$$10.tag) {\n    case 2:\n      {\n        return some(s$$10.fields[0]);\n      }\n\n    case 0:\n      {\n        return null;\n      }\n\n    default:\n      {\n        return some(SetTreeModule$$$maximumElementAux(s$$10.fields[2], s$$10.fields[0]));\n      }\n  }\n}\nexport function SetTreeModule$$$minimumElement(s$$11) {\n  const matchValue$$4 = SetTreeModule$$$minimumElementOpt(s$$11);\n\n  if (matchValue$$4 == null) {\n    throw new Error(\"Set contains no elements\");\n  } else {\n    const k$$27 = value$$2(matchValue$$4);\n    return k$$27;\n  }\n}\nexport function SetTreeModule$$$maximumElement(s$$12) {\n  const matchValue$$5 = SetTreeModule$$$maximumElementOpt(s$$12);\n\n  if (matchValue$$5 == null) {\n    throw new Error(\"Set contains no elements\");\n  } else {\n    const k$$28 = value$$2(matchValue$$5);\n    return k$$28;\n  }\n}\nexport const SetTreeModule$002ESetIterator$00601 = declare(function Set_SetTreeModule_SetIterator(arg1, arg2) {\n  this.stack = arg1;\n  this.started = arg2;\n}, Record);\nexport function SetTreeModule$002ESetIterator$00601$reflection($gen$$103) {\n  return record(\"Set.SetTreeModule.SetIterator`1\", [$gen$$103], SetTreeModule$002ESetIterator$00601, () => [[\"stack\", list(SetTree$00601$reflection($gen$$103))], [\"started\", bool]]);\n}\nexport function SetTreeModule$$$collapseLHS($stack$$104) {\n  SetTreeModule$$$collapseLHS: while (true) {\n    const stack = $stack$$104;\n\n    if (stack.tail != null) {\n      if (stack.head.tag === 2) {\n        return stack;\n      } else if (stack.head.tag === 1) {\n        $stack$$104 = new List(stack.head.fields[1], new List(SetTreeModule$$$SetOne(stack.head.fields[0]), new List(stack.head.fields[2], stack.tail)));\n        continue SetTreeModule$$$collapseLHS;\n      } else {\n        $stack$$104 = stack.tail;\n        continue SetTreeModule$$$collapseLHS;\n      }\n    } else {\n      return new List();\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$mkIterator(s$$13) {\n  return new SetTreeModule$002ESetIterator$00601(SetTreeModule$$$collapseLHS(new List(s$$13, new List())), false);\n}\nexport function SetTreeModule$$$notStarted() {\n  throw new Error(\"Enumeration not started\");\n}\nexport function SetTreeModule$$$alreadyFinished() {\n  throw new Error(\"Enumeration already started\");\n}\nexport function SetTreeModule$$$current(i) {\n  if (i.started) {\n    const matchValue$$6 = i.stack;\n\n    if (matchValue$$6.tail == null) {\n      return SetTreeModule$$$alreadyFinished();\n    } else if (matchValue$$6.head.tag === 2) {\n      return matchValue$$6.head.fields[0];\n    } else {\n      throw new Error(\"Please report error: Set iterator, unexpected stack for current\");\n    }\n  } else {\n    return SetTreeModule$$$notStarted();\n  }\n}\nexport function SetTreeModule$$$moveNext(i$$1) {\n  if (i$$1.started) {\n    const matchValue$$7 = i$$1.stack;\n\n    if (matchValue$$7.tail == null) {\n      return false;\n    } else if (matchValue$$7.head.tag === 2) {\n      i$$1.stack = SetTreeModule$$$collapseLHS(matchValue$$7.tail);\n      return !(i$$1.stack.tail == null);\n    } else {\n      throw new Error(\"Please report error: Set iterator, unexpected stack for moveNext\");\n    }\n  } else {\n    i$$1.started = true;\n    return !(i$$1.stack.tail == null);\n  }\n}\nexport const SetTreeModule$002EmkIEnumerator$00601 = declare(function Set_SetTreeModule_mkIEnumerator(s$$14) {\n  const $this$$1 = this;\n  $this$$1.s = s$$14;\n  $this$$1.i = SetTreeModule$$$mkIterator($this$$1.s);\n});\nexport function SetTreeModule$002EmkIEnumerator$00601$reflection($gen$$108) {\n  return type(\"Set.SetTreeModule.mkIEnumerator`1\", [$gen$$108]);\n}\nexport function SetTreeModule$002EmkIEnumerator$00601$$$$002Ector$$Z5B395D56(s$$14) {\n  return this instanceof SetTreeModule$002EmkIEnumerator$00601 ? SetTreeModule$002EmkIEnumerator$00601.call(this, s$$14) : new SetTreeModule$002EmkIEnumerator$00601(s$$14);\n}\nObject.defineProperty(SetTreeModule$002EmkIEnumerator$00601.prototype, \"Current\", {\n  \"get\": function () {\n    const __ = this;\n\n    return SetTreeModule$$$current(__.i);\n  }\n});\n\nSetTreeModule$002EmkIEnumerator$00601.prototype.MoveNext = function () {\n  const __$$1 = this;\n\n  return SetTreeModule$$$moveNext(__$$1.i);\n};\n\nSetTreeModule$002EmkIEnumerator$00601.prototype.Reset = function () {\n  const __$$2 = this;\n\n  __$$2.i = SetTreeModule$$$mkIterator(__$$2.s);\n};\n\nSetTreeModule$002EmkIEnumerator$00601.prototype.Dispose = function () {};\n\nexport function SetTreeModule$$$mkIEnumerator(s$$15) {\n  return SetTreeModule$002EmkIEnumerator$00601$$$$002Ector$$Z5B395D56(s$$15);\n}\nexport function SetTreeModule$$$toSeq(s$$16) {\n  const en = SetTreeModule$$$mkIEnumerator(s$$16);\n  return unfold(function generator(en$$1) {\n    if (en$$1.MoveNext()) {\n      return [en$$1.Current, en$$1];\n    } else {\n      return null;\n    }\n  }, en);\n}\nexport function SetTreeModule$$$compareStacks($comparer$$17$$112, $l1$$113, $l2$$114) {\n  SetTreeModule$$$compareStacks: while (true) {\n    const comparer$$17 = $comparer$$17$$112,\n          l1 = $l1$$113,\n          l2 = $l2$$114;\n    var $target$$115, t1$$6, t2$$6, n1k, n2k, t1$$7, t2$$7, n1k$$1, n2k$$1, n2r, t1$$8, t2$$8, emp, n1k$$2, n1r, n2k$$2, t1$$9, t2$$9, n1k$$3, n1r$$1, n2k$$3, n2r$$1, t1$$10, t2$$10, n1k$$4, t1$$11, n1k$$5, n1l, n1r$$2, t1$$12, n2k$$4, t2$$11, n2k$$5, n2l, n2r$$2, t2$$12;\n\n    if (l1.tail != null) {\n      if (l2.tail != null) {\n        if (l2.head.tag === 2) {\n          if (l1.head.tag === 2) {\n            $target$$115 = 4;\n            n1k = l1.head.fields[0];\n            n2k = l2.head.fields[0];\n            t1$$7 = l1.tail;\n            t2$$7 = l2.tail;\n          } else if (l1.head.tag === 1) {\n            if (l1.head.fields[1].tag === 0) {\n              $target$$115 = 6;\n              emp = l1.head.fields[1];\n              n1k$$2 = l1.head.fields[0];\n              n1r = l1.head.fields[2];\n              n2k$$2 = l2.head.fields[0];\n              t1$$9 = l1.tail;\n              t2$$9 = l2.tail;\n            } else {\n              $target$$115 = 9;\n              n1k$$5 = l1.head.fields[0];\n              n1l = l1.head.fields[1];\n              n1r$$2 = l1.head.fields[2];\n              t1$$12 = l1.tail;\n            }\n          } else {\n            $target$$115 = 10;\n            n2k$$4 = l2.head.fields[0];\n            t2$$11 = l2.tail;\n          }\n        } else if (l2.head.tag === 1) {\n          if (l2.head.fields[1].tag === 0) {\n            if (l1.head.tag === 2) {\n              $target$$115 = 5;\n              n1k$$1 = l1.head.fields[0];\n              n2k$$1 = l2.head.fields[0];\n              n2r = l2.head.fields[2];\n              t1$$8 = l1.tail;\n              t2$$8 = l2.tail;\n            } else if (l1.head.tag === 1) {\n              if (l1.head.fields[1].tag === 0) {\n                $target$$115 = 7;\n                n1k$$3 = l1.head.fields[0];\n                n1r$$1 = l1.head.fields[2];\n                n2k$$3 = l2.head.fields[0];\n                n2r$$1 = l2.head.fields[2];\n                t1$$10 = l1.tail;\n                t2$$10 = l2.tail;\n              } else {\n                $target$$115 = 9;\n                n1k$$5 = l1.head.fields[0];\n                n1l = l1.head.fields[1];\n                n1r$$2 = l1.head.fields[2];\n                t1$$12 = l1.tail;\n              }\n            } else {\n              $target$$115 = 11;\n              n2k$$5 = l2.head.fields[0];\n              n2l = l2.head.fields[1];\n              n2r$$2 = l2.head.fields[2];\n              t2$$12 = l2.tail;\n            }\n          } else if (l1.head.tag === 2) {\n            $target$$115 = 8;\n            n1k$$4 = l1.head.fields[0];\n            t1$$11 = l1.tail;\n          } else if (l1.head.tag === 1) {\n            $target$$115 = 9;\n            n1k$$5 = l1.head.fields[0];\n            n1l = l1.head.fields[1];\n            n1r$$2 = l1.head.fields[2];\n            t1$$12 = l1.tail;\n          } else {\n            $target$$115 = 11;\n            n2k$$5 = l2.head.fields[0];\n            n2l = l2.head.fields[1];\n            n2r$$2 = l2.head.fields[2];\n            t2$$12 = l2.tail;\n          }\n        } else if (l1.head.tag === 2) {\n          $target$$115 = 8;\n          n1k$$4 = l1.head.fields[0];\n          t1$$11 = l1.tail;\n        } else if (l1.head.tag === 1) {\n          $target$$115 = 9;\n          n1k$$5 = l1.head.fields[0];\n          n1l = l1.head.fields[1];\n          n1r$$2 = l1.head.fields[2];\n          t1$$12 = l1.tail;\n        } else {\n          $target$$115 = 3;\n          t1$$6 = l1.tail;\n          t2$$6 = l2.tail;\n        }\n      } else {\n        $target$$115 = 2;\n      }\n    } else if (l2.tail != null) {\n      $target$$115 = 1;\n    } else {\n      $target$$115 = 0;\n    }\n\n    switch ($target$$115) {\n      case 0:\n        {\n          return 0;\n        }\n\n      case 1:\n        {\n          return -1 | 0;\n        }\n\n      case 2:\n        {\n          return 1;\n        }\n\n      case 3:\n        {\n          $comparer$$17$$112 = comparer$$17;\n          $l1$$113 = t1$$6;\n          $l2$$114 = t2$$6;\n          continue SetTreeModule$$$compareStacks;\n        }\n\n      case 4:\n        {\n          const c$$7 = comparer$$17.Compare(n1k, n2k) | 0;\n\n          if (c$$7 !== 0) {\n            return c$$7 | 0;\n          } else {\n            $comparer$$17$$112 = comparer$$17;\n            $l1$$113 = t1$$7;\n            $l2$$114 = t2$$7;\n            continue SetTreeModule$$$compareStacks;\n          }\n        }\n\n      case 5:\n        {\n          const c$$8 = comparer$$17.Compare(n1k$$1, n2k$$1) | 0;\n\n          if (c$$8 !== 0) {\n            return c$$8 | 0;\n          } else {\n            $comparer$$17$$112 = comparer$$17;\n            $l1$$113 = new List(new SetTree$00601(0, \"SetEmpty\"), t1$$8);\n            $l2$$114 = new List(n2r, t2$$8);\n            continue SetTreeModule$$$compareStacks;\n          }\n        }\n\n      case 6:\n        {\n          const c$$9 = comparer$$17.Compare(n1k$$2, n2k$$2) | 0;\n\n          if (c$$9 !== 0) {\n            return c$$9 | 0;\n          } else {\n            $comparer$$17$$112 = comparer$$17;\n            $l1$$113 = new List(n1r, t1$$9);\n            $l2$$114 = new List(emp, t2$$9);\n            continue SetTreeModule$$$compareStacks;\n          }\n        }\n\n      case 7:\n        {\n          const c$$10 = comparer$$17.Compare(n1k$$3, n2k$$3) | 0;\n\n          if (c$$10 !== 0) {\n            return c$$10 | 0;\n          } else {\n            $comparer$$17$$112 = comparer$$17;\n            $l1$$113 = new List(n1r$$1, t1$$10);\n            $l2$$114 = new List(n2r$$1, t2$$10);\n            continue SetTreeModule$$$compareStacks;\n          }\n        }\n\n      case 8:\n        {\n          $comparer$$17$$112 = comparer$$17;\n          $l1$$113 = new List(new SetTree$00601(0, \"SetEmpty\"), new List(SetTreeModule$$$SetOne(n1k$$4), t1$$11));\n          $l2$$114 = l2;\n          continue SetTreeModule$$$compareStacks;\n        }\n\n      case 9:\n        {\n          $comparer$$17$$112 = comparer$$17;\n          $l1$$113 = new List(n1l, new List(SetTreeModule$$$SetNode(n1k$$5, new SetTree$00601(0, \"SetEmpty\"), n1r$$2, 0), t1$$12));\n          $l2$$114 = l2;\n          continue SetTreeModule$$$compareStacks;\n        }\n\n      case 10:\n        {\n          $comparer$$17$$112 = comparer$$17;\n          $l1$$113 = l1;\n          $l2$$114 = new List(new SetTree$00601(0, \"SetEmpty\"), new List(SetTreeModule$$$SetOne(n2k$$4), t2$$11));\n          continue SetTreeModule$$$compareStacks;\n        }\n\n      case 11:\n        {\n          $comparer$$17$$112 = comparer$$17;\n          $l1$$113 = l1;\n          $l2$$114 = new List(n2l, new List(SetTreeModule$$$SetNode(n2k$$5, new SetTree$00601(0, \"SetEmpty\"), n2r$$2, 0), t2$$12));\n          continue SetTreeModule$$$compareStacks;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$compare(comparer$$18, s1, s2) {\n  if (s1.tag === 0) {\n    if (s2.tag === 0) {\n      return 0;\n    } else {\n      return -1 | 0;\n    }\n  } else if (s2.tag === 0) {\n    return 1;\n  } else {\n    return SetTreeModule$$$compareStacks(comparer$$18, new List(s1, new List()), new List(s2, new List())) | 0;\n  }\n}\nexport function SetTreeModule$$$choose(s$$17) {\n  return SetTreeModule$$$minimumElement(s$$17);\n}\nexport function SetTreeModule$$$loop($m$$8$$120, $acc$$10$$121) {\n  SetTreeModule$$$loop: while (true) {\n    const m$$8 = $m$$8$$120,\n          acc$$10 = $acc$$10$$121;\n\n    switch (m$$8.tag) {\n      case 2:\n        {\n          return new List(m$$8.fields[0], acc$$10);\n        }\n\n      case 0:\n        {\n          return acc$$10;\n        }\n\n      default:\n        {\n          $m$$8$$120 = m$$8.fields[1];\n          $acc$$10$$121 = new List(m$$8.fields[0], SetTreeModule$$$loop(m$$8.fields[2], acc$$10));\n          continue SetTreeModule$$$loop;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$toList(s$$18) {\n  return SetTreeModule$$$loop(s$$18, new List());\n}\nexport function SetTreeModule$$$copyToArray(s$$19, arr, i$$2) {\n  let j = i$$2 | 0;\n  SetTreeModule$$$iter(function (x$$8) {\n    arr[j] = x$$8;\n    j = j + 1;\n  }, s$$19);\n}\nexport function SetTreeModule$$$mkFromEnumerator($comparer$$19$$126, $acc$$11$$127, $e$$128) {\n  SetTreeModule$$$mkFromEnumerator: while (true) {\n    const comparer$$19 = $comparer$$19$$126,\n          acc$$11 = $acc$$11$$127,\n          e = $e$$128;\n\n    if (e.MoveNext()) {\n      $comparer$$19$$126 = comparer$$19;\n      $acc$$11$$127 = SetTreeModule$$$add(comparer$$19, e.Current, acc$$11);\n      $e$$128 = e;\n      continue SetTreeModule$$$mkFromEnumerator;\n    } else {\n      return acc$$11;\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$ofSeq(comparer$$20, c$$11) {\n  const ie = getEnumerator(c$$11);\n\n  try {\n    return SetTreeModule$$$mkFromEnumerator(comparer$$20, new SetTree$00601(0, \"SetEmpty\"), ie);\n  } finally {\n    if (isDisposable(ie)) {\n      ie.Dispose();\n    }\n  }\n}\nexport function SetTreeModule$$$ofArray(comparer$$21, arr$$1) {\n  let acc$$12 = new SetTree$00601(0, \"SetEmpty\");\n\n  for (let i$$3 = 0; i$$3 <= arr$$1.length - 1; i$$3++) {\n    acc$$12 = SetTreeModule$$$add(comparer$$21, arr$$1[i$$3], acc$$12);\n  }\n\n  return acc$$12;\n}\nexport const FSharpSet = declare(function Set_Set(comparer$$22, tree) {\n  const $this$$2 = this;\n  $this$$2.comparer = comparer$$22;\n  $this$$2.tree = tree;\n});\nexport function FSharpSet$reflection($gen$$133) {\n  return type(\"Set.FSharpSet\", [$gen$$133]);\n}\nexport function FSharpSet$$$$002Ector$$2528C5CB(comparer$$22, tree) {\n  return this instanceof FSharpSet ? FSharpSet.call(this, comparer$$22, tree) : new FSharpSet(comparer$$22, tree);\n}\nexport function FSharpSet$$get_Comparer(__$$4) {\n  return __$$4.comparer;\n}\nexport function FSharpSet$$get_Tree(__$$5) {\n  return __$$5.tree;\n}\nexport function FSharpSet$$Add$$2B595(s$$20, x$$9) {\n  return FSharpSet$$$$002Ector$$2528C5CB(FSharpSet$$get_Comparer(s$$20), SetTreeModule$$$add(FSharpSet$$get_Comparer(s$$20), x$$9, FSharpSet$$get_Tree(s$$20)));\n}\nexport function FSharpSet$$Remove$$2B595(s$$21, x$$10) {\n  return FSharpSet$$$$002Ector$$2528C5CB(FSharpSet$$get_Comparer(s$$21), SetTreeModule$$$remove(FSharpSet$$get_Comparer(s$$21), x$$10, FSharpSet$$get_Tree(s$$21)));\n}\nexport function FSharpSet$$get_Count(s$$22) {\n  return SetTreeModule$$$count(FSharpSet$$get_Tree(s$$22));\n}\nexport function FSharpSet$$Contains$$2B595(s$$23, x$$11) {\n  return SetTreeModule$$$mem(FSharpSet$$get_Comparer(s$$23), x$$11, FSharpSet$$get_Tree(s$$23));\n}\nexport function FSharpSet$$Iterate$$5028453F(s$$24, x$$12) {\n  SetTreeModule$$$iter(x$$12, FSharpSet$$get_Tree(s$$24));\n}\nexport function FSharpSet$$Fold(s$$25, f$$10, z) {\n  return SetTreeModule$$$fold(function (x$$13, z$$1) {\n    return f$$10(z$$1, x$$13);\n  }, z, FSharpSet$$get_Tree(s$$25));\n}\nexport function FSharpSet$$get_IsEmpty(s$$26) {\n  return SetTreeModule$$$isEmpty(FSharpSet$$get_Tree(s$$26));\n}\nexport function FSharpSet$$Partition$$Z1D55A0D7(s$$27, f$$11) {\n  const matchValue$$10 = FSharpSet$$get_Tree(s$$27);\n\n  if (matchValue$$10.tag === 0) {\n    return [s$$27, s$$27];\n  } else {\n    const patternInput$$6 = SetTreeModule$$$partition(FSharpSet$$get_Comparer(s$$27), f$$11, FSharpSet$$get_Tree(s$$27));\n    return [FSharpSet$$$$002Ector$$2528C5CB(FSharpSet$$get_Comparer(s$$27), patternInput$$6[0]), FSharpSet$$$$002Ector$$2528C5CB(FSharpSet$$get_Comparer(s$$27), patternInput$$6[1])];\n  }\n}\nexport function FSharpSet$$Filter$$Z1D55A0D7(s$$28, f$$12) {\n  const matchValue$$11 = FSharpSet$$get_Tree(s$$28);\n\n  if (matchValue$$11.tag === 0) {\n    return s$$28;\n  } else {\n    return FSharpSet$$$$002Ector$$2528C5CB(FSharpSet$$get_Comparer(s$$28), SetTreeModule$$$filter(FSharpSet$$get_Comparer(s$$28), f$$12, FSharpSet$$get_Tree(s$$28)));\n  }\n}\nexport function FSharpSet$$Map$$7597B8F7(s$$29, f$$13, comparer$$23) {\n  return FSharpSet$$$$002Ector$$2528C5CB(comparer$$23, SetTreeModule$$$fold(function (acc$$13, k$$33) {\n    return SetTreeModule$$$add(comparer$$23, f$$13(k$$33), acc$$13);\n  }, new SetTree$00601(0, \"SetEmpty\"), FSharpSet$$get_Tree(s$$29)));\n}\nexport function FSharpSet$$Exists$$Z1D55A0D7(s$$30, f$$14) {\n  return SetTreeModule$$$exists(f$$14, FSharpSet$$get_Tree(s$$30));\n}\nexport function FSharpSet$$ForAll$$Z1D55A0D7(s$$31, f$$15) {\n  return SetTreeModule$$$forall(f$$15, FSharpSet$$get_Tree(s$$31));\n}\nexport function FSharpSet$$$op_Subtraction(a$$4, b$$5) {\n  const matchValue$$12 = FSharpSet$$get_Tree(a$$4);\n\n  if (matchValue$$12.tag === 0) {\n    return a$$4;\n  } else {\n    const matchValue$$13 = FSharpSet$$get_Tree(b$$5);\n\n    if (matchValue$$13.tag === 0) {\n      return a$$4;\n    } else {\n      return FSharpSet$$$$002Ector$$2528C5CB(FSharpSet$$get_Comparer(a$$4), SetTreeModule$$$diff(FSharpSet$$get_Comparer(a$$4), FSharpSet$$get_Tree(a$$4), FSharpSet$$get_Tree(b$$5)));\n    }\n  }\n}\nexport function FSharpSet$$$op_Addition(a$$5, b$$6) {\n  const matchValue$$14 = FSharpSet$$get_Tree(b$$6);\n\n  if (matchValue$$14.tag === 0) {\n    return a$$5;\n  } else {\n    const matchValue$$15 = FSharpSet$$get_Tree(a$$5);\n\n    if (matchValue$$15.tag === 0) {\n      return b$$6;\n    } else {\n      return FSharpSet$$$$002Ector$$2528C5CB(FSharpSet$$get_Comparer(a$$5), SetTreeModule$$$union(FSharpSet$$get_Comparer(a$$5), FSharpSet$$get_Tree(a$$5), FSharpSet$$get_Tree(b$$6)));\n    }\n  }\n}\nexport function FSharpSet$$$Intersection$$Z3BE9BFE0(a$$6, b$$7) {\n  const matchValue$$16 = FSharpSet$$get_Tree(b$$7);\n\n  if (matchValue$$16.tag === 0) {\n    return b$$7;\n  } else {\n    const matchValue$$17 = FSharpSet$$get_Tree(a$$6);\n\n    if (matchValue$$17.tag === 0) {\n      return a$$6;\n    } else {\n      return FSharpSet$$$$002Ector$$2528C5CB(FSharpSet$$get_Comparer(a$$6), SetTreeModule$$$intersection(FSharpSet$$get_Comparer(a$$6), FSharpSet$$get_Tree(a$$6), FSharpSet$$get_Tree(b$$7)));\n    }\n  }\n}\nexport function FSharpSet$$$IntersectionMany$$Z15B59630(sets) {\n  return reduce(FSharpSet$$$Intersection$$Z3BE9BFE0, sets);\n}\nexport function FSharpSet$$$Equality$$Z3BE9BFE0(a$$7, b$$8) {\n  return SetTreeModule$$$compare(FSharpSet$$get_Comparer(a$$7), FSharpSet$$get_Tree(a$$7), FSharpSet$$get_Tree(b$$8)) === 0;\n}\nexport function FSharpSet$$$Compare$$Z3BE9BFE0(a$$8, b$$9) {\n  return SetTreeModule$$$compare(FSharpSet$$get_Comparer(a$$8), FSharpSet$$get_Tree(a$$8), FSharpSet$$get_Tree(b$$9));\n}\nexport function FSharpSet$$get_Choose(x$$14) {\n  return SetTreeModule$$$choose(FSharpSet$$get_Tree(x$$14));\n}\nexport function FSharpSet$$get_MinimumElement(x$$15) {\n  return SetTreeModule$$$minimumElement(FSharpSet$$get_Tree(x$$15));\n}\nexport function FSharpSet$$get_MaximumElement(x$$16) {\n  return SetTreeModule$$$maximumElement(FSharpSet$$get_Tree(x$$16));\n}\nexport function FSharpSet$$IsSubsetOf$$6A20B1FF(x$$17, y) {\n  return SetTreeModule$$$subset(FSharpSet$$get_Comparer(x$$17), FSharpSet$$get_Tree(x$$17), FSharpSet$$get_Tree(y));\n}\nexport function FSharpSet$$IsSupersetOf$$6A20B1FF(x$$18, y$$1) {\n  return SetTreeModule$$$subset(FSharpSet$$get_Comparer(x$$18), FSharpSet$$get_Tree(y$$1), FSharpSet$$get_Tree(x$$18));\n}\nexport function FSharpSet$$IsProperSubsetOf$$6A20B1FF(x$$19, y$$2) {\n  return SetTreeModule$$$psubset(FSharpSet$$get_Comparer(x$$19), FSharpSet$$get_Tree(x$$19), FSharpSet$$get_Tree(y$$2));\n}\nexport function FSharpSet$$IsProperSupersetOf$$6A20B1FF(x$$20, y$$3) {\n  return SetTreeModule$$$psubset(FSharpSet$$get_Comparer(x$$20), FSharpSet$$get_Tree(y$$3), FSharpSet$$get_Tree(x$$20));\n}\n\nFSharpSet.prototype.toString = function () {\n  var strings;\n  const this$ = this;\n  return \"set [\" + (strings = map$$1(function (x$$21) {\n    let copyOfStruct = x$$21;\n    return String(copyOfStruct);\n  }, this$), join(\"; \", strings)) + \"]\";\n};\n\nFSharpSet.prototype.GetHashCode = function () {\n  const this$$$1 = this;\n  let res = 0;\n  const e$$1 = SetTreeModule$$$mkIEnumerator(FSharpSet$$get_Tree(this$$$1));\n\n  while (e$$1.MoveNext()) {\n    const x$$22 = res | 0;\n    const y$$4 = structuralHash(e$$1.Current) | 0;\n    res = (x$$22 << 1) + y$$4 + 631;\n  }\n\n  return Math.abs(res) | 0;\n};\n\nFSharpSet.prototype.Equals = function (that) {\n  const this$$$2 = this;\n  return SetTreeModule$$$compare(FSharpSet$$get_Comparer(this$$$2), FSharpSet$$get_Tree(this$$$2), FSharpSet$$get_Tree(that)) === 0;\n};\n\nFSharpSet.prototype.CompareTo = function (that$$1) {\n  const this$$$3 = this;\n  return SetTreeModule$$$compare(FSharpSet$$get_Comparer(this$$$3), FSharpSet$$get_Tree(this$$$3), FSharpSet$$get_Tree(that$$1)) | 0;\n};\n\nFSharpSet.prototype[Symbol.iterator] = function () {\n  const s$$32 = this;\n  return toIterator(SetTreeModule$$$mkIEnumerator(FSharpSet$$get_Tree(s$$32)));\n};\n\nexport function isEmpty(s$$33) {\n  return FSharpSet$$get_IsEmpty(s$$33);\n}\nexport function contains(x$$23, s$$34) {\n  return FSharpSet$$Contains$$2B595(s$$34, x$$23);\n}\nexport function add(x$$24, s$$35) {\n  return FSharpSet$$Add$$2B595(s$$35, x$$24);\n}\nexport function singleton(x$$25, comparer$$24) {\n  return FSharpSet$$$$002Ector$$2528C5CB(comparer$$24, new SetTree$00601(2, \"SetOne\", x$$25));\n}\nexport function remove(x$$26, s$$36) {\n  return FSharpSet$$Remove$$2B595(s$$36, x$$26);\n}\nexport function union(s1$$2, s2$$2) {\n  return FSharpSet$$$op_Addition(s1$$2, s2$$2);\n}\nexport function unionMany(sets$$1, comparer$$25) {\n  return fold$$1(FSharpSet$$$op_Addition, FSharpSet$$$$002Ector$$2528C5CB(comparer$$25, new SetTree$00601(0, \"SetEmpty\")), sets$$1);\n}\nexport function intersect(s1$$3, s2$$3) {\n  return FSharpSet$$$Intersection$$Z3BE9BFE0(s1$$3, s2$$3);\n}\nexport function intersectMany(sets$$2) {\n  return FSharpSet$$$IntersectionMany$$Z15B59630(sets$$2);\n}\nexport function iterate(f$$16, s$$37) {\n  FSharpSet$$Iterate$$5028453F(s$$37, f$$16);\n}\nexport function empty(comparer$$26) {\n  return FSharpSet$$$$002Ector$$2528C5CB(comparer$$26, new SetTree$00601(0, \"SetEmpty\"));\n}\nexport function forAll(f$$17, s$$38) {\n  return FSharpSet$$ForAll$$Z1D55A0D7(s$$38, f$$17);\n}\nexport function exists(f$$18, s$$39) {\n  return FSharpSet$$Exists$$Z1D55A0D7(s$$39, f$$18);\n}\nexport function filter(f$$19, s$$40) {\n  return FSharpSet$$Filter$$Z1D55A0D7(s$$40, f$$19);\n}\nexport function partition(f$$20, s$$41) {\n  return FSharpSet$$Partition$$Z1D55A0D7(s$$41, f$$20);\n}\nexport function fold(f$$21, z$$2, s$$42) {\n  return SetTreeModule$$$fold(f$$21, z$$2, FSharpSet$$get_Tree(s$$42));\n}\nexport function foldBack(f$$22, s$$43, z$$3) {\n  return SetTreeModule$$$foldBack(f$$22, FSharpSet$$get_Tree(s$$43), z$$3);\n}\nexport function map(f$$23, s$$44, comparer$$27) {\n  return FSharpSet$$Map$$7597B8F7(s$$44, f$$23, comparer$$27);\n}\nexport function count(s$$45) {\n  return FSharpSet$$get_Count(s$$45);\n}\nexport function minimumElement(s$$46) {\n  return FSharpSet$$get_MinimumElement(s$$46);\n}\nexport function maximumElement(s$$47) {\n  return FSharpSet$$get_MaximumElement(s$$47);\n}\nexport function ofList(li, comparer$$28) {\n  return FSharpSet$$$$002Ector$$2528C5CB(comparer$$28, SetTreeModule$$$ofSeq(comparer$$28, li));\n}\nexport function ofArray(arr$$2, comparer$$29) {\n  return FSharpSet$$$$002Ector$$2528C5CB(comparer$$29, SetTreeModule$$$ofArray(comparer$$29, arr$$2));\n}\nexport function toList(s$$48) {\n  return SetTreeModule$$$toList(FSharpSet$$get_Tree(s$$48));\n}\nexport function toArray(s$$49, cons) {\n  const n$$3 = count(s$$49) | 0;\n  const res$$1 = new cons(n$$3);\n  SetTreeModule$$$copyToArray(FSharpSet$$get_Tree(s$$49), res$$1, 0);\n  return res$$1;\n}\nexport function toSeq(s$$50) {\n  return SetTreeModule$$$toSeq(FSharpSet$$get_Tree(s$$50));\n}\nexport function ofSeq(elements, comparer$$30) {\n  return FSharpSet$$$$002Ector$$2528C5CB(comparer$$30, SetTreeModule$$$ofSeq(comparer$$30, elements));\n}\nexport function difference(x$$28, y$$6) {\n  return FSharpSet$$$op_Subtraction(x$$28, y$$6);\n}\nexport function isSubset(x$$29, y$$7) {\n  return FSharpSet$$IsSubsetOf$$6A20B1FF(x$$29, y$$7);\n}\nexport function isSuperset(x$$30, y$$8) {\n  return FSharpSet$$IsSupersetOf$$6A20B1FF(x$$30, y$$8);\n}\nexport function isProperSubset(x$$31, y$$9) {\n  return FSharpSet$$IsProperSubsetOf$$6A20B1FF(x$$31, y$$9);\n}\nexport function isProperSuperset(x$$32, y$$10) {\n  return FSharpSet$$IsProperSupersetOf$$6A20B1FF(x$$32, y$$10);\n}\nexport function minElement(s$$51) {\n  return FSharpSet$$get_MinimumElement(s$$51);\n}\nexport function maxElement(s$$52) {\n  return FSharpSet$$get_MaximumElement(s$$52);\n}\n\nfunction createMutablePrivate(comparer$$31, tree$0027) {\n  let tree$$1 = tree$0027;\n  return {\n    get size() {\n      return SetTreeModule$$$count(tree$$1);\n    },\n\n    add(x$$33) {\n      const this$$$4 = this;\n      tree$$1 = SetTreeModule$$$add(comparer$$31, x$$33, tree$$1);\n      return this$$$4;\n    },\n\n    add_(x$$34) {\n      if (SetTreeModule$$$mem(comparer$$31, x$$34, tree$$1)) {\n        return false;\n      } else {\n        tree$$1 = SetTreeModule$$$add(comparer$$31, x$$34, tree$$1);\n        return true;\n      }\n    },\n\n    clear() {\n      tree$$1 = new SetTree$00601(0, \"SetEmpty\");\n    },\n\n    delete(x$$35) {\n      if (SetTreeModule$$$mem(comparer$$31, x$$35, tree$$1)) {\n        tree$$1 = SetTreeModule$$$remove(comparer$$31, x$$35, tree$$1);\n        return true;\n      } else {\n        return false;\n      }\n    },\n\n    has(x$$36) {\n      return SetTreeModule$$$mem(comparer$$31, x$$36, tree$$1);\n    },\n\n    keys() {\n      return SetTreeModule$$$toSeq(tree$$1);\n    },\n\n    values() {\n      return SetTreeModule$$$toSeq(tree$$1);\n    },\n\n    entries() {\n      const source = SetTreeModule$$$toSeq(tree$$1);\n      return map$$1(function mapping(v) {\n        return [v, v];\n      }, source);\n    },\n\n    [Symbol.iterator]() {\n      return toIterator(SetTreeModule$$$mkIEnumerator(tree$$1));\n    },\n\n    GetEnumerator() {\n      return SetTreeModule$$$mkIEnumerator(tree$$1);\n    }\n\n  };\n}\n\nexport function createMutable(source$$1, comparer$$32) {\n  const set = MutableSet$002400601$0024$0024$0024$0024002Ector$0024$0024Z6150332D(source$$1, comparer$$32);\n  return set;\n}\nexport function distinct(xs, comparer$$33) {\n  return delay(function () {\n    const set$$1 = MutableSet$002400601$0024$0024$0024$0024002Ector$0024$0024Z6150332D(empty$$1(), comparer$$33);\n    return collect(function (x$$37) {\n      return MutableSet$002400601$0024$0024Add$0024$00242B595(set$$1, x$$37) ? singleton$$1(x$$37) : empty$$1();\n    }, xs);\n  });\n}\nexport function distinctBy(projection, xs$$1, comparer$$34) {\n  return delay(function () {\n    const set$$2 = MutableSet$002400601$0024$0024$0024$0024002Ector$0024$0024Z6150332D(empty$$1(), comparer$$34);\n    return collect(function (x$$38) {\n      return MutableSet$002400601$0024$0024Add$0024$00242B595(set$$2, projection(x$$38)) ? singleton$$1(x$$38) : empty$$1();\n    }, xs$$1);\n  });\n}\nexport function unionWith(s1$$4, s2$$4) {\n  return fold$$1(function folder(acc$$14, x$$39) {\n    return acc$$14.add(x$$39);\n  }, s1$$4, s2$$4);\n}\nexport function intersectWith(s1$$5, s2$$5, comparer$$35) {\n  const s2$$6 = ofSeq(s2$$5, comparer$$35);\n  iterate$$1(function (x$$40) {\n    if (!FSharpSet$$Contains$$2B595(s2$$6, x$$40)) {\n      const value = s1$$5.delete(x$$40);\n      void value;\n    }\n  }, s1$$5);\n}\nexport function exceptWith(s1$$6, s2$$7) {\n  iterate$$1(function (x$$41) {\n    const value$$1 = s1$$6.delete(x$$41);\n    void value$$1;\n  }, s2$$7);\n}\nexport function isSubsetOf(s1$$7, s2$$8, comparer$$36) {\n  return isSubset(ofSeq(s1$$7, comparer$$36), ofSeq(s2$$8, comparer$$36));\n}\nexport function isSupersetOf(s1$$8, s2$$9, comparer$$37) {\n  return isSuperset(ofSeq(s1$$8, comparer$$37), ofSeq(s2$$9, comparer$$37));\n}\nexport function isProperSubsetOf(s1$$9, s2$$10, comparer$$38) {\n  return isProperSubset(ofSeq(s1$$9, comparer$$38), ofSeq(s2$$10, comparer$$38));\n}\nexport function isProperSupersetOf(s1$$10, s2$$11, comparer$$39) {\n  return isProperSuperset(ofSeq(s1$$10, comparer$$39), ofSeq(s2$$11, comparer$$39));\n}","import { defaultArg, value as value$$1, some } from \"./Option\";\nimport { List } from \"./Types\";\nimport { transpose as transpose$$1, collect as collect$$1, scanBack as scanBack$$1, scan as scan$$1, foldBack2 as foldBack2$$1, fold2 as fold2$$1, fold as fold$$1, map as map$$1 } from \"./Seq\";\nimport { partialApply, getItemFromDict, addToDict, tryGetValue, addToSet, count } from \"./Util\";\nimport { ofList } from \"./Array\";\nimport { splitInto as splitInto$$1, chunkBySize as chunkBySize$$1, permute as permute$$1, findIndexBack as findIndexBack$$1, tryFindIndexBack as tryFindIndexBack$$1 } from \"./Array\";\nimport { createMutable } from \"./Set\";\nimport { createMutable as createMutable$$1 } from \"./Map\";\nexport function head(_arg1) {\n  if (_arg1.tail != null) {\n    return _arg1.head;\n  } else {\n    throw new Error(\"List was empty\");\n  }\n}\nexport function tryHead(_arg1$$1) {\n  if (_arg1$$1.tail != null) {\n    return some(_arg1$$1.head);\n  } else {\n    return null;\n  }\n}\nexport function tail(_arg1$$2) {\n  if (_arg1$$2.tail != null) {\n    return _arg1$$2.tail;\n  } else {\n    throw new Error(\"List was empty\");\n  }\n}\nexport function last($_arg1$$3$$5) {\n  last: while (true) {\n    const _arg1$$3 = $_arg1$$3$$5;\n\n    if (_arg1$$3.tail != null) {\n      if (_arg1$$3.tail.tail == null) {\n        return _arg1$$3.head;\n      } else {\n        $_arg1$$3$$5 = _arg1$$3.tail;\n        continue last;\n      }\n    } else {\n      throw new Error(\"List was empty\");\n    }\n\n    break;\n  }\n}\nexport function tryLast($_arg1$$4$$6) {\n  tryLast: while (true) {\n    const _arg1$$4 = $_arg1$$4$$6;\n\n    if (_arg1$$4.tail != null) {\n      if (_arg1$$4.tail.tail == null) {\n        return some(_arg1$$4.head);\n      } else {\n        $_arg1$$4$$6 = _arg1$$4.tail;\n        continue tryLast;\n      }\n    } else {\n      return null;\n    }\n\n    break;\n  }\n}\nexport function compareWith(comparer, xs$$3, ys) {\n  if (xs$$3 === ys) {\n    return 0;\n  } else {\n    const loop = function loop($xs$$4$$10, $ys$$1$$11) {\n      loop: while (true) {\n        const xs$$4 = $xs$$4$$10,\n              ys$$1 = $ys$$1$$11;\n\n        if (xs$$4.tail != null) {\n          if (ys$$1.tail != null) {\n            const matchValue$$1 = comparer(xs$$4.head, ys$$1.head) | 0;\n\n            if (matchValue$$1 === 0) {\n              $xs$$4$$10 = xs$$4.tail;\n              $ys$$1$$11 = ys$$1.tail;\n              continue loop;\n            } else {\n              return matchValue$$1 | 0;\n            }\n          } else {\n            return 1;\n          }\n        } else if (ys$$1.tail == null) {\n          return 0;\n        } else {\n          return -1 | 0;\n        }\n\n        break;\n      }\n    };\n\n    return loop(xs$$3, ys) | 0;\n  }\n}\nexport function foldIndexedAux($f$$12, $i$$13, $acc$$14, $_arg1$$5$$15) {\n  foldIndexedAux: while (true) {\n    const f = $f$$12,\n          i = $i$$13,\n          acc = $acc$$14,\n          _arg1$$5 = $_arg1$$5$$15;\n\n    if (_arg1$$5.tail != null) {\n      $f$$12 = f;\n      $i$$13 = i + 1;\n      $acc$$14 = f(i, acc, _arg1$$5.head);\n      $_arg1$$5$$15 = _arg1$$5.tail;\n      continue foldIndexedAux;\n    } else {\n      return acc;\n    }\n\n    break;\n  }\n}\nexport function foldIndexed(f$$1, state, xs$$7) {\n  return foldIndexedAux(f$$1, 0, state, xs$$7);\n}\nexport function fold($f$$2$$19, $state$$1$$20, $xs$$8$$21) {\n  fold: while (true) {\n    const f$$2 = $f$$2$$19,\n          state$$1 = $state$$1$$20,\n          xs$$8 = $xs$$8$$21;\n\n    if (xs$$8.tail != null) {\n      $f$$2$$19 = f$$2;\n      $state$$1$$20 = f$$2(state$$1, xs$$8.head);\n      $xs$$8$$21 = xs$$8.tail;\n      continue fold;\n    } else {\n      return state$$1;\n    }\n\n    break;\n  }\n}\nexport function reverse(xs$$9) {\n  return fold(function (acc$$1, x$$6) {\n    return new List(x$$6, acc$$1);\n  }, new List(), xs$$9);\n}\nexport function foldBack(f$$3, xs$$10, state$$2) {\n  return fold(function (acc$$2, x$$7) {\n    return f$$3(x$$7, acc$$2);\n  }, state$$2, reverse(xs$$10));\n}\nexport function toSeq(xs$$11) {\n  return map$$1(function (x$$8) {\n    return x$$8;\n  }, xs$$11);\n}\nexport function ofSeq(xs$$12) {\n  const xs$$13 = fold$$1(function (acc$$3, x$$9) {\n    return new List(x$$9, acc$$3);\n  }, new List(), xs$$12);\n  return reverse(xs$$13);\n}\nexport function concat(lists) {\n  const xs$$15 = fold$$1(function (state$$3, xs$$14) {\n    return fold(function f$$4(acc$$4, x$$10) {\n      return new List(x$$10, acc$$4);\n    }, state$$3, xs$$14);\n  }, new List(), lists);\n  return reverse(xs$$15);\n}\nexport function foldIndexed2Aux($f$$5$$31, $i$$1$$32, $acc$$5$$33, $bs$$34, $cs$$35) {\n  foldIndexed2Aux: while (true) {\n    const f$$5 = $f$$5$$31,\n          i$$1 = $i$$1$$32,\n          acc$$5 = $acc$$5$$33,\n          bs = $bs$$34,\n          cs = $cs$$35;\n    var $target$$36, x$$11, xs$$16, y$$1, ys$$3;\n\n    if (bs.tail != null) {\n      if (cs.tail != null) {\n        $target$$36 = 1;\n        x$$11 = bs.head;\n        xs$$16 = bs.tail;\n        y$$1 = cs.head;\n        ys$$3 = cs.tail;\n      } else {\n        $target$$36 = 2;\n      }\n    } else if (cs.tail == null) {\n      $target$$36 = 0;\n    } else {\n      $target$$36 = 2;\n    }\n\n    switch ($target$$36) {\n      case 0:\n        {\n          return acc$$5;\n        }\n\n      case 1:\n        {\n          $f$$5$$31 = f$$5;\n          $i$$1$$32 = i$$1 + 1;\n          $acc$$5$$33 = f$$5(i$$1, acc$$5, x$$11, y$$1);\n          $bs$$34 = xs$$16;\n          $cs$$35 = ys$$3;\n          continue foldIndexed2Aux;\n        }\n\n      case 2:\n        {\n          throw new Error(\"Lists had different lengths\");\n        }\n    }\n\n    break;\n  }\n}\nexport function foldIndexed2(f$$6, state$$4, xs$$17, ys$$4) {\n  return foldIndexed2Aux(f$$6, 0, state$$4, xs$$17, ys$$4);\n}\nexport function fold2(f$$7, state$$5, xs$$18, ys$$5) {\n  return fold2$$1(f$$7, state$$5, xs$$18, ys$$5);\n}\nexport function foldBack2(f$$8, xs$$19, ys$$6, state$$6) {\n  return foldBack2$$1(f$$8, xs$$19, ys$$6, state$$6);\n}\nexport function unfold(f$$9, state$$7) {\n  const unfoldInner = function unfoldInner($acc$$6$$51, $state$$8$$52) {\n    unfoldInner: while (true) {\n      const acc$$6 = $acc$$6$$51,\n            state$$8 = $state$$8$$52;\n      const matchValue$$3 = f$$9(state$$8);\n\n      if (matchValue$$3 != null) {\n        const x$$12 = matchValue$$3[0];\n        const state$$9 = matchValue$$3[1];\n        $acc$$6$$51 = new List(x$$12, acc$$6);\n        $state$$8$$52 = state$$9;\n        continue unfoldInner;\n      } else {\n        return reverse(acc$$6);\n      }\n\n      break;\n    }\n  };\n\n  return unfoldInner(new List(), state$$7);\n}\nexport function foldIndexed3Aux($f$$10$$53, $i$$2$$54, $acc$$7$$55, $bs$$1$$56, $cs$$1$$57, $ds$$58) {\n  foldIndexed3Aux: while (true) {\n    const f$$10 = $f$$10$$53,\n          i$$2 = $i$$2$$54,\n          acc$$7 = $acc$$7$$55,\n          bs$$1 = $bs$$1$$56,\n          cs$$1 = $cs$$1$$57,\n          ds = $ds$$58;\n    var $target$$59, x$$13, xs$$20, y$$2, ys$$7, z, zs;\n\n    if (bs$$1.tail != null) {\n      if (cs$$1.tail != null) {\n        if (ds.tail != null) {\n          $target$$59 = 1;\n          x$$13 = bs$$1.head;\n          xs$$20 = bs$$1.tail;\n          y$$2 = cs$$1.head;\n          ys$$7 = cs$$1.tail;\n          z = ds.head;\n          zs = ds.tail;\n        } else {\n          $target$$59 = 2;\n        }\n      } else {\n        $target$$59 = 2;\n      }\n    } else if (cs$$1.tail == null) {\n      if (ds.tail == null) {\n        $target$$59 = 0;\n      } else {\n        $target$$59 = 2;\n      }\n    } else {\n      $target$$59 = 2;\n    }\n\n    switch ($target$$59) {\n      case 0:\n        {\n          return acc$$7;\n        }\n\n      case 1:\n        {\n          $f$$10$$53 = f$$10;\n          $i$$2$$54 = i$$2 + 1;\n          $acc$$7$$55 = f$$10(i$$2, acc$$7, x$$13, y$$2, z);\n          $bs$$1$$56 = xs$$20;\n          $cs$$1$$57 = ys$$7;\n          $ds$$58 = zs;\n          continue foldIndexed3Aux;\n        }\n\n      case 2:\n        {\n          throw new Error(\"Lists had different lengths\");\n        }\n    }\n\n    break;\n  }\n}\nexport function foldIndexed3(f$$11, seed, xs$$21, ys$$8, zs$$1) {\n  return foldIndexed3Aux(f$$11, 0, seed, xs$$21, ys$$8, zs$$1);\n}\nexport function fold3(f$$12, state$$10, xs$$22, ys$$9, zs$$2) {\n  return foldIndexed3(function (_arg1$$6, acc$$8, x$$14, y$$3, z$$1) {\n    return f$$12(acc$$8, x$$14, y$$3, z$$1);\n  }, state$$10, xs$$22, ys$$9, zs$$2);\n}\nexport function scan(f$$13, state$$11, xs$$23) {\n  const xs$$24 = scan$$1(f$$13, state$$11, xs$$23);\n  return ofSeq(xs$$24);\n}\nexport function scanBack(f$$14, xs$$25, state$$12) {\n  const xs$$26 = scanBack$$1(f$$14, xs$$25, state$$12);\n  return ofSeq(xs$$26);\n}\nexport function length(xs$$27) {\n  return fold(function (acc$$9, _arg1$$7) {\n    return acc$$9 + 1;\n  }, 0, xs$$27);\n}\nexport function append(xs$$28, ys$$10) {\n  return fold(function (acc$$10, x$$15) {\n    return new List(x$$15, acc$$10);\n  }, ys$$10, reverse(xs$$28));\n}\nexport function collect(f$$15, xs$$29) {\n  const xs$$30 = collect$$1(f$$15, xs$$29);\n  return ofSeq(xs$$30);\n}\nexport function map(f$$16, xs$$31) {\n  const xs$$32 = fold(function (acc$$11, x$$16) {\n    return new List(f$$16(x$$16), acc$$11);\n  }, new List(), xs$$31);\n  return reverse(xs$$32);\n}\nexport function mapIndexed(f$$17, xs$$33) {\n  const xs$$34 = foldIndexed(function (i$$3, acc$$12, x$$17) {\n    return new List(f$$17(i$$3, x$$17), acc$$12);\n  }, new List(), xs$$33);\n  return reverse(xs$$34);\n}\nexport function indexed(xs$$35) {\n  return mapIndexed(function (i$$4, x$$18) {\n    return [i$$4, x$$18];\n  }, xs$$35);\n}\nexport function map2(f$$18, xs$$36, ys$$11) {\n  const xs$$37 = fold2(function (acc$$13, x$$19, y$$4) {\n    return new List(f$$18(x$$19, y$$4), acc$$13);\n  }, new List(), xs$$36, ys$$11);\n  return reverse(xs$$37);\n}\nexport function mapIndexed2(f$$19, xs$$38, ys$$12) {\n  const xs$$39 = foldIndexed2(function (i$$5, acc$$14, x$$20, y$$5) {\n    return new List(f$$19(i$$5, x$$20, y$$5), acc$$14);\n  }, new List(), xs$$38, ys$$12);\n  return reverse(xs$$39);\n}\nexport function map3(f$$20, xs$$40, ys$$13, zs$$3) {\n  const xs$$41 = fold3(function (acc$$15, x$$21, y$$6, z$$2) {\n    return new List(f$$20(x$$21, y$$6, z$$2), acc$$15);\n  }, new List(), xs$$40, ys$$13, zs$$3);\n  return reverse(xs$$41);\n}\nexport function mapIndexed3(f$$21, xs$$42, ys$$14, zs$$4) {\n  const xs$$43 = foldIndexed3(function (i$$6, acc$$16, x$$22, y$$7, z$$3) {\n    return new List(f$$21(i$$6, x$$22, y$$7, z$$3), acc$$16);\n  }, new List(), xs$$42, ys$$14, zs$$4);\n  return reverse(xs$$43);\n}\nexport function mapFold(f$$22, s, xs$$44) {\n  const patternInput$$1 = fold(function foldFn(tupledArg, x$$23) {\n    const patternInput = f$$22(tupledArg[1], x$$23);\n    return [new List(patternInput[0], tupledArg[0]), patternInput[1]];\n  }, [new List(), s], xs$$44);\n  return [reverse(patternInput$$1[0]), patternInput$$1[1]];\n}\nexport function mapFoldBack(f$$23, xs$$45, s$$2) {\n  return mapFold(function (s$$3, v) {\n    return f$$23(v, s$$3);\n  }, s$$2, reverse(xs$$45));\n}\nexport function iterate(f$$24, xs$$46) {\n  fold(function (unitVar0, x$$24) {\n    f$$24(x$$24);\n  }, null, xs$$46);\n}\nexport function iterate2(f$$25, xs$$47, ys$$15) {\n  fold2(function (unitVar0$$1, x$$25, y$$8) {\n    f$$25(x$$25, y$$8);\n  }, null, xs$$47, ys$$15);\n}\nexport function iterateIndexed(f$$26, xs$$48) {\n  foldIndexed(function (i$$7, unitVar1, x$$26) {\n    f$$26(i$$7, x$$26);\n  }, null, xs$$48);\n}\nexport function iterateIndexed2(f$$27, xs$$49, ys$$16) {\n  foldIndexed2(function (i$$8, unitVar1$$1, x$$27, y$$9) {\n    f$$27(i$$8, x$$27, y$$9);\n  }, null, xs$$49, ys$$16);\n}\nexport function ofArray(xs$$50) {\n  let res$$1 = new List();\n\n  for (let i$$9 = count(xs$$50) - 1; i$$9 >= 0; i$$9--) {\n    res$$1 = new List(xs$$50[i$$9], res$$1);\n  }\n\n  return res$$1;\n}\nexport function empty() {\n  return new List();\n}\nexport function isEmpty(_arg1$$8) {\n  if (_arg1$$8.tail == null) {\n    return true;\n  } else {\n    return false;\n  }\n}\nexport function tryPickIndexedAux($f$$28$$120, $i$$10$$121, $_arg1$$9$$122) {\n  tryPickIndexedAux: while (true) {\n    const f$$28 = $f$$28$$120,\n          i$$10 = $i$$10$$121,\n          _arg1$$9 = $_arg1$$9$$122;\n\n    if (_arg1$$9.tail != null) {\n      const result = f$$28(i$$10, _arg1$$9.head);\n\n      if (result == null) {\n        $f$$28$$120 = f$$28;\n        $i$$10$$121 = i$$10 + 1;\n        $_arg1$$9$$122 = _arg1$$9.tail;\n        continue tryPickIndexedAux;\n      } else {\n        return result;\n      }\n    } else {\n      return null;\n    }\n\n    break;\n  }\n}\nexport function tryPickIndexed(f$$29, xs$$52) {\n  return tryPickIndexedAux(f$$29, 0, xs$$52);\n}\nexport function tryPick(f$$30, xs$$53) {\n  return tryPickIndexed(function (_arg1$$10, x$$29) {\n    return f$$30(x$$29);\n  }, xs$$53);\n}\nexport function pick(f$$31, xs$$54) {\n  const matchValue$$5 = tryPick(f$$31, xs$$54);\n\n  if (matchValue$$5 != null) {\n    const x$$30 = value$$1(matchValue$$5);\n    return x$$30;\n  } else {\n    throw new Error(\"List did not contain any matching elements\");\n  }\n}\nexport function tryFindIndexed(f$$32, xs$$55) {\n  return tryPickIndexed(function (i$$11, x$$31) {\n    return f$$32(i$$11, x$$31) ? some(x$$31) : null;\n  }, xs$$55);\n}\nexport function tryFind(f$$33, xs$$56) {\n  return tryPickIndexed(function (_arg1$$11, x$$32) {\n    return f$$33(x$$32) ? some(x$$32) : null;\n  }, xs$$56);\n}\nexport function findIndexed(f$$34, xs$$57) {\n  const matchValue$$6 = tryFindIndexed(f$$34, xs$$57);\n\n  if (matchValue$$6 != null) {\n    const x$$33 = value$$1(matchValue$$6);\n    return x$$33;\n  } else {\n    throw new Error(\"List did not contain any matching elements\");\n  }\n}\nexport function find(f$$35, xs$$58) {\n  return findIndexed(function (_arg1$$12, x$$34) {\n    return f$$35(x$$34);\n  }, xs$$58);\n}\nexport function findBack(f$$36, xs$$59) {\n  let xs$$61;\n  xs$$61 = reverse(xs$$59);\n  return find(f$$36, xs$$61);\n}\nexport function tryFindBack(f$$37, xs$$62) {\n  let xs$$64;\n  xs$$64 = reverse(xs$$62);\n  return tryFind(f$$37, xs$$64);\n}\nexport function tryFindIndex(f$$38, xs$$65) {\n  return tryPickIndexed(function (i$$12, x$$35) {\n    return f$$38(x$$35) ? i$$12 : null;\n  }, xs$$65);\n}\nexport function tryFindIndexBack(f$$39, xs$$66) {\n  const array = ofList(xs$$66, Array);\n  return tryFindIndexBack$$1(f$$39, array);\n}\nexport function findIndex(f$$40, xs$$67) {\n  const matchValue$$7 = tryFindIndex(f$$40, xs$$67);\n\n  if (matchValue$$7 != null) {\n    const x$$36 = matchValue$$7 | 0;\n    return x$$36 | 0;\n  } else {\n    throw new Error(\"List did not contain any matching elements\");\n  }\n}\nexport function findIndexBack(f$$41, xs$$68) {\n  const array$$1 = ofList(xs$$68, Array);\n  return findIndexBack$$1(f$$41, array$$1) | 0;\n}\nexport function item(n, xs$$69) {\n  return findIndexed(function (i$$13, _arg1$$13) {\n    return n === i$$13;\n  }, xs$$69);\n}\nexport function tryItem(n$$1, xs$$70) {\n  return tryFindIndexed(function (i$$14, _arg1$$14) {\n    return n$$1 === i$$14;\n  }, xs$$70);\n}\nexport function filter(f$$42, xs$$71) {\n  const xs$$72 = fold(function (acc$$17, x$$37) {\n    return f$$42(x$$37) ? new List(x$$37, acc$$17) : acc$$17;\n  }, new List(), xs$$71);\n  return reverse(xs$$72);\n}\nexport function partition(f$$43, xs$$73) {\n  return fold(function (tupledArg$$1, x$$38) {\n    return f$$43(x$$38) ? [new List(x$$38, tupledArg$$1[0]), tupledArg$$1[1]] : [tupledArg$$1[0], new List(x$$38, tupledArg$$1[1])];\n  }, [new List(), new List()], reverse(xs$$73));\n}\nexport function choose(f$$44, xs$$74) {\n  const xs$$75 = fold(function (acc$$18, x$$39) {\n    const matchValue$$8 = f$$44(x$$39);\n\n    if (matchValue$$8 == null) {\n      return acc$$18;\n    } else {\n      const y$$10 = value$$1(matchValue$$8);\n      return new List(y$$10, acc$$18);\n    }\n  }, new List(), xs$$74);\n  return reverse(xs$$75);\n}\nexport function contains(value, list, eq) {\n  const loop$$1 = function loop$$1($xs$$76$$162) {\n    loop$$1: while (true) {\n      const xs$$76 = $xs$$76$$162;\n\n      if (xs$$76.tail != null) {\n        if (eq.Equals(value, xs$$76.head)) {\n          return true;\n        } else {\n          $xs$$76$$162 = xs$$76.tail;\n          continue loop$$1;\n        }\n      } else {\n        return false;\n      }\n\n      break;\n    }\n  };\n\n  return loop$$1(list);\n}\nexport function except(itemsToExclude, array$$2, eq$$1) {\n  if (isEmpty(array$$2)) {\n    return array$$2;\n  } else {\n    const cached = createMutable(itemsToExclude, eq$$1);\n    return filter(function f$$45(arg00) {\n      return addToSet(arg00, cached);\n    }, array$$2);\n  }\n}\nexport function initialize(n$$2, f$$46) {\n  let xs$$78 = new List();\n\n  for (let i$$15 = 1; i$$15 <= n$$2; i$$15++) {\n    xs$$78 = new List(f$$46(n$$2 - i$$15), xs$$78);\n  }\n\n  return xs$$78;\n}\nexport function replicate(n$$3, x$$40) {\n  return initialize(n$$3, function (_arg1$$15) {\n    return x$$40;\n  });\n}\nexport function reduce(f$$47, _arg1$$16) {\n  if (_arg1$$16.tail != null) {\n    return fold(f$$47, _arg1$$16.head, _arg1$$16.tail);\n  } else {\n    throw new Error(\"List was empty\");\n  }\n}\nexport function reduceBack(f$$48, _arg1$$17) {\n  if (_arg1$$17.tail != null) {\n    return foldBack(f$$48, _arg1$$17.tail, _arg1$$17.head);\n  } else {\n    throw new Error(\"List was empty\");\n  }\n}\nexport function forAll(f$$49, xs$$79) {\n  return fold(function (acc$$19, x$$41) {\n    return acc$$19 ? f$$49(x$$41) : false;\n  }, true, xs$$79);\n}\nexport function forAll2(f$$50, xs$$80, ys$$17) {\n  return fold2(function (acc$$20, x$$42, y$$11) {\n    return acc$$20 ? f$$50(x$$42, y$$11) : false;\n  }, true, xs$$80, ys$$17);\n}\nexport function exists($f$$51$$180, $_arg1$$18$$181) {\n  exists: while (true) {\n    const f$$51 = $f$$51$$180,\n          _arg1$$18 = $_arg1$$18$$181;\n\n    if (_arg1$$18.tail != null) {\n      if (f$$51(_arg1$$18.head)) {\n        return true;\n      } else {\n        $f$$51$$180 = f$$51;\n        $_arg1$$18$$181 = _arg1$$18.tail;\n        continue exists;\n      }\n    } else {\n      return false;\n    }\n\n    break;\n  }\n}\nexport function exists2($f$$52$$182, $bs$$2$$183, $cs$$2$$184) {\n  exists2: while (true) {\n    const f$$52 = $f$$52$$182,\n          bs$$2 = $bs$$2$$183,\n          cs$$2 = $cs$$2$$184;\n    var $target$$185, x$$44, xs$$82, y$$12, ys$$18;\n\n    if (bs$$2.tail != null) {\n      if (cs$$2.tail != null) {\n        $target$$185 = 1;\n        x$$44 = bs$$2.head;\n        xs$$82 = bs$$2.tail;\n        y$$12 = cs$$2.head;\n        ys$$18 = cs$$2.tail;\n      } else {\n        $target$$185 = 2;\n      }\n    } else if (cs$$2.tail == null) {\n      $target$$185 = 0;\n    } else {\n      $target$$185 = 2;\n    }\n\n    switch ($target$$185) {\n      case 0:\n        {\n          return false;\n        }\n\n      case 1:\n        {\n          if (f$$52(x$$44, y$$12)) {\n            return true;\n          } else {\n            $f$$52$$182 = f$$52;\n            $bs$$2$$183 = xs$$82;\n            $cs$$2$$184 = ys$$18;\n            continue exists2;\n          }\n        }\n\n      case 2:\n        {\n          throw new Error(\"Lists had different lengths\");\n        }\n    }\n\n    break;\n  }\n}\nexport function unzip(xs$$83) {\n  return foldBack(function (tupledArg$$2, tupledArg$$3) {\n    return [new List(tupledArg$$2[0], tupledArg$$3[0]), new List(tupledArg$$2[1], tupledArg$$3[1])];\n  }, xs$$83, [new List(), new List()]);\n}\nexport function unzip3(xs$$84) {\n  return foldBack(function (tupledArg$$4, tupledArg$$5) {\n    return [new List(tupledArg$$4[0], tupledArg$$5[0]), new List(tupledArg$$4[1], tupledArg$$5[1]), new List(tupledArg$$4[2], tupledArg$$5[2])];\n  }, xs$$84, [new List(), new List(), new List()]);\n}\nexport function zip(xs$$85, ys$$19) {\n  return map2(function (x$$47, y$$15) {\n    return [x$$47, y$$15];\n  }, xs$$85, ys$$19);\n}\nexport function zip3(xs$$86, ys$$20, zs$$5) {\n  return map3(function (x$$48, y$$16, z$$5) {\n    return [x$$48, y$$16, z$$5];\n  }, xs$$86, ys$$20, zs$$5);\n}\nexport function sort(xs$$87, comparer$$1) {\n  let xs$$89;\n  const xs$$88 = ofList(xs$$87, Array);\n  xs$$88.sort(function comparer$$2(x$$49, y$$17) {\n    return comparer$$1.Compare(x$$49, y$$17);\n  });\n  xs$$89 = xs$$88;\n  return ofArray(xs$$89);\n}\nexport function sortBy(projection, xs$$90, comparer$$3) {\n  let xs$$92;\n  const xs$$91 = ofList(xs$$90, Array);\n  xs$$91.sort(function comparer$$4(x$$50, y$$18) {\n    return comparer$$3.Compare(projection(x$$50), projection(y$$18));\n  });\n  xs$$92 = xs$$91;\n  return ofArray(xs$$92);\n}\nexport function sortDescending(xs$$93, comparer$$5) {\n  let xs$$95;\n  const xs$$94 = ofList(xs$$93, Array);\n  xs$$94.sort(function comparer$$6(x$$51, y$$19) {\n    return comparer$$5.Compare(x$$51, y$$19) * -1;\n  });\n  xs$$95 = xs$$94;\n  return ofArray(xs$$95);\n}\nexport function sortByDescending(projection$$1, xs$$96, comparer$$7) {\n  let xs$$98;\n  const xs$$97 = ofList(xs$$96, Array);\n  xs$$97.sort(function comparer$$8(x$$52, y$$20) {\n    return comparer$$7.Compare(projection$$1(x$$52), projection$$1(y$$20)) * -1;\n  });\n  xs$$98 = xs$$97;\n  return ofArray(xs$$98);\n}\nexport function sortWith(comparer$$9, xs$$99) {\n  let xs$$101;\n  const xs$$100 = ofList(xs$$99, Array);\n  xs$$100.sort(comparer$$9);\n  xs$$101 = xs$$100;\n  return ofArray(xs$$101);\n}\nexport function sum(xs$$102, adder) {\n  return fold(function (acc$$21, x$$53) {\n    return adder.Add(acc$$21, x$$53);\n  }, adder.GetZero(), xs$$102);\n}\nexport function sumBy(f$$53, xs$$103, adder$$1) {\n  return fold(function (acc$$22, x$$54) {\n    return adder$$1.Add(acc$$22, f$$53(x$$54));\n  }, adder$$1.GetZero(), xs$$103);\n}\nexport function maxBy(projection$$2, xs$$104, comparer$$11) {\n  return reduce(function (x$$55, y$$21) {\n    return comparer$$11.Compare(projection$$2(y$$21), projection$$2(x$$55)) > 0 ? y$$21 : x$$55;\n  }, xs$$104);\n}\nexport function max(li, comparer$$12) {\n  return reduce(function (x$$56, y$$22) {\n    return comparer$$12.Compare(y$$22, x$$56) > 0 ? y$$22 : x$$56;\n  }, li);\n}\nexport function minBy(projection$$3, xs$$105, comparer$$13) {\n  return reduce(function (x$$57, y$$23) {\n    return comparer$$13.Compare(projection$$3(y$$23), projection$$3(x$$57)) > 0 ? x$$57 : y$$23;\n  }, xs$$105);\n}\nexport function min(xs$$106, comparer$$14) {\n  return reduce(function (x$$58, y$$24) {\n    return comparer$$14.Compare(y$$24, x$$58) > 0 ? x$$58 : y$$24;\n  }, xs$$106);\n}\nexport function average(xs$$107, averager) {\n  const total = fold(function (acc$$23, x$$59) {\n    return averager.Add(acc$$23, x$$59);\n  }, averager.GetZero(), xs$$107);\n  return averager.DivideByInt(total, length(xs$$107));\n}\nexport function averageBy(f$$54, xs$$108, averager$$1) {\n  const total$$1 = fold(function (acc$$24, x$$60) {\n    return averager$$1.Add(acc$$24, f$$54(x$$60));\n  }, averager$$1.GetZero(), xs$$108);\n  return averager$$1.DivideByInt(total$$1, length(xs$$108));\n}\nexport function permute(f$$55, xs$$109) {\n  let xs$$110;\n  let array$$3;\n  array$$3 = ofList(xs$$109, Array);\n  xs$$110 = permute$$1(f$$55, array$$3);\n  return ofArray(xs$$110);\n}\nexport function chunkBySize(chunkSize, xs$$111) {\n  let xs$$114;\n  let xs$$112;\n  let array$$4;\n  array$$4 = ofList(xs$$111, Array);\n  xs$$112 = chunkBySize$$1(chunkSize, array$$4);\n  xs$$114 = ofArray(xs$$112);\n  return map(function f$$56(xs$$113) {\n    return ofArray(xs$$113);\n  }, xs$$114);\n}\nexport function skip(i$$16, xs$$115) {\n  const skipInner = function skipInner($i$$17$$240, $xs$$116$$241) {\n    skipInner: while (true) {\n      const i$$17 = $i$$17$$240,\n            xs$$116 = $xs$$116$$241;\n\n      if (i$$17 === 0) {\n        return xs$$116;\n      } else if (xs$$116.tail != null) {\n        $i$$17$$240 = i$$17 - 1;\n        $xs$$116$$241 = xs$$116.tail;\n        continue skipInner;\n      } else {\n        throw new Error(\"The input sequence has an insufficient number of elements.\");\n      }\n\n      break;\n    }\n  };\n\n  if (i$$16 < 0) {\n    throw new Error(\"The input must be non-negative.\");\n  } else {\n    var $target$$242, i$$20, xs$$119;\n\n    if (i$$16 === 0) {\n      $target$$242 = 0;\n    } else if (i$$16 === 1) {\n      if (xs$$115.tail != null) {\n        $target$$242 = 1;\n      } else {\n        $target$$242 = 2;\n        i$$20 = i$$16;\n        xs$$119 = xs$$115;\n      }\n    } else {\n      $target$$242 = 2;\n      i$$20 = i$$16;\n      xs$$119 = xs$$115;\n    }\n\n    switch ($target$$242) {\n      case 0:\n        {\n          return xs$$115;\n        }\n\n      case 1:\n        {\n          return xs$$115.tail;\n        }\n\n      case 2:\n        {\n          return skipInner(i$$20, xs$$119);\n        }\n    }\n  }\n}\nexport function skipWhile($predicate$$243, $xs$$120$$244) {\n  skipWhile: while (true) {\n    const predicate = $predicate$$243,\n          xs$$120 = $xs$$120$$244;\n    var $target$$245, h$$4, t$$4;\n\n    if (xs$$120.tail != null) {\n      if (predicate(xs$$120.head)) {\n        $target$$245 = 0;\n        h$$4 = xs$$120.head;\n        t$$4 = xs$$120.tail;\n      } else {\n        $target$$245 = 1;\n      }\n    } else {\n      $target$$245 = 1;\n    }\n\n    switch ($target$$245) {\n      case 0:\n        {\n          $predicate$$243 = predicate;\n          $xs$$120$$244 = t$$4;\n          continue skipWhile;\n        }\n\n      case 1:\n        {\n          return xs$$120;\n        }\n    }\n\n    break;\n  }\n}\nexport function takeSplitAux($error$$246, $i$$21$$247, $acc$$25$$248, $xs$$121$$249) {\n  takeSplitAux: while (true) {\n    const error = $error$$246,\n          i$$21 = $i$$21$$247,\n          acc$$25 = $acc$$25$$248,\n          xs$$121 = $xs$$121$$249;\n\n    if (i$$21 === 0) {\n      return [reverse(acc$$25), xs$$121];\n    } else if (xs$$121.tail != null) {\n      $error$$246 = error;\n      $i$$21$$247 = i$$21 - 1;\n      $acc$$25$$248 = new List(xs$$121.head, acc$$25);\n      $xs$$121$$249 = xs$$121.tail;\n      continue takeSplitAux;\n    } else {\n      if (error) {\n        throw new Error(\"The input sequence has an insufficient number of elements.\");\n      } else {\n        return [reverse(acc$$25), xs$$121];\n      }\n    }\n\n    break;\n  }\n}\nexport function take(i$$22, xs$$123) {\n  if (i$$22 < 0) {\n    throw new Error(\"The input must be non-negative.\");\n  } else {\n    var $target$$252, i$$25, xs$$124;\n\n    if (i$$22 === 0) {\n      $target$$252 = 0;\n    } else if (i$$22 === 1) {\n      if (xs$$123.tail != null) {\n        $target$$252 = 1;\n      } else {\n        $target$$252 = 2;\n        i$$25 = i$$22;\n        xs$$124 = xs$$123;\n      }\n    } else {\n      $target$$252 = 2;\n      i$$25 = i$$22;\n      xs$$124 = xs$$123;\n    }\n\n    switch ($target$$252) {\n      case 0:\n        {\n          return new List();\n        }\n\n      case 1:\n        {\n          return new List(xs$$123.head, new List());\n        }\n\n      case 2:\n        {\n          const tuple = takeSplitAux(true, i$$25, new List(), xs$$124);\n          return tuple[0];\n        }\n    }\n  }\n}\nexport function takeWhile(predicate$$1, xs$$125) {\n  if (xs$$125.tail != null) {\n    if (xs$$125.tail.tail == null) {\n      if (predicate$$1(xs$$125.head)) {\n        return xs$$125;\n      } else {\n        return xs$$125.tail;\n      }\n    } else {\n      if (!predicate$$1(xs$$125.head)) {\n        return new List();\n      } else {\n        return new List(xs$$125.head, takeWhile(predicate$$1, xs$$125.tail));\n      }\n    }\n  } else {\n    return xs$$125;\n  }\n}\nexport function truncate(i$$26, xs$$127) {\n  if (i$$26 < 0) {\n    throw new Error(\"The input must be non-negative.\");\n  } else {\n    var $target$$257, i$$29, xs$$128;\n\n    if (i$$26 === 0) {\n      $target$$257 = 0;\n    } else if (i$$26 === 1) {\n      if (xs$$127.tail != null) {\n        $target$$257 = 1;\n      } else {\n        $target$$257 = 2;\n        i$$29 = i$$26;\n        xs$$128 = xs$$127;\n      }\n    } else {\n      $target$$257 = 2;\n      i$$29 = i$$26;\n      xs$$128 = xs$$127;\n    }\n\n    switch ($target$$257) {\n      case 0:\n        {\n          return new List();\n        }\n\n      case 1:\n        {\n          return new List(xs$$127.head, new List());\n        }\n\n      case 2:\n        {\n          const tuple$$1 = takeSplitAux(false, i$$29, new List(), xs$$128);\n          return tuple$$1[0];\n        }\n    }\n  }\n}\nexport function splitAt(i$$30, xs$$129) {\n  if (i$$30 < 0) {\n    throw new Error(\"The input must be non-negative.\");\n  } else {\n    var $target$$260, i$$33, xs$$131;\n\n    if (i$$30 === 0) {\n      $target$$260 = 0;\n    } else if (i$$30 === 1) {\n      if (xs$$129.tail != null) {\n        $target$$260 = 1;\n      } else {\n        $target$$260 = 2;\n        i$$33 = i$$30;\n        xs$$131 = xs$$129;\n      }\n    } else {\n      $target$$260 = 2;\n      i$$33 = i$$30;\n      xs$$131 = xs$$129;\n    }\n\n    switch ($target$$260) {\n      case 0:\n        {\n          return [new List(), xs$$129];\n        }\n\n      case 1:\n        {\n          return [new List(xs$$129.head, new List()), xs$$129.tail];\n        }\n\n      case 2:\n        {\n          return takeSplitAux(true, i$$33, new List(), xs$$131);\n        }\n    }\n  }\n}\nexport function outOfRange() {\n  throw new Error(\"Index out of range\");\n}\nexport function slice(lower, upper, xs$$132) {\n  const lower$$1 = defaultArg(lower, 0) | 0;\n  const hasUpper = upper != null;\n\n  if (lower$$1 < 0) {\n    return outOfRange();\n  } else if (hasUpper ? upper < lower$$1 : false) {\n    return new List();\n  } else {\n    let lastIndex = -1 | 0;\n    let res$$2;\n    const state$$13 = new List();\n    res$$2 = foldIndexed(function f$$57(i$$34, acc$$26, x$$67) {\n      lastIndex = i$$34;\n\n      if (lower$$1 <= i$$34 ? !hasUpper ? true : i$$34 <= upper : false) {\n        return new List(x$$67, acc$$26);\n      } else {\n        return acc$$26;\n      }\n    }, state$$13, xs$$132);\n\n    if (lower$$1 > lastIndex + 1 ? true : hasUpper ? upper > lastIndex : false) {\n      outOfRange();\n    }\n\n    return reverse(res$$2);\n  }\n}\nexport function distinctBy(projection$$4, xs$$134, eq$$2) {\n  const hashSet = createMutable([], eq$$2);\n  return filter(function f$$58($arg$$1) {\n    const arg00$$1 = projection$$4($arg$$1);\n    return addToSet(arg00$$1, hashSet);\n  }, xs$$134);\n}\nexport function distinct(xs$$136, eq$$3) {\n  return distinctBy(function (x$$68) {\n    return x$$68;\n  }, xs$$136, eq$$3);\n}\nexport function exactlyOne(xs$$137) {\n  if (xs$$137.tail != null) {\n    if (xs$$137.tail.tail != null) {\n      throw new Error(\"Input list too long\\\\nParameter name: list\");\n    } else {\n      return xs$$137.head;\n    }\n  } else {\n    throw new Error(\"The input sequence was empty\\\\nParameter name: list\");\n  }\n}\nexport function groupBy(projection$$5, xs$$139, eq$$4) {\n  const dict = createMutable$$1([], eq$$4);\n  let keys = new List();\n  iterate(function f$$59(v$$2) {\n    const key = projection$$5(v$$2);\n    const matchValue$$16 = tryGetValue(dict, key, null);\n\n    if (matchValue$$16[0]) {\n      dict.set(key, new List(v$$2, matchValue$$16[1]));\n    } else {\n      addToDict(dict, key, new List(v$$2, new List()));\n      keys = new List(key, keys);\n    }\n  }, xs$$139);\n  let result$$1 = new List();\n  const xs$$141 = keys;\n  iterate(function f$$60(key$$1) {\n    result$$1 = new List([key$$1, reverse(getItemFromDict(dict, key$$1))], result$$1);\n  }, xs$$141);\n  return result$$1;\n}\nexport function countBy(projection$$6, xs$$142, eq$$5) {\n  const dict$$1 = createMutable$$1([], eq$$5);\n  let keys$$1 = new List();\n  iterate(function f$$61(v$$3) {\n    const key$$2 = projection$$6(v$$3);\n    const matchValue$$17 = tryGetValue(dict$$1, key$$2, 0);\n\n    if (matchValue$$17[0]) {\n      dict$$1.set(key$$2, matchValue$$17[1] + 1);\n    } else {\n      dict$$1.set(key$$2, 1);\n      keys$$1 = new List(key$$2, keys$$1);\n    }\n  }, xs$$142);\n  let result$$2 = new List();\n  const xs$$144 = keys$$1;\n  iterate(function f$$62(key$$3) {\n    result$$2 = new List([key$$3, getItemFromDict(dict$$1, key$$3)], result$$2);\n  }, xs$$144);\n  return result$$2;\n}\nexport function where(predicate$$2, xs$$145) {\n  return filter(predicate$$2, xs$$145);\n}\nexport function pairwise(xs$$146) {\n  const inner = function inner($xs$$147$$287, $acc$$27$$288, $x1$$1$$289) {\n    inner: while (true) {\n      const xs$$147 = $xs$$147$$287,\n            acc$$27 = $acc$$27$$288,\n            x1$$1 = $x1$$1$$289;\n\n      if (xs$$147.tail != null) {\n        let copyOfStruct = acc$$27;\n        copyOfStruct.push([x1$$1, xs$$147.head]);\n        $xs$$147$$287 = xs$$147.tail;\n        $acc$$27$$288 = acc$$27;\n        $x1$$1$$289 = xs$$147.head;\n        continue inner;\n      } else {\n        return ofArray(acc$$27);\n      }\n\n      break;\n    }\n  };\n\n  var $target$$290, x1$$2, x2$$2, xs$$149;\n\n  if (xs$$146.tail != null) {\n    if (xs$$146.tail.tail != null) {\n      $target$$290 = 1;\n      x1$$2 = xs$$146.head;\n      x2$$2 = xs$$146.tail.head;\n      xs$$149 = xs$$146.tail.tail;\n    } else {\n      $target$$290 = 0;\n    }\n  } else {\n    $target$$290 = 0;\n  }\n\n  switch ($target$$290) {\n    case 0:\n      {\n        return new List();\n      }\n\n    case 1:\n      {\n        const acc$$28 = [];\n        acc$$28.push([x1$$2, x2$$2]);\n        const clo1 = partialApply(2, inner, [xs$$149]);\n        const clo2 = clo1(acc$$28);\n        return clo2(x2$$2);\n      }\n  }\n}\nexport function windowed(windowSize, source) {\n  if (windowSize <= 0) {\n    throw new Error(\"windowSize must be positive\");\n  }\n\n  let res$$3 = new List();\n\n  for (let i$$35 = length(source); i$$35 >= windowSize; i$$35--) {\n    res$$3 = new List(slice(i$$35 - windowSize, i$$35 - 1, source), res$$3);\n  }\n\n  return res$$3;\n}\nexport function splitInto(chunks, source$$1) {\n  let xs$$152;\n  let xs$$150;\n  let array$$5;\n  array$$5 = ofList(source$$1, Array);\n  xs$$150 = splitInto$$1(chunks, array$$5);\n  xs$$152 = ofArray(xs$$150);\n  return map(function f$$63(xs$$151) {\n    return ofArray(xs$$151);\n  }, xs$$152);\n}\nexport function transpose(lists$$1) {\n  let xs$$154;\n  let source$$3;\n  source$$3 = transpose$$1(lists$$1);\n  xs$$154 = map$$1(ofSeq, source$$3);\n  return ofSeq(xs$$154);\n}","export class CancellationToken {\n  constructor(cancelled = false) {\n    this._id = 0;\n    this._cancelled = cancelled;\n    this._listeners = new Map();\n  }\n\n  get isCancelled() {\n    return this._cancelled;\n  }\n\n  cancel() {\n    if (!this._cancelled) {\n      this._cancelled = true;\n\n      for (const [, listener] of this._listeners) {\n        listener();\n      }\n    }\n  }\n\n  addListener(f) {\n    const id = this._id;\n\n    this._listeners.set(this._id++, f);\n\n    return id;\n  }\n\n  removeListener(id) {\n    return this._listeners.delete(id);\n  }\n\n  register(f, state) {\n    const $ = this;\n    const id = this.addListener(state == null ? f : () => f(state));\n    return {\n      Dispose() {\n        $.removeListener(id);\n      }\n\n    };\n  }\n\n}\nexport class OperationCanceledError extends Error {\n  constructor() {\n    super(\"The operation was canceled\");\n    Object.setPrototypeOf(this, OperationCanceledError.prototype);\n  }\n\n}\nexport class Trampoline {\n  constructor() {\n    this.callCount = 0;\n  }\n\n  static get maxTrampolineCallCount() {\n    return 2000;\n  }\n\n  incrementAndCheck() {\n    return this.callCount++ > Trampoline.maxTrampolineCallCount;\n  }\n\n  hijack(f) {\n    this.callCount = 0;\n    setTimeout(f, 0);\n  }\n\n}\nexport function protectedCont(f) {\n  return ctx => {\n    if (ctx.cancelToken.isCancelled) {\n      ctx.onCancel(new OperationCanceledError());\n    } else if (ctx.trampoline.incrementAndCheck()) {\n      ctx.trampoline.hijack(() => {\n        try {\n          f(ctx);\n        } catch (err) {\n          ctx.onError(err);\n        }\n      });\n    } else {\n      try {\n        f(ctx);\n      } catch (err) {\n        ctx.onError(err);\n      }\n    }\n  };\n}\nexport function protectedBind(computation, binder) {\n  return protectedCont(ctx => {\n    computation({\n      onSuccess: x => {\n        try {\n          binder(x)(ctx);\n        } catch (ex) {\n          ctx.onError(ex);\n        }\n      },\n      onError: ctx.onError,\n      onCancel: ctx.onCancel,\n      cancelToken: ctx.cancelToken,\n      trampoline: ctx.trampoline\n    });\n  });\n}\nexport function protectedReturn(value) {\n  return protectedCont(ctx => ctx.onSuccess(value));\n}\nexport class AsyncBuilder {\n  Bind(computation, binder) {\n    return protectedBind(computation, binder);\n  }\n\n  Combine(computation1, computation2) {\n    return this.Bind(computation1, () => computation2);\n  }\n\n  Delay(generator) {\n    return protectedCont(ctx => generator()(ctx));\n  }\n\n  For(sequence, body) {\n    const iter = sequence[Symbol.iterator]();\n    let cur = iter.next();\n    return this.While(() => !cur.done, this.Delay(() => {\n      const res = body(cur.value);\n      cur = iter.next();\n      return res;\n    }));\n  }\n\n  Return(value) {\n    return protectedReturn(value);\n  }\n\n  ReturnFrom(computation) {\n    return computation;\n  }\n\n  TryFinally(computation, compensation) {\n    return protectedCont(ctx => {\n      computation({\n        onSuccess: x => {\n          compensation();\n          ctx.onSuccess(x);\n        },\n        onError: x => {\n          compensation();\n          ctx.onError(x);\n        },\n        onCancel: x => {\n          compensation();\n          ctx.onCancel(x);\n        },\n        cancelToken: ctx.cancelToken,\n        trampoline: ctx.trampoline\n      });\n    });\n  }\n\n  TryWith(computation, catchHandler) {\n    return protectedCont(ctx => {\n      computation({\n        onSuccess: ctx.onSuccess,\n        onCancel: ctx.onCancel,\n        cancelToken: ctx.cancelToken,\n        trampoline: ctx.trampoline,\n        onError: ex => {\n          try {\n            catchHandler(ex)(ctx);\n          } catch (ex2) {\n            ctx.onError(ex2);\n          }\n        }\n      });\n    });\n  }\n\n  Using(resource, binder) {\n    return this.TryFinally(binder(resource), () => resource.Dispose());\n  }\n\n  While(guard, computation) {\n    if (guard()) {\n      return this.Bind(computation, () => this.While(guard, computation));\n    } else {\n      return this.Return(void 0);\n    }\n  }\n\n  Zero() {\n    return protectedCont(ctx => ctx.onSuccess(void 0));\n  }\n\n}\nexport const singleton = new AsyncBuilder();","import { OperationCanceledError, Trampoline } from \"./AsyncBuilder\";\nimport { CancellationToken } from \"./AsyncBuilder\";\nimport { protectedCont } from \"./AsyncBuilder\";\nimport { protectedBind } from \"./AsyncBuilder\";\nimport { protectedReturn } from \"./AsyncBuilder\";\nimport { choice1, choice2 } from \"./Option\";\nimport { map } from \"./Seq\"; // Implemented just for type references\n\nexport default class Async {}\n\nfunction emptyContinuation(_x) {} // NOP\n// MakeAsync: body:(AsyncActivation<'T> -> AsyncReturn) -> Async<'T>\n\n\nexport function makeAsync(body) {\n  return body;\n} // Invoke: computation: Async<'T> -> ctxt:AsyncActivation<'T> -> AsyncReturn\n\nexport function invoke(computation, ctx) {\n  return computation(ctx);\n} // CallThenInvoke: ctxt:AsyncActivation<'T> -> result1:'U -> part2:('U -> Async<'T>) -> AsyncReturn\n\nexport function callThenInvoke(ctx, result1, part2) {\n  return part2(result1)(ctx);\n} // Bind: ctxt:AsyncActivation<'T> -> part1:Async<'U> -> part2:('U -> Async<'T>) -> AsyncReturn\n\nexport function bind(ctx, part1, part2) {\n  return protectedBind(part1, part2)(ctx);\n}\nexport function createCancellationToken(arg) {\n  const token = new CancellationToken(typeof arg === \"boolean\" ? arg : false);\n\n  if (typeof arg === \"number\") {\n    setTimeout(() => {\n      token.cancel();\n    }, arg);\n  }\n\n  return token;\n}\nexport function cancel(token) {\n  token.cancel();\n}\nexport function cancelAfter(token, ms) {\n  setTimeout(() => {\n    token.cancel();\n  }, ms);\n}\nexport function isCancellationRequested(token) {\n  return token != null && token.isCancelled;\n}\nexport function startChild(computation) {\n  const promise = startAsPromise(computation); // JS Promises are hot, computation has already started\n  // but we delay returning the result\n\n  return protectedCont(ctx => protectedReturn(awaitPromise(promise))(ctx));\n}\nexport function awaitPromise(p) {\n  return fromContinuations(conts => p.then(conts[0]).catch(err => (err instanceof OperationCanceledError ? conts[2] : conts[1])(err)));\n}\nexport function cancellationToken() {\n  return protectedCont(ctx => ctx.onSuccess(ctx.cancelToken));\n}\nexport const defaultCancellationToken = new CancellationToken();\nexport function catchAsync(work) {\n  return protectedCont(ctx => {\n    work({\n      onSuccess: x => ctx.onSuccess(choice1(x)),\n      onError: ex => ctx.onSuccess(choice2(ex)),\n      onCancel: ctx.onCancel,\n      cancelToken: ctx.cancelToken,\n      trampoline: ctx.trampoline\n    });\n  });\n}\nexport function fromContinuations(f) {\n  return protectedCont(ctx => f([ctx.onSuccess, ctx.onError, ctx.onCancel]));\n}\nexport function ignore(computation) {\n  return protectedBind(computation, _x => protectedReturn(void 0));\n}\nexport function parallel(computations) {\n  return awaitPromise(Promise.all(map(w => startAsPromise(w), computations)));\n}\nexport function sleep(millisecondsDueTime) {\n  return protectedCont(ctx => {\n    let tokenId;\n    const timeoutId = setTimeout(() => {\n      ctx.cancelToken.removeListener(tokenId);\n      ctx.onSuccess(void 0);\n    }, millisecondsDueTime);\n    tokenId = ctx.cancelToken.addListener(() => {\n      clearTimeout(timeoutId);\n      ctx.onCancel(new OperationCanceledError());\n    });\n  });\n}\nexport function start(computation, cancellationToken) {\n  return startWithContinuations(computation, cancellationToken);\n}\nexport function startImmediate(computation, cancellationToken) {\n  return start(computation, cancellationToken);\n}\nexport function startWithContinuations(computation, continuation, exceptionContinuation, cancellationContinuation, cancelToken) {\n  if (typeof continuation !== \"function\") {\n    cancelToken = continuation;\n    continuation = undefined;\n  }\n\n  const trampoline = new Trampoline();\n  computation({\n    onSuccess: continuation ? continuation : emptyContinuation,\n    onError: exceptionContinuation ? exceptionContinuation : emptyContinuation,\n    onCancel: cancellationContinuation ? cancellationContinuation : emptyContinuation,\n    cancelToken: cancelToken ? cancelToken : defaultCancellationToken,\n    trampoline\n  });\n}\nexport function startAsPromise(computation, cancellationToken) {\n  return new Promise((resolve, reject) => startWithContinuations(computation, resolve, reject, reject, cancellationToken ? cancellationToken : defaultCancellationToken));\n}","import { some } from \"../fable-library.2.4.13/Option\";\nimport Timer from \"../fable-library.2.4.13/Timer\";\nimport { add } from \"../fable-library.2.4.13/Observable\";\nexport function Log$$$onError(text, ex) {\n  console.error(some(text), ex);\n}\nexport function Log$$$toConsole(text$$1, o) {\n  console.log(some(text$$1), o);\n}\nexport function Timer$$$delay(interval, callback) {\n  let t;\n  let returnVal = new Timer(interval);\n  returnVal.AutoReset = false;\n  t = returnVal;\n  add(callback, t.Elapsed);\n  t.Enabled = true;\n  t.Start();\n}","import { concat, map, iterate } from \"../fable-library.2.4.13/List\";\nimport { List } from \"../fable-library.2.4.13/Types\";\nimport { startImmediate, catchAsync } from \"../fable-library.2.4.13/Async\";\nimport { singleton } from \"../fable-library.2.4.13/AsyncBuilder\";\nimport { Timer$$$delay as Timer$0024$0024$0024delay } from \"./prelude\";\nexport function Cmd$$$exec(dispatch, cmd) {\n  iterate(function action(sub) {\n    sub(dispatch);\n  }, cmd);\n}\nexport function Cmd$$$none() {\n  return new List();\n}\nexport function Cmd$$$map(f, cmd$$1) {\n  return map(function mapping(g) {\n    return function ($arg$$2) {\n      g(function ($arg$$1) {\n        $arg$$2(f($arg$$1));\n      });\n    };\n  }, cmd$$1);\n}\nexport function Cmd$$$batch(cmds) {\n  return concat(cmds);\n}\nexport function Cmd$$$ofSub(sub$$1) {\n  return new List(sub$$1, new List());\n}\nexport function Cmd$002EOfFunc$$$either(task, arg, ofSuccess, ofError) {\n  return new List(function bind(dispatch$$2) {\n    try {\n      const $arg$$3 = task(arg);\n      return dispatch$$2(ofSuccess($arg$$3));\n    } catch (x) {\n      return dispatch$$2(ofError(x));\n    }\n  }, new List());\n}\nexport function Cmd$002EOfFunc$$$perform(task$$1, arg$$1, ofSuccess$$1) {\n  return new List(function bind$$1(dispatch$$3) {\n    try {\n      const $arg$$5 = task$$1(arg$$1);\n      dispatch$$3(ofSuccess$$1($arg$$5));\n    } catch (x$$1) {}\n  }, new List());\n}\nexport function Cmd$002EOfFunc$$$attempt(task$$2, arg$$2, ofError$$1) {\n  return new List(function bind$$2(dispatch$$4) {\n    try {\n      task$$2(arg$$2);\n    } catch (x$$2) {\n      dispatch$$4(ofError$$1(x$$2));\n    }\n  }, new List());\n}\nexport function Cmd$002EOfFunc$$$result(msg) {\n  return new List(function (dispatch$$5) {\n    dispatch$$5(msg);\n  }, new List());\n}\nexport function Cmd$002EOfAsyncWith$$$either(start, task$$3, arg$$3, ofSuccess$$2, ofError$$2) {\n  return new List(function ($arg$$7) {\n    start((singleton.Delay(function () {\n      var arg00;\n      return singleton.Bind((arg00 = task$$3(arg$$3), (catchAsync(arg00))), function (_arg1) {\n        $arg$$7(_arg1.tag === 1 ? ofError$$2(_arg1.fields[0]) : ofSuccess$$2(_arg1.fields[0]));\n        return singleton.Zero();\n      });\n    })));\n  }, new List());\n}\nexport function Cmd$002EOfAsyncWith$$$perform(start$$1, task$$4, arg$$4, ofSuccess$$3) {\n  return new List(function ($arg$$8) {\n    start$$1((singleton.Delay(function () {\n      var arg00$$1;\n      return singleton.Bind((arg00$$1 = task$$4(arg$$4), (catchAsync(arg00$$1))), function (_arg1$$1) {\n        if (_arg1$$1.tag === 0) {\n          $arg$$8(ofSuccess$$3(_arg1$$1.fields[0]));\n          return singleton.Zero();\n        } else {\n          return singleton.Zero();\n        }\n      });\n    })));\n  }, new List());\n}\nexport function Cmd$002EOfAsyncWith$$$attempt(start$$2, task$$5, arg$$5, ofError$$3) {\n  return new List(function ($arg$$9) {\n    start$$2((singleton.Delay(function () {\n      var arg00$$2;\n      return singleton.Bind((arg00$$2 = task$$5(arg$$5), (catchAsync(arg00$$2))), function (_arg1$$2) {\n        if (_arg1$$2.tag === 1) {\n          $arg$$9(ofError$$3(_arg1$$2.fields[0]));\n          return singleton.Zero();\n        } else {\n          return singleton.Zero();\n        }\n      });\n    })));\n  }, new List());\n}\nexport function Cmd$002EOfAsyncWith$$$result(start$$3, task$$6) {\n  return new List(function ($arg$$10) {\n    start$$3((singleton.Delay(function () {\n      return singleton.Bind((catchAsync(task$$6)), function (_arg1$$3) {\n        if (_arg1$$3.tag === 0) {\n          $arg$$10(_arg1$$3.fields[0]);\n          return singleton.Zero();\n        } else {\n          return singleton.Zero();\n        }\n      });\n    })));\n  }, new List());\n}\nexport function Cmd$002EOfAsync$$$start(x$$8) {\n  Timer$0024$0024$0024delay(0, function (_arg1$$4) {\n    startImmediate(x$$8);\n  });\n}\nexport function Cmd$002EOfPromise$$$either(task$$7, arg$$6, ofSuccess$$4, ofError$$4) {\n  return new List(function bind$$7(dispatch$$10) {\n    const value$$1 = task$$7(arg$$6).then(function ($arg$$11) {\n      return dispatch$$10(ofSuccess$$4($arg$$11));\n    }).catch(function ($arg$$13) {\n      return dispatch$$10((ofError$$4(($arg$$13))));\n    });\n    void value$$1;\n  }, new List());\n}\nexport function Cmd$002EOfPromise$$$perform(task$$8, arg$$7, ofSuccess$$5) {\n  return new List(function bind$$8(dispatch$$11) {\n    const value$$2 = task$$8(arg$$7).then(function ($arg$$14) {\n      return dispatch$$11(ofSuccess$$5($arg$$14));\n    });\n    void value$$2;\n  }, new List());\n}\nexport function Cmd$002EOfPromise$$$attempt(task$$9, arg$$8, ofError$$5) {\n  return new List(function bind$$9(dispatch$$12) {\n    const value$$4 = task$$9(arg$$8).catch(function ($arg$$16) {\n      dispatch$$12((ofError$$5(($arg$$16))));\n    });\n    void value$$4;\n  }, new List());\n}\nexport function Cmd$002EOfPromise$$$result(task$$10) {\n  return new List(function bind$$10(dispatch$$13) {\n    const value$$5 = task$$10.then(dispatch$$13);\n    void value$$5;\n  }, new List());\n}\nexport function Cmd$$$attemptFunc(task$$11, arg$$9, ofError$$6) {\n  return Cmd$002EOfFunc$$$attempt(task$$11, arg$$9, ofError$$6);\n}","import { List } from \"./fable-library.2.4.13/Types\";\nimport { Model, Role as Role$$1 } from \"./Model\";\nimport { Cmd$$$none as Cmd$0024$0024$0024none } from \"./Fable.Elmish.3.0.6/cmd\";\nimport { getPermissions as getPermissions$$1 } from \"./js/jwt\";\nexport const initialState = new Model(new List(), null, new Role$$1(2, \"Visitor\"));\nexport function init(_arg1) {\n  return [initialState, Cmd$0024$0024$0024none()];\n}\nconst getPermissions = getPermissions$$1;\n\nfunction getRole(token$$1) {\n  const permissions = getPermissions(token$$1);\n\n  const hasPermission = function hasPermission(name) {\n    return permissions.some(function (p) {\n      return p === name;\n    });\n  };\n\n  if (hasPermission(\"delete:location\")) {\n    return new Role$$1(0, \"Admin\");\n  } else if (hasPermission(\"write:location\")) {\n    return new Role$$1(1, \"Editor\");\n  } else {\n    return new Role$$1(2, \"Visitor\");\n  }\n}\n\nexport function update(msg, model) {\n  var AuthorizationToken, Role;\n  return [(AuthorizationToken = msg.fields[0], (Role = getRole(msg.fields[0]), new Model(model.Events, AuthorizationToken, Role))), Cmd$0024$0024$0024none()];\n}","function parseJwt(token) {\n  const base64Url = token.split(\".\")[1];\n  const base64 = base64Url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const jsonPayload = decodeURIComponent(atob(base64).split(\"\").map(function (c) {\n    return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n  }).join(\"\"));\n  return JSON.parse(jsonPayload);\n}\n\n;\nexport function getPermissions(jwtToken) {\n  const token = parseJwt(jwtToken) || {\n    permissions: []\n  };\n  return token.permissions;\n}","import { declare, Union } from \"../fable-library.2.4.13/Types\";\nimport { type, union, int32, array } from \"../fable-library.2.4.13/Reflection\";\nimport { max, comparePrimitives } from \"../fable-library.2.4.13/Util\";\nimport { ofSeq, fill } from \"../fable-library.2.4.13/Array\";\nimport { some } from \"../fable-library.2.4.13/Option\";\nimport { append, delay, collect, rangeNumber, singleton, take, skip } from \"../fable-library.2.4.13/Seq\";\nexport const RingState$00601 = declare(function Elmish_RingState(tag, name, ...fields) {\n  Union.call(this, tag, name, ...fields);\n}, Union);\nexport function RingState$00601$reflection($gen$$4) {\n  return union(\"Elmish.RingState`1\", [$gen$$4], RingState$00601, () => [[\"Writable\", [array($gen$$4), int32]], [\"ReadWritable\", [array($gen$$4), int32, int32]]]);\n}\nexport const RingBuffer$00601 = declare(function Elmish_RingBuffer(size) {\n  const $this$$1 = this;\n  $this$$1.state = new RingState$00601(0, \"Writable\", fill(new Array(max(comparePrimitives, size, 10)), 0, max(comparePrimitives, size, 10), null), 0);\n});\nexport function RingBuffer$00601$reflection($gen$$5) {\n  return type(\"Elmish.RingBuffer`1\", [$gen$$5]);\n}\nexport function RingBuffer$00601$$$$002Ector$$Z524259A4(size) {\n  return this instanceof RingBuffer$00601 ? RingBuffer$00601.call(this, size) : new RingBuffer$00601(size);\n}\nexport function RingBuffer$00601$$Pop(__) {\n  const matchValue = __.state;\n\n  if (matchValue.tag === 1) {\n    const rix$0027 = (matchValue.fields[2] + 1) % matchValue.fields[0].length | 0;\n    const matchValue$$1 = rix$0027 === matchValue.fields[1];\n\n    if (matchValue$$1) {\n      __.state = new RingState$00601(0, \"Writable\", matchValue.fields[0], matchValue.fields[1]);\n    } else {\n      __.state = new RingState$00601(1, \"ReadWritable\", matchValue.fields[0], matchValue.fields[1], rix$0027);\n    }\n\n    return some(matchValue.fields[0][matchValue.fields[2]]);\n  } else {\n    return null;\n  }\n}\nexport function RingBuffer$00601$$Push$$2B595(__$$1, item) {\n  const matchValue$$2 = __$$1.state;\n\n  if (matchValue$$2.tag === 1) {\n    matchValue$$2.fields[0][matchValue$$2.fields[1]] = item;\n    const wix$0027 = (matchValue$$2.fields[1] + 1) % matchValue$$2.fields[0].length | 0;\n    const matchValue$$3 = wix$0027 === matchValue$$2.fields[2];\n\n    if (matchValue$$3) {\n      __$$1.state = new RingState$00601(1, \"ReadWritable\", (RingBuffer$00601$$doubleSize(__$$1, matchValue$$2.fields[2], matchValue$$2.fields[0])), matchValue$$2.fields[0].length, 0);\n    } else {\n      __$$1.state = new RingState$00601(1, \"ReadWritable\", matchValue$$2.fields[0], wix$0027, matchValue$$2.fields[2]);\n    }\n  } else {\n    matchValue$$2.fields[0][matchValue$$2.fields[1]] = item;\n    const wix$$1 = (matchValue$$2.fields[1] + 1) % matchValue$$2.fields[0].length | 0;\n    __$$1.state = new RingState$00601(1, \"ReadWritable\", matchValue$$2.fields[0], wix$$1, matchValue$$2.fields[1]);\n  }\n}\n\nfunction RingBuffer$00601$$doubleSize(this$, ix$$1, items$$4) {\n  const source$$2 = delay(function () {\n    return append((skip(ix$$1, items$$4)), delay(function () {\n      return append((take(ix$$1, items$$4)), delay(function () {\n        return collect(function (matchValue$$4) {\n          return singleton(null);\n        }, rangeNumber(0, 1, items$$4.length));\n      }));\n    }));\n  });\n  return ofSeq(source$$2, Array);\n}","import { defaultArg, value as value$$14, some } from \"./Option\";\nimport { min as min$$1, compare, addToDict, addToSet, getItemFromDict, tryGetValue, max as max$$1, comparePrimitives } from \"./Util\";\nimport { createMutable } from \"./Map\";\nimport { createMutable as createMutable$$1 } from \"./Set\";\nimport { List } from \"./Types\";\nimport { iterate as iterate$$1 } from \"./Seq\";\nconst indexNotFoundMsg = \"An index satisfying the predicate was not found in the collection.\";\nexport function append(array1, array2, cons) {\n  if (ArrayBuffer.isView(array1)) {\n    const len1 = array1.length | 0;\n    const len2 = array2.length | 0;\n    const newArray = new cons(len1 + len2);\n\n    for (let i = 0; i <= len1 - 1; i++) {\n      newArray[i] = array1[i];\n    }\n\n    for (let i$$1 = 0; i$$1 <= len2 - 1; i$$1++) {\n      newArray[i$$1 + len1] = array2[i$$1];\n    }\n\n    return newArray;\n  } else {\n    return array1.concat(array2);\n  }\n}\nexport function filter(predicate, array) {\n  return array.filter(predicate);\n}\nexport function fill(target, targetIndex, count, value) {\n  target.fill(value, targetIndex, targetIndex + count);\n  return target;\n}\nexport function getSubArray(array$$3, start$$1, count$$2) {\n  return array$$3.slice(start$$1, start$$1 + count$$2);\n}\nexport function last(array$$5) {\n  if (array$$5.length === 0) {\n    throw new Error(\"The input array was empty\\\\nParameter name: array\");\n  }\n\n  return array$$5[array$$5.length - 1];\n}\nexport function tryLast(array$$6) {\n  if (array$$6.length === 0) {\n    return null;\n  } else {\n    return some(array$$6[array$$6.length - 1]);\n  }\n}\nexport function mapIndexed(f, source, cons$$1) {\n  if (ArrayBuffer.isView(source)) {\n    const len = source.length | 0;\n    const target$$1 = new cons$$1(len);\n\n    for (let i$$2 = 0; i$$2 <= len - 1; i$$2++) {\n      target$$1[i$$2] = f(i$$2, source[i$$2]);\n    }\n\n    return target$$1;\n  } else {\n    return source.map(function (delegateArg0, delegateArg1) {\n      return f(delegateArg1, delegateArg0);\n    });\n  }\n}\nexport function map(f$$1, source$$1, cons$$2) {\n  if (ArrayBuffer.isView(source$$1)) {\n    const len$$1 = source$$1.length | 0;\n    const target$$2 = new cons$$2(len$$1);\n\n    for (let i$$4 = 0; i$$4 <= len$$1 - 1; i$$4++) {\n      target$$2[i$$4] = f$$1(source$$1[i$$4]);\n    }\n\n    return target$$2;\n  } else {\n    return source$$1.map(function mapping$$1(x$$1) {\n      return f$$1(x$$1);\n    });\n  }\n}\nexport function mapIndexed2(f$$2, source1, source2, cons$$3) {\n  if (source1.length !== source2.length) {\n    throw new Error(\"Arrays had different lengths\");\n  }\n\n  const result = new cons$$3(source1.length);\n\n  for (let i$$5 = 0; i$$5 <= source1.length - 1; i$$5++) {\n    result[i$$5] = f$$2(i$$5, source1[i$$5], source2[i$$5]);\n  }\n\n  return result;\n}\nexport function map2(f$$3, source1$$1, source2$$1, cons$$4) {\n  if (source1$$1.length !== source2$$1.length) {\n    throw new Error(\"Arrays had different lengths\");\n  }\n\n  const result$$1 = new cons$$4(source1$$1.length);\n\n  for (let i$$6 = 0; i$$6 <= source1$$1.length - 1; i$$6++) {\n    result$$1[i$$6] = f$$3(source1$$1[i$$6], source2$$1[i$$6]);\n  }\n\n  return result$$1;\n}\nexport function mapIndexed3(f$$4, source1$$2, source2$$2, source3, cons$$5) {\n  if (source1$$2.length !== source2$$2.length ? true : source2$$2.length !== source3.length) {\n    throw new Error(\"Arrays had different lengths\");\n  }\n\n  const result$$2 = new cons$$5(source1$$2.length);\n\n  for (let i$$7 = 0; i$$7 <= source1$$2.length - 1; i$$7++) {\n    result$$2[i$$7] = f$$4(i$$7, source1$$2[i$$7], source2$$2[i$$7], source3[i$$7]);\n  }\n\n  return result$$2;\n}\nexport function map3(f$$5, source1$$3, source2$$3, source3$$1, cons$$6) {\n  if (source1$$3.length !== source2$$3.length ? true : source2$$3.length !== source3$$1.length) {\n    throw new Error(\"Arrays had different lengths\");\n  }\n\n  const result$$3 = new cons$$6(source1$$3.length);\n\n  for (let i$$8 = 0; i$$8 <= source1$$3.length - 1; i$$8++) {\n    result$$3[i$$8] = f$$5(source1$$3[i$$8], source2$$3[i$$8], source3$$1[i$$8]);\n  }\n\n  return result$$3;\n}\nexport function mapFold(mapping$$2, state, array$$9, cons$$7) {\n  const matchValue = array$$9.length | 0;\n\n  if (matchValue === 0) {\n    return [[], state];\n  } else {\n    let acc = state;\n    const res = new cons$$7(matchValue);\n\n    for (let i$$9 = 0; i$$9 <= array$$9.length - 1; i$$9++) {\n      const patternInput = mapping$$2(acc, array$$9[i$$9]);\n      res[i$$9] = patternInput[0];\n      acc = patternInput[1];\n    }\n\n    return [res, acc];\n  }\n}\nexport function mapFoldBack(mapping$$3, array$$10, state$$1, cons$$8) {\n  const matchValue$$1 = array$$10.length | 0;\n\n  if (matchValue$$1 === 0) {\n    return [[], state$$1];\n  } else {\n    let acc$$1 = state$$1;\n    const res$$1 = new cons$$8(matchValue$$1);\n\n    for (let i$$10 = array$$10.length - 1; i$$10 >= 0; i$$10--) {\n      const patternInput$$1 = mapping$$3(array$$10[i$$10], acc$$1);\n      res$$1[i$$10] = patternInput$$1[0];\n      acc$$1 = patternInput$$1[1];\n    }\n\n    return [res$$1, acc$$1];\n  }\n}\nexport function indexed(source$$2) {\n  const len$$4 = source$$2.length | 0;\n  const target$$3 = new Array(len$$4);\n\n  for (let i$$11 = 0; i$$11 <= len$$4 - 1; i$$11++) {\n    target$$3[i$$11] = [i$$11, source$$2[i$$11]];\n  }\n\n  return target$$3;\n}\nexport function truncate(count$$4, array$$11) {\n  const count$$5 = max$$1(comparePrimitives, 0, count$$4) | 0;\n  return array$$11.slice(0, 0 + count$$5);\n}\nexport function concat(arrays, cons$$9) {\n  var arr$$4;\n  const arrays$$1 = Array.isArray(arrays) ? arrays : Array.from(arrays);\n  const matchValue$$2 = arrays$$1.length | 0;\n\n  switch (matchValue$$2) {\n    case 0:\n      {\n        return new cons$$9(0);\n      }\n\n    case 1:\n      {\n        return arrays$$1[0];\n      }\n\n    default:\n      {\n        if (arr$$4 = arrays$$1[0], ArrayBuffer.isView(arr$$4)) {\n          let totalIdx = 0;\n          let totalLength = 0;\n\n          for (let idx = 0; idx <= arrays$$1.length - 1; idx++) {\n            const arr$$5 = arrays$$1[idx];\n            totalLength = totalLength + arr$$5.length;\n          }\n\n          const result$$4 = new cons$$9(totalLength);\n\n          for (let idx$$1 = 0; idx$$1 <= arrays$$1.length - 1; idx$$1++) {\n            const arr$$6 = arrays$$1[idx$$1];\n\n            for (let j = 0; j <= arr$$6.length - 1; j++) {\n              result$$4[totalIdx] = arr$$6[j];\n              totalIdx = totalIdx + 1;\n            }\n          }\n\n          return result$$4;\n        } else {\n          return arrays$$1[0].concat(...arrays$$1.slice(1));\n        }\n      }\n  }\n}\nexport function collect(mapping$$4, array$$14, cons$$10) {\n  const mapped = map(mapping$$4, array$$14, Array);\n  return concat(mapped, cons$$10);\n}\nexport function countBy(projection, array$$15, eq) {\n  const dict = createMutable([], eq);\n  const keys = [];\n\n  for (let idx$$2 = 0; idx$$2 <= array$$15.length - 1; idx$$2++) {\n    const value$$2 = array$$15[idx$$2];\n    const key = projection(value$$2);\n    const matchValue$$3 = tryGetValue(dict, key, 0);\n\n    if (matchValue$$3[0]) {\n      dict.set(key, matchValue$$3[1] + 1);\n    } else {\n      dict.set(key, 1);\n      const value$$3 = keys.push(key);\n      void value$$3;\n    }\n  }\n\n  const result$$5 = map(function (key$$1) {\n    return [key$$1, getItemFromDict(dict, key$$1)];\n  }, keys, Array);\n  return result$$5;\n}\nexport function distinctBy(projection$$1, array$$17, eq$$1) {\n  const hashSet = createMutable$$1([], eq$$1);\n  return filter(function predicate$$2($arg$$3) {\n    const arg00 = projection$$1($arg$$3);\n    return addToSet(arg00, hashSet);\n  }, array$$17);\n}\nexport function distinct(array$$19, eq$$2) {\n  return distinctBy(function (x$$2) {\n    return x$$2;\n  }, array$$19, eq$$2);\n}\nexport function where(predicate$$3, array$$20) {\n  return array$$20.filter(predicate$$3);\n}\nexport function contains(value$$4, array$$22, eq$$3) {\n  const loop = function loop($i$$12$$79) {\n    loop: while (true) {\n      const i$$12 = $i$$12$$79;\n\n      if (i$$12 >= array$$22.length) {\n        return false;\n      } else if (eq$$3.Equals(value$$4, array$$22[i$$12])) {\n        return true;\n      } else {\n        $i$$12$$79 = i$$12 + 1;\n        continue loop;\n      }\n\n      break;\n    }\n  };\n\n  return loop(0);\n}\nexport function except(itemsToExclude, array$$23, eq$$4) {\n  if (array$$23.length === 0) {\n    return array$$23;\n  } else {\n    const cached = createMutable$$1(itemsToExclude, eq$$4);\n    return array$$23.filter(function predicate$$5(arg00$$1) {\n      return addToSet(arg00$$1, cached);\n    });\n  }\n}\nexport function groupBy(projection$$2, array$$26, cons$$11, eq$$5) {\n  const dict$$1 = createMutable([], eq$$5);\n  const keys$$1 = [];\n\n  for (let idx$$3 = 0; idx$$3 <= array$$26.length - 1; idx$$3++) {\n    const v = array$$26[idx$$3];\n    const key$$2 = projection$$2(v);\n    const matchValue$$4 = tryGetValue(dict$$1, key$$2, null);\n\n    if (matchValue$$4[0]) {\n      dict$$1.set(key$$2, new List(v, matchValue$$4[1]));\n    } else {\n      addToDict(dict$$1, key$$2, new List(v, new List()));\n      const value$$5 = keys$$1.push(key$$2);\n      void value$$5;\n    }\n  }\n\n  const result$$6 = map(function (key$$3) {\n    var array$$28;\n    return [key$$3, (array$$28 = cons$$11.from(getItemFromDict(dict$$1, key$$3)), array$$28.reverse())];\n  }, keys$$1, Array);\n  return result$$6;\n}\nexport function empty(cons$$12) {\n  return new cons$$12(0);\n}\nexport function singleton(value$$6, cons$$14) {\n  const ar = new cons$$14(1);\n  ar[0] = value$$6;\n  return ar;\n}\nexport function initialize(count$$8, initializer, cons$$15) {\n  if (count$$8 < 0) {\n    throw new Error(\"The input must be non-negative\\\\nParameter name: count\");\n  }\n\n  const result$$7 = new cons$$15(count$$8);\n\n  for (let i$$13 = 0; i$$13 <= count$$8 - 1; i$$13++) {\n    result$$7[i$$13] = initializer(i$$13);\n  }\n\n  return result$$7;\n}\nexport function pairwise(array$$30) {\n  if (array$$30.length < 2) {\n    return [];\n  } else {\n    const count$$9 = array$$30.length - 1 | 0;\n    const result$$8 = new Array(count$$9);\n\n    for (let i$$14 = 0; i$$14 <= count$$9 - 1; i$$14++) {\n      result$$8[i$$14] = [array$$30[i$$14], array$$30[i$$14 + 1]];\n    }\n\n    return result$$8;\n  }\n}\nexport function replicate(count$$10, initial, cons$$16) {\n  if (count$$10 < 0) {\n    throw new Error(\"The input must be non-negative\\\\nParameter name: count\");\n  }\n\n  const result$$9 = new cons$$16(count$$10);\n\n  for (let i$$15 = 0; i$$15 <= result$$9.length - 1; i$$15++) {\n    result$$9[i$$15] = initial;\n  }\n\n  return result$$9;\n}\nexport function copy(array$$31, cons$$17) {\n  return array$$31.slice();\n}\nexport function reverse(array$$33, cons$$18) {\n  const array$$35 = array$$33.slice();\n  return array$$35.reverse();\n}\nexport function scan(folder, state$$2, array$$37, cons$$19) {\n  const res$$2 = new cons$$19(array$$37.length + 1);\n  res$$2[0] = state$$2;\n\n  for (let i$$16 = 0; i$$16 <= array$$37.length - 1; i$$16++) {\n    res$$2[i$$16 + 1] = folder(res$$2[i$$16], array$$37[i$$16]);\n  }\n\n  return res$$2;\n}\nexport function scanBack(folder$$1, array$$38, state$$3, cons$$20) {\n  const res$$3 = new cons$$20(array$$38.length + 1);\n  res$$3[array$$38.length] = state$$3;\n\n  for (let i$$17 = array$$38.length - 1; i$$17 >= 0; i$$17--) {\n    res$$3[i$$17] = folder$$1(array$$38[i$$17], res$$3[i$$17 + 1]);\n  }\n\n  return res$$3;\n}\nexport function skip(count$$11, array$$39, cons$$21) {\n  if (count$$11 > array$$39.length) {\n    throw new Error(\"count is greater than array length\\\\nParameter name: count\");\n  }\n\n  if (count$$11 === array$$39.length) {\n    return new cons$$21(0);\n  } else {\n    const count$$12 = (count$$11 < 0 ? 0 : count$$11) | 0;\n    return array$$39.slice(count$$12);\n  }\n}\nexport function skipWhile(predicate$$7, array$$41, cons$$23) {\n  let count$$14 = 0;\n\n  while (count$$14 < array$$41.length ? predicate$$7(array$$41[count$$14]) : false) {\n    count$$14 = count$$14 + 1;\n  }\n\n  if (count$$14 === array$$41.length) {\n    return new cons$$23(0);\n  } else {\n    const count$$15 = count$$14 | 0;\n    return array$$41.slice(count$$15);\n  }\n}\nexport function take(count$$16, array$$43, cons$$25) {\n  if (count$$16 < 0) {\n    throw new Error(\"The input must be non-negative\\\\nParameter name: count\");\n  }\n\n  if (count$$16 > array$$43.length) {\n    throw new Error(\"count is greater than array length\\\\nParameter name: count\");\n  }\n\n  if (count$$16 === 0) {\n    return new cons$$25(0);\n  } else {\n    return array$$43.slice(0, 0 + count$$16);\n  }\n}\nexport function takeWhile(predicate$$8, array$$45, cons$$27) {\n  let count$$18 = 0;\n\n  while (count$$18 < array$$45.length ? predicate$$8(array$$45[count$$18]) : false) {\n    count$$18 = count$$18 + 1;\n  }\n\n  if (count$$18 === 0) {\n    return new cons$$27(0);\n  } else {\n    const count$$19 = count$$18 | 0;\n    return array$$45.slice(0, 0 + count$$19);\n  }\n}\nexport function addRangeInPlace(range, array$$47) {\n  iterate$$1(function (x$$3) {\n    const value$$7 = array$$47.push(x$$3);\n    void value$$7;\n  }, range);\n}\nexport function removeInPlace(item$$4, array$$49) {\n  const i$$18 = array$$49.indexOf(item$$4);\n\n  if (i$$18 > -1) {\n    const value$$8 = array$$49.splice(i$$18, 1);\n    void value$$8;\n    return true;\n  } else {\n    return false;\n  }\n}\nexport function removeAllInPlace(predicate$$9, array$$52) {\n  const countRemoveAll = function countRemoveAll(count$$20) {\n    const i$$19 = array$$52.findIndex(predicate$$9);\n\n    if (i$$19 > -1) {\n      const value$$9 = array$$52.splice(i$$19, 1);\n      void value$$9;\n      return countRemoveAll(count$$20) + 1 | 0;\n    } else {\n      return count$$20 | 0;\n    }\n  };\n\n  return countRemoveAll(0) | 0;\n}\nexport function copyTo(source$$3, sourceIndex, target$$4, targetIndex$$1, count$$21) {\n  const diff = targetIndex$$1 - sourceIndex | 0;\n\n  for (let i$$20 = sourceIndex; i$$20 <= sourceIndex + count$$21 - 1; i$$20++) {\n    target$$4[i$$20 + diff] = source$$3[i$$20];\n  }\n}\nexport function partition(f$$6, source$$4, cons$$29) {\n  const len$$7 = source$$4.length | 0;\n  const res1 = new cons$$29(len$$7);\n  const res2 = new cons$$29(len$$7);\n  let iTrue = 0;\n  let iFalse = 0;\n\n  for (let i$$21 = 0; i$$21 <= len$$7 - 1; i$$21++) {\n    if (f$$6(source$$4[i$$21])) {\n      res1[iTrue] = source$$4[i$$21];\n      iTrue = iTrue + 1;\n    } else {\n      res2[iFalse] = source$$4[i$$21];\n      iFalse = iFalse + 1;\n    }\n  }\n\n  return [truncate(iTrue, res1), truncate(iFalse, res2)];\n}\nexport function find(predicate$$11, array$$57) {\n  const matchValue$$5 = array$$57.find(predicate$$11);\n\n  if (matchValue$$5 == null) {\n    throw new Error(indexNotFoundMsg);\n  } else {\n    const res$$4 = value$$14(matchValue$$5);\n    return res$$4;\n  }\n}\nexport function tryFind(predicate$$13, array$$59) {\n  return array$$59.find(predicate$$13);\n}\nexport function findIndex(predicate$$15, array$$61) {\n  const matchValue$$6 = array$$61.findIndex(predicate$$15);\n\n  if (matchValue$$6 > -1) {\n    return matchValue$$6 | 0;\n  } else {\n    throw new Error(indexNotFoundMsg);\n  }\n}\nexport function tryFindIndex(predicate$$17, array$$63) {\n  const matchValue$$7 = array$$63.findIndex(predicate$$17);\n\n  if (matchValue$$7 > -1) {\n    return matchValue$$7;\n  } else {\n    return null;\n  }\n}\nexport function pick(chooser, array$$65) {\n  const loop$$1 = function loop$$1($i$$22$$147) {\n    loop$$1: while (true) {\n      const i$$22 = $i$$22$$147;\n\n      if (i$$22 >= array$$65.length) {\n        throw new Error(indexNotFoundMsg);\n      } else {\n        const matchValue$$8 = chooser(array$$65[i$$22]);\n\n        if (matchValue$$8 != null) {\n          const res$$5 = value$$14(matchValue$$8);\n          return res$$5;\n        } else {\n          $i$$22$$147 = i$$22 + 1;\n          continue loop$$1;\n        }\n      }\n\n      break;\n    }\n  };\n\n  return loop$$1(0);\n}\nexport function tryPick(chooser$$1, array$$66) {\n  const loop$$2 = function loop$$2($i$$23$$150) {\n    loop$$2: while (true) {\n      const i$$23 = $i$$23$$150;\n\n      if (i$$23 >= array$$66.length) {\n        return null;\n      } else {\n        const matchValue$$9 = chooser$$1(array$$66[i$$23]);\n\n        if (matchValue$$9 == null) {\n          $i$$23$$150 = i$$23 + 1;\n          continue loop$$2;\n        } else {\n          return matchValue$$9;\n        }\n      }\n\n      break;\n    }\n  };\n\n  return loop$$2(0);\n}\nexport function findBack(predicate$$19, array$$67) {\n  const loop$$3 = function loop$$3($i$$24$$153) {\n    loop$$3: while (true) {\n      const i$$24 = $i$$24$$153;\n\n      if (i$$24 < 0) {\n        throw new Error(indexNotFoundMsg);\n      } else if (predicate$$19(array$$67[i$$24])) {\n        return array$$67[i$$24];\n      } else {\n        $i$$24$$153 = i$$24 - 1;\n        continue loop$$3;\n      }\n\n      break;\n    }\n  };\n\n  return loop$$3(array$$67.length - 1);\n}\nexport function tryFindBack(predicate$$20, array$$68) {\n  const loop$$4 = function loop$$4($i$$25$$156) {\n    loop$$4: while (true) {\n      const i$$25 = $i$$25$$156;\n\n      if (i$$25 < 0) {\n        return null;\n      } else if (predicate$$20(array$$68[i$$25])) {\n        return some(array$$68[i$$25]);\n      } else {\n        $i$$25$$156 = i$$25 - 1;\n        continue loop$$4;\n      }\n\n      break;\n    }\n  };\n\n  return loop$$4(array$$68.length - 1);\n}\nexport function findLastIndex(predicate$$21, array$$69) {\n  const loop$$5 = function loop$$5($i$$26$$159) {\n    loop$$5: while (true) {\n      const i$$26 = $i$$26$$159;\n\n      if (i$$26 < 0) {\n        return -1 | 0;\n      } else if (predicate$$21(array$$69[i$$26])) {\n        return i$$26 | 0;\n      } else {\n        $i$$26$$159 = i$$26 - 1;\n        continue loop$$5;\n      }\n\n      break;\n    }\n  };\n\n  return loop$$5(array$$69.length - 1) | 0;\n}\nexport function findIndexBack(predicate$$22, array$$70) {\n  const loop$$6 = function loop$$6($i$$27$$162) {\n    loop$$6: while (true) {\n      const i$$27 = $i$$27$$162;\n\n      if (i$$27 < 0) {\n        throw new Error(indexNotFoundMsg);\n      } else if (predicate$$22(array$$70[i$$27])) {\n        return i$$27 | 0;\n      } else {\n        $i$$27$$162 = i$$27 - 1;\n        continue loop$$6;\n      }\n\n      break;\n    }\n  };\n\n  return loop$$6(array$$70.length - 1) | 0;\n}\nexport function tryFindIndexBack(predicate$$23, array$$71) {\n  const loop$$7 = function loop$$7($i$$28$$165) {\n    loop$$7: while (true) {\n      const i$$28 = $i$$28$$165;\n\n      if (i$$28 < 0) {\n        return null;\n      } else if (predicate$$23(array$$71[i$$28])) {\n        return i$$28;\n      } else {\n        $i$$28$$165 = i$$28 - 1;\n        continue loop$$7;\n      }\n\n      break;\n    }\n  };\n\n  return loop$$7(array$$71.length - 1);\n}\nexport function choose(chooser$$2, array$$72, cons$$30) {\n  const arr$$7 = array$$72.filter(function f$$7(x$$4) {\n    const option = chooser$$2(x$$4);\n    return option != null;\n  });\n  return map(function g(x$$5) {\n    const option$$1 = chooser$$2(x$$5);\n    return value$$14(option$$1);\n  }, arr$$7, cons$$30);\n}\nexport function foldIndexed(folder$$2, state$$4, array$$74) {\n  return array$$74.reduce(function (delegateArg0$$1, delegateArg1$$1, delegateArg2) {\n    return folder$$2(delegateArg2, delegateArg0$$1, delegateArg1$$1);\n  }, state$$4);\n}\nexport function fold(folder$$4, state$$6, array$$76) {\n  return array$$76.reduce(function (delegateArg0$$2, delegateArg1$$2) {\n    return folder$$4(delegateArg0$$2, delegateArg1$$2);\n  }, state$$6);\n}\nexport function iterate(action, array$$78) {\n  for (let i$$30 = 0; i$$30 <= array$$78.length - 1; i$$30++) {\n    action(array$$78[i$$30]);\n  }\n}\nexport function iterateIndexed(action$$1, array$$79) {\n  for (let i$$31 = 0; i$$31 <= array$$79.length - 1; i$$31++) {\n    action$$1(i$$31, array$$79[i$$31]);\n  }\n}\nexport function iterate2(action$$2, array1$$2, array2$$2) {\n  if (array1$$2.length !== array2$$2.length) {\n    throw new Error(\"Arrays had different lengths\");\n  }\n\n  for (let i$$32 = 0; i$$32 <= array1$$2.length - 1; i$$32++) {\n    action$$2(array1$$2[i$$32], array2$$2[i$$32]);\n  }\n}\nexport function iterateIndexed2(action$$3, array1$$3, array2$$3) {\n  if (array1$$3.length !== array2$$3.length) {\n    throw new Error(\"Arrays had different lengths\");\n  }\n\n  for (let i$$33 = 0; i$$33 <= array1$$3.length - 1; i$$33++) {\n    action$$3(i$$33, array1$$3[i$$33], array2$$3[i$$33]);\n  }\n}\nexport function isEmpty(array$$80) {\n  return array$$80.length === 0;\n}\nexport function forAll(predicate$$25, array$$81) {\n  return array$$81.every(predicate$$25);\n}\nexport function permute(f$$8, array$$83) {\n  const size = array$$83.length | 0;\n  const res$$7 = array$$83.slice();\n  const checkFlags = new Array(size);\n  iterateIndexed(function (i$$34, x$$8) {\n    const j$$1 = f$$8(i$$34) | 0;\n\n    if (j$$1 < 0 ? true : j$$1 >= size) {\n      throw new Error(\"Not a valid permutation\");\n    }\n\n    res$$7[j$$1] = x$$8;\n    checkFlags[j$$1] = 1;\n  }, array$$83);\n  const isValid = forAll(function (y) {\n    return 1 === y;\n  }, checkFlags);\n\n  if (!isValid) {\n    throw new Error(\"Not a valid permutation\");\n  }\n\n  return res$$7;\n}\nexport function setSlice(target$$5, lower, upper, source$$5) {\n  const lower$$1 = defaultArg(lower, 0) | 0;\n  const upper$$1 = defaultArg(upper, 0) | 0;\n  const length = (upper$$1 > 0 ? upper$$1 : target$$5.length - 1) - lower$$1 | 0;\n\n  for (let i$$35 = 0; i$$35 <= length; i$$35++) {\n    target$$5[i$$35 + lower$$1] = source$$5[i$$35];\n  }\n}\nexport function sortInPlaceBy(projection$$3, xs, comparer) {\n  xs.sort(function (x$$10, y$$1) {\n    return comparer.Compare(projection$$3(x$$10), projection$$3(y$$1));\n  });\n}\nexport function sortInPlace(xs$$1, comparer$$1) {\n  xs$$1.sort(function (x$$11, y$$2) {\n    return comparer$$1.Compare(x$$11, y$$2);\n  });\n}\nexport function sort(xs$$2, comparer$$2) {\n  const xs$$3 = xs$$2.slice();\n  xs$$3.sort(function comparer$$3(x$$12, y$$3) {\n    return comparer$$2.Compare(x$$12, y$$3);\n  });\n  return xs$$3;\n}\nexport function sortBy(projection$$4, xs$$4, comparer$$4) {\n  const xs$$5 = xs$$4.slice();\n  xs$$5.sort(function comparer$$5(x$$13, y$$4) {\n    return comparer$$4.Compare(projection$$4(x$$13), projection$$4(y$$4));\n  });\n  return xs$$5;\n}\nexport function sortDescending(xs$$6, comparer$$6) {\n  const xs$$7 = xs$$6.slice();\n  xs$$7.sort(function comparer$$7(x$$14, y$$5) {\n    return comparer$$6.Compare(x$$14, y$$5) * -1;\n  });\n  return xs$$7;\n}\nexport function sortByDescending(projection$$5, xs$$8, comparer$$8) {\n  const xs$$9 = xs$$8.slice();\n  xs$$9.sort(function comparer$$9(x$$15, y$$6) {\n    return comparer$$8.Compare(projection$$5(x$$15), projection$$5(y$$6)) * -1;\n  });\n  return xs$$9;\n}\nexport function sortWith(comparer$$10, xs$$10) {\n  const xs$$11 = xs$$10.slice();\n  xs$$11.sort(comparer$$10);\n  return xs$$11;\n}\nexport function unfold(generator, state$$8) {\n  const res$$8 = [];\n\n  const loop$$8 = function loop$$8($state$$9$$223) {\n    loop$$8: while (true) {\n      const state$$9 = $state$$9$$223;\n      const matchValue$$10 = generator(state$$9);\n\n      if (matchValue$$10 != null) {\n        const x$$16 = matchValue$$10[0];\n        const s$0027$$2 = matchValue$$10[1];\n        const value$$10 = res$$8.push(x$$16);\n        void value$$10;\n        $state$$9$$223 = s$0027$$2;\n        continue loop$$8;\n      }\n\n      break;\n    }\n  };\n\n  loop$$8(state$$8);\n  return res$$8;\n}\nexport function unzip(array$$91) {\n  const len$$9 = array$$91.length | 0;\n  const res1$$1 = new Array(len$$9);\n  const res2$$1 = new Array(len$$9);\n  iterateIndexed(function (i$$36, tupledArg) {\n    res1$$1[i$$36] = tupledArg[0];\n    res2$$1[i$$36] = tupledArg[1];\n  }, array$$91);\n  return [res1$$1, res2$$1];\n}\nexport function unzip3(array$$92) {\n  const len$$12 = array$$92.length | 0;\n  const res1$$2 = new Array(len$$12);\n  const res2$$2 = new Array(len$$12);\n  const res3 = new Array(len$$12);\n  iterateIndexed(function (i$$37, tupledArg$$1) {\n    res1$$2[i$$37] = tupledArg$$1[0];\n    res2$$2[i$$37] = tupledArg$$1[1];\n    res3[i$$37] = tupledArg$$1[2];\n  }, array$$92);\n  return [res1$$2, res2$$2, res3];\n}\nexport function zip(array1$$4, array2$$4) {\n  if (array1$$4.length !== array2$$4.length) {\n    throw new Error(\"Arrays had different lengths\");\n  }\n\n  let result$$10;\n  const len$$16 = array1$$4.length | 0;\n  result$$10 = new Array(len$$16);\n\n  for (let i$$38 = 0; i$$38 <= array1$$4.length - 1; i$$38++) {\n    result$$10[i$$38] = [array1$$4[i$$38], array2$$4[i$$38]];\n  }\n\n  return result$$10;\n}\nexport function zip3(array1$$5, array2$$5, array3) {\n  if (array1$$5.length !== array2$$5.length ? true : array2$$5.length !== array3.length) {\n    throw new Error(\"Arrays had different lengths\");\n  }\n\n  let result$$11;\n  const len$$17 = array1$$5.length | 0;\n  result$$11 = new Array(len$$17);\n\n  for (let i$$39 = 0; i$$39 <= array1$$5.length - 1; i$$39++) {\n    result$$11[i$$39] = [array1$$5[i$$39], array2$$5[i$$39], array3[i$$39]];\n  }\n\n  return result$$11;\n}\nexport function chunkBySize(chunkSize, array$$93) {\n  if (chunkSize < 1) {\n    throw new Error(\"The input must be positive.\\\\nParameter name: size\");\n  }\n\n  if (array$$93.length === 0) {\n    return [[]];\n  } else {\n    const result$$12 = [];\n\n    for (let x$$17 = 0; x$$17 <= ~~Math.ceil(array$$93.length / chunkSize) - 1; x$$17++) {\n      const start$$8 = x$$17 * chunkSize | 0;\n      const slice = array$$93.slice(start$$8, start$$8 + chunkSize);\n      const value$$11 = result$$12.push(slice);\n      void value$$11;\n    }\n\n    return result$$12;\n  }\n}\nexport function splitAt(index$$4, array$$96) {\n  if (index$$4 < 0) {\n    throw new Error(\"The input must be non-negative\\\\nParameter name: index\");\n  }\n\n  if (index$$4 > array$$96.length) {\n    throw new Error(\"The input sequence has an insufficient number of elements.\\\\nParameter name: index\");\n  }\n\n  return [array$$96.slice(0, 0 + index$$4), array$$96.slice(index$$4)];\n}\nexport function compareWith(comparer$$12, array1$$6, array2$$6) {\n  if (array1$$6 == null) {\n    if (array2$$6 == null) {\n      return 0;\n    } else {\n      return -1 | 0;\n    }\n  } else if (array2$$6 == null) {\n    return 1;\n  } else {\n    let i$$40 = 0;\n    let result$$13 = 0;\n    const length1 = array1$$6.length | 0;\n    const length2 = array2$$6.length | 0;\n\n    if (length1 > length2) {\n      return 1;\n    } else if (length1 < length2) {\n      return -1 | 0;\n    } else {\n      while (i$$40 < length1 ? result$$13 === 0 : false) {\n        result$$13 = comparer$$12(array1$$6[i$$40], array2$$6[i$$40]);\n        i$$40 = i$$40 + 1;\n      }\n\n      return result$$13 | 0;\n    }\n  }\n}\nexport function equalsWith(comparer$$13, array1$$7, array2$$7) {\n  return compareWith(compare, array1$$7, array2$$7) === 0;\n}\nexport function exactlyOne(array$$99) {\n  if (array$$99.length === 1) {\n    return array$$99[0];\n  } else if (array$$99.length === 0) {\n    throw new Error(\"The input sequence was empty\\\\nParameter name: array\");\n  } else {\n    throw new Error(\"Input array too long\\\\nParameter name: array\");\n  }\n}\nexport function head(array$$100) {\n  if (array$$100.length === 0) {\n    throw new Error(\"The input array was empty\\\\nParameter name: array\");\n  } else {\n    return array$$100[0];\n  }\n}\nexport function tryHead(array$$101) {\n  if (array$$101.length === 0) {\n    return null;\n  } else {\n    return some(array$$101[0]);\n  }\n}\nexport function tail(array$$102) {\n  if (array$$102.length === 0) {\n    throw new Error(\"Not enough elements\\\\nParameter name: array\");\n  }\n\n  return array$$102.slice(1);\n}\nexport function item(index$$5, array$$104) {\n  return array$$104[index$$5];\n}\nexport function tryItem(index$$6, array$$105) {\n  if (index$$6 < 0 ? true : index$$6 >= array$$105.length) {\n    return null;\n  } else {\n    return some(array$$105[index$$6]);\n  }\n}\nexport function foldBackIndexed(folder$$6, array$$106, state$$10) {\n  return array$$106.reduceRight(function (delegateArg0$$3, delegateArg1$$3, delegateArg2$$1) {\n    return folder$$6(delegateArg2$$1, delegateArg1$$3, delegateArg0$$3);\n  }, state$$10);\n}\nexport function foldBack(folder$$8, array$$108, state$$12) {\n  return array$$108.reduceRight(function (delegateArg0$$4, delegateArg1$$4) {\n    return folder$$8(delegateArg1$$4, delegateArg0$$4);\n  }, state$$12);\n}\nexport function foldIndexed2(folder$$10, state$$14, array1$$8, array2$$8) {\n  let acc$$6 = state$$14;\n\n  if (array1$$8.length !== array2$$8.length) {\n    throw new Error(\"Arrays have different lengths\");\n  }\n\n  for (let i$$42 = 0; i$$42 <= array1$$8.length - 1; i$$42++) {\n    acc$$6 = folder$$10(i$$42, acc$$6, array1$$8[i$$42], array2$$8[i$$42]);\n  }\n\n  return acc$$6;\n}\nexport function fold2(folder$$11, state$$15, array1$$9, array2$$9) {\n  return foldIndexed2(function (_arg1, acc$$7, x$$20, y$$7) {\n    return folder$$11(acc$$7, x$$20, y$$7);\n  }, state$$15, array1$$9, array2$$9);\n}\nexport function foldBackIndexed2(folder$$12, array1$$10, array2$$10, state$$16) {\n  let acc$$8 = state$$16;\n\n  if (array1$$10.length !== array2$$10.length) {\n    throw new Error(\"Arrays had different lengths\");\n  }\n\n  const size$$1 = array1$$10.length | 0;\n\n  for (let i$$43 = 1; i$$43 <= size$$1; i$$43++) {\n    acc$$8 = folder$$12(i$$43 - 1, array1$$10[size$$1 - i$$43], array2$$10[size$$1 - i$$43], acc$$8);\n  }\n\n  return acc$$8;\n}\nexport function foldBack2(f$$9, array1$$11, array2$$11, state$$17) {\n  return foldBackIndexed2(function (_arg1$$1, x$$21, y$$8, acc$$9) {\n    return f$$9(x$$21, y$$8, acc$$9);\n  }, array1$$11, array2$$11, state$$17);\n}\nexport function reduce(reduction, array$$110) {\n  if (array$$110.length === 0) {\n    throw new Error(\"The input array was empty\");\n  }\n\n  return array$$110.reduce(reduction);\n}\nexport function reduceBack(reduction$$2, array$$112) {\n  if (array$$112.length === 0) {\n    throw new Error(\"The input array was empty\");\n  }\n\n  return array$$112.reduceRight(reduction$$2);\n}\nexport function forAll2(predicate$$27, array1$$12, array2$$12) {\n  return fold2(function (acc$$10, x$$22, y$$9) {\n    return acc$$10 ? predicate$$27(x$$22, y$$9) : false;\n  }, true, array1$$12, array2$$12);\n}\nexport function existsOffset($predicate$$28$$278, $array$$114$$279, $index$$7$$280) {\n  existsOffset: while (true) {\n    const predicate$$28 = $predicate$$28$$278,\n          array$$114 = $array$$114$$279,\n          index$$7 = $index$$7$$280;\n\n    if (index$$7 === array$$114.length) {\n      return false;\n    } else if (predicate$$28(array$$114[index$$7])) {\n      return true;\n    } else {\n      $predicate$$28$$278 = predicate$$28;\n      $array$$114$$279 = array$$114;\n      $index$$7$$280 = index$$7 + 1;\n      continue existsOffset;\n    }\n\n    break;\n  }\n}\nexport function exists(predicate$$29, array$$115) {\n  return existsOffset(predicate$$29, array$$115, 0);\n}\nexport function existsOffset2($predicate$$30$$283, $array1$$13$$284, $array2$$13$$285, $index$$8$$286) {\n  existsOffset2: while (true) {\n    const predicate$$30 = $predicate$$30$$283,\n          array1$$13 = $array1$$13$$284,\n          array2$$13 = $array2$$13$$285,\n          index$$8 = $index$$8$$286;\n\n    if (index$$8 === array1$$13.length) {\n      return false;\n    } else if (predicate$$30(array1$$13[index$$8], array2$$13[index$$8])) {\n      return true;\n    } else {\n      $predicate$$30$$283 = predicate$$30;\n      $array1$$13$$284 = array1$$13;\n      $array2$$13$$285 = array2$$13;\n      $index$$8$$286 = index$$8 + 1;\n      continue existsOffset2;\n    }\n\n    break;\n  }\n}\nexport function exists2(predicate$$31, array1$$14, array2$$14) {\n  if (array1$$14.length !== array2$$14.length) {\n    throw new Error(\"Arrays had different lengths\");\n  }\n\n  return existsOffset2(predicate$$31, array1$$14, array2$$14, 0);\n}\nexport function sum(array$$116, adder) {\n  let acc$$11 = adder.GetZero();\n\n  for (let i$$44 = 0; i$$44 <= array$$116.length - 1; i$$44++) {\n    acc$$11 = adder.Add(acc$$11, array$$116[i$$44]);\n  }\n\n  return acc$$11;\n}\nexport function sumBy(projection$$6, array$$117, adder$$1) {\n  let acc$$12 = adder$$1.GetZero();\n\n  for (let i$$45 = 0; i$$45 <= array$$117.length - 1; i$$45++) {\n    acc$$12 = adder$$1.Add(acc$$12, projection$$6(array$$117[i$$45]));\n  }\n\n  return acc$$12;\n}\nexport function maxBy(projection$$7, xs$$12, comparer$$14) {\n  return reduce(function (x$$23, y$$10) {\n    return comparer$$14.Compare(projection$$7(y$$10), projection$$7(x$$23)) > 0 ? y$$10 : x$$23;\n  }, xs$$12);\n}\nexport function max(xs$$13, comparer$$15) {\n  return reduce(function (x$$24, y$$11) {\n    return comparer$$15.Compare(y$$11, x$$24) > 0 ? y$$11 : x$$24;\n  }, xs$$13);\n}\nexport function minBy(projection$$8, xs$$14, comparer$$16) {\n  return reduce(function (x$$25, y$$12) {\n    return comparer$$16.Compare(projection$$8(y$$12), projection$$8(x$$25)) > 0 ? x$$25 : y$$12;\n  }, xs$$14);\n}\nexport function min(xs$$15, comparer$$17) {\n  return reduce(function (x$$26, y$$13) {\n    return comparer$$17.Compare(y$$13, x$$26) > 0 ? x$$26 : y$$13;\n  }, xs$$15);\n}\nexport function average(array$$118, averager) {\n  if (array$$118.length === 0) {\n    throw new Error(\"The input array was empty\\\\nParameter name: array\");\n  }\n\n  let total = averager.GetZero();\n\n  for (let i$$46 = 0; i$$46 <= array$$118.length - 1; i$$46++) {\n    total = averager.Add(total, array$$118[i$$46]);\n  }\n\n  return averager.DivideByInt(total, array$$118.length);\n}\nexport function averageBy(projection$$9, array$$119, averager$$1) {\n  if (array$$119.length === 0) {\n    throw new Error(\"The input array was empty\\\\nParameter name: array\");\n  }\n\n  let total$$1 = averager$$1.GetZero();\n\n  for (let i$$47 = 0; i$$47 <= array$$119.length - 1; i$$47++) {\n    total$$1 = averager$$1.Add(total$$1, projection$$9(array$$119[i$$47]));\n  }\n\n  return averager$$1.DivideByInt(total$$1, array$$119.length);\n}\nexport function ofSeq(source$$6, cons$$31) {\n  return cons$$31.from(source$$6);\n}\nexport function ofList(source$$7, cons$$32) {\n  return cons$$32.from(source$$7);\n}\nexport function toList(source$$8) {\n  const len$$18 = source$$8.length | 0;\n  let target$$6 = new List();\n\n  for (let i$$48 = len$$18 - 1; i$$48 >= 0; i$$48--) {\n    target$$6 = new List(source$$8[i$$48], target$$6);\n  }\n\n  return target$$6;\n}\nexport function windowed(windowSize, source$$9) {\n  if (windowSize <= 0) {\n    throw new Error(\"windowSize must be positive\");\n  }\n\n  let res$$9;\n  const len$$19 = max$$1(comparePrimitives, 0, source$$9.length - windowSize) | 0;\n  res$$9 = new Array(len$$19);\n\n  for (let i$$49 = windowSize; i$$49 <= source$$9.length; i$$49++) {\n    res$$9[i$$49 - windowSize] = source$$9.slice(i$$49 - windowSize, i$$49 - 1 + 1);\n  }\n\n  return res$$9;\n}\nexport function splitInto(chunks, array$$120) {\n  if (chunks < 1) {\n    throw new Error(\"The input must be positive.\\\\nParameter name: chunks\");\n  }\n\n  if (array$$120.length === 0) {\n    return [[]];\n  } else {\n    const result$$14 = [];\n    const chunks$$1 = min$$1(comparePrimitives, chunks, array$$120.length) | 0;\n    const minChunkSize = ~~(array$$120.length / chunks$$1) | 0;\n    const chunksWithExtraItem = array$$120.length % chunks$$1 | 0;\n\n    for (let i$$50 = 0; i$$50 <= chunks$$1 - 1; i$$50++) {\n      const chunkSize$$1 = (i$$50 < chunksWithExtraItem ? minChunkSize + 1 : minChunkSize) | 0;\n      const start$$11 = i$$50 * minChunkSize + min$$1(comparePrimitives, chunksWithExtraItem, i$$50) | 0;\n      const slice$$1 = array$$120.slice(start$$11, start$$11 + chunkSize$$1);\n      const value$$12 = result$$14.push(slice$$1);\n      void value$$12;\n    }\n\n    return result$$14;\n  }\n}\nexport function transpose(arrays$$2, cons$$33) {\n  var value$$13;\n  const arrays$$3 = Array.isArray(arrays$$2) ? arrays$$2 : Array.from(arrays$$2);\n  const len$$21 = arrays$$3.length | 0;\n\n  if (len$$21 === 0) {\n    return new Array(0);\n  } else {\n    const lenInner = arrays$$3[0].length | 0;\n\n    if (value$$13 = forAll(function predicate$$32(a) {\n      return a.length === lenInner;\n    }, arrays$$3), !value$$13) {\n      throw new Error(\"Arrays had different lengths\");\n    }\n\n    const result$$15 = new Array(lenInner);\n\n    for (let i$$51 = 0; i$$51 <= lenInner - 1; i$$51++) {\n      result$$15[i$$51] = new cons$$33(len$$21);\n\n      for (let j$$2 = 0; j$$2 <= len$$21 - 1; j$$2++) {\n        result$$15[i$$51][j$$2] = arrays$$3[j$$2][i$$51];\n      }\n    }\n\n    return result$$15;\n  }\n}","import { declare, Record } from \"../fable-library.2.4.13/Types\";\nimport { record, type, string, tuple, list, lambda, unit } from \"../fable-library.2.4.13/Reflection\";\nimport { Cmd$$$exec as Cmd$0024$0024$0024exec, Cmd$$$batch as Cmd$0024$0024$0024batch, Cmd$$$none as Cmd$0024$0024$0024none } from \"./cmd\";\nimport { Log$$$toConsole as Log$0024$0024$0024toConsole, Log$$$onError as Log$0024$0024$0024onError } from \"./prelude\";\nimport { curry, partialApply, uncurry } from \"../fable-library.2.4.13/Util\";\nimport { append, ofArray } from \"../fable-library.2.4.13/List\";\nimport { RingBuffer$00601$$Pop as RingBuffer$002400601$0024$0024Pop, RingBuffer$00601$$Push$$2B595 as RingBuffer$002400601$0024$0024Push$0024$00242B595, RingBuffer$00601$$$$002Ector$$Z524259A4 as RingBuffer$002400601$0024$0024$0024$0024002Ector$0024$0024Z524259A4 } from \"./ring\";\nimport { value as value$$2, some } from \"../fable-library.2.4.13/Option\";\nimport { toText, printf } from \"../fable-library.2.4.13/String\";\nexport const Program$00604 = declare(function Elmish_Program(arg1, arg2, arg3, arg4, arg5, arg6, arg7) {\n  this.init = arg1;\n  this.update = arg2;\n  this.subscribe = arg3;\n  this.view = arg4;\n  this.setState = arg5;\n  this.onError = arg6;\n  this.syncDispatch = arg7;\n}, Record);\nexport function Program$00604$reflection($gen$$5, $gen$$6, $gen$$7, $gen$$8) {\n  return record(\"Elmish.Program`4\", [$gen$$5, $gen$$6, $gen$$7, $gen$$8], Program$00604, () => [[\"init\", lambda($gen$$5, tuple($gen$$6, list(lambda(lambda($gen$$7, unit), unit))))], [\"update\", lambda($gen$$7, lambda($gen$$6, tuple($gen$$6, list(lambda(lambda($gen$$7, unit), unit)))))], [\"subscribe\", lambda($gen$$6, list(lambda(lambda($gen$$7, unit), unit)))], [\"view\", lambda($gen$$6, lambda(lambda($gen$$7, unit), $gen$$8))], [\"setState\", lambda($gen$$6, lambda(lambda($gen$$7, unit), unit))], [\"onError\", lambda(tuple(string, type(\"System.Exception\")), unit)], [\"syncDispatch\", lambda(lambda($gen$$7, unit), lambda($gen$$7, unit))]]);\n}\nexport function ProgramModule$$$mkProgram(init, update, view) {\n  return new Program$00604(init, update, function (_arg1) {\n    return Cmd$0024$0024$0024none();\n  }, view, function setState(model, $arg$$1) {\n    const value = view(model, $arg$$1);\n    void value;\n  }, function (tupledArg) {\n    Log$0024$0024$0024onError(tupledArg[0], tupledArg[1]);\n  }, uncurry(2, function (x) {\n    return x;\n  }));\n}\nexport function ProgramModule$$$mkSimple(init$$1, update$$1, view$$1) {\n  return new Program$00604(function init$$2($arg$$2) {\n    const state = init$$1($arg$$2);\n    return [state, Cmd$0024$0024$0024none()];\n  }, function update$$2(msg, $arg$$3) {\n    const state$$1 = update$$1(msg, $arg$$3);\n    return [state$$1, Cmd$0024$0024$0024none()];\n  }, function (_arg1$$1) {\n    return Cmd$0024$0024$0024none();\n  }, view$$1, function setState$$1(model$$1, $arg$$4) {\n    const value$$1 = view$$1(model$$1, $arg$$4);\n    void value$$1;\n  }, function (tupledArg$$1) {\n    Log$0024$0024$0024onError(tupledArg$$1[0], tupledArg$$1[1]);\n  }, uncurry(2, function (x$$1) {\n    return x$$1;\n  }));\n}\nexport function ProgramModule$$$withSubscription(subscribe, program) {\n  return new Program$00604(program.init, program.update, function sub(model$$2) {\n    return Cmd$0024$0024$0024batch(ofArray([program.subscribe(model$$2), subscribe(model$$2)]));\n  }, program.view, program.setState, program.onError, program.syncDispatch);\n}\nexport function ProgramModule$$$withConsoleTrace(program$$1) {\n  return new Program$00604(function traceInit(arg) {\n    const patternInput = program$$1.init(arg);\n    Log$0024$0024$0024toConsole(\"Initial state:\", patternInput[0]);\n    return [patternInput[0], patternInput[1]];\n  }, function traceUpdate(msg$$1, model$$3) {\n    Log$0024$0024$0024toConsole(\"New message:\", msg$$1);\n    const patternInput$$1 = program$$1.update(msg$$1, model$$3);\n    Log$0024$0024$0024toConsole(\"Updated state:\", patternInput$$1[0]);\n    return [patternInput$$1[0], patternInput$$1[1]];\n  }, program$$1.subscribe, program$$1.view, program$$1.setState, program$$1.onError, program$$1.syncDispatch);\n}\nexport function ProgramModule$$$withTrace(trace, program$$2) {\n  return new Program$00604(program$$2.init, function update$$3(msg$$2, model$$4) {\n    const patternInput$$2 = program$$2.update(msg$$2, model$$4);\n    trace(msg$$2, patternInput$$2[0]);\n    return [patternInput$$2[0], patternInput$$2[1]];\n  }, program$$2.subscribe, program$$2.view, program$$2.setState, program$$2.onError, program$$2.syncDispatch);\n}\nexport function ProgramModule$$$withErrorHandler(onError, program$$3) {\n  return new Program$00604(program$$3.init, program$$3.update, program$$3.subscribe, program$$3.view, program$$3.setState, onError, program$$3.syncDispatch);\n}\nexport function ProgramModule$$$mapErrorHandler(map, program$$4) {\n  const onError$$1 = partialApply(1, map, [program$$4.onError]);\n  return new Program$00604(program$$4.init, program$$4.update, program$$4.subscribe, program$$4.view, program$$4.setState, onError$$1, program$$4.syncDispatch);\n}\nexport function ProgramModule$$$onError(program$$5) {\n  return program$$5.onError;\n}\nexport function ProgramModule$$$withSetState(setState$$2, program$$6) {\n  return new Program$00604(program$$6.init, program$$6.update, program$$6.subscribe, program$$6.view, setState$$2, program$$6.onError, program$$6.syncDispatch);\n}\nexport function ProgramModule$$$setState(program$$7) {\n  return curry(2, program$$7.setState);\n}\nexport function ProgramModule$$$view(program$$8) {\n  return curry(2, program$$8.view);\n}\nexport function ProgramModule$$$withSyncDispatch(syncDispatch, program$$9) {\n  return new Program$00604(program$$9.init, program$$9.update, program$$9.subscribe, program$$9.view, program$$9.setState, program$$9.onError, syncDispatch);\n}\nexport function ProgramModule$$$map(mapInit, mapUpdate, mapView, mapSetState, mapSubscribe, program$$10) {\n  const init$$3 = partialApply(1, mapInit, [program$$10.init]);\n  const update$$4 = partialApply(2, mapUpdate, [program$$10.update]);\n  const view$$2 = partialApply(2, mapView, [program$$10.view]);\n  const setState$$3 = partialApply(2, mapSetState, [program$$10.setState]);\n  return new Program$00604(init$$3, uncurry(2, update$$4), partialApply(1, mapSubscribe, [program$$10.subscribe]), uncurry(2, view$$2), uncurry(2, setState$$3), program$$10.onError, uncurry(2, function (x$$2) {\n    return x$$2;\n  }));\n}\nexport function ProgramModule$$$runWith(arg$$1, program$$11) {\n  const patternInput$$3 = program$$11.init(arg$$1);\n  const rb = RingBuffer$002400601$0024$0024$0024$0024002Ector$0024$0024Z524259A4(10);\n  let reentered = false;\n  let state$$3 = patternInput$$3[0];\n\n  const dispatch = function dispatch(msg$$3) {\n    var clo1;\n\n    if (reentered) {\n      RingBuffer$002400601$0024$0024Push$0024$00242B595(rb, msg$$3);\n    } else {\n      reentered = true;\n      let nextMsg = some(msg$$3);\n\n      while (nextMsg != null) {\n        const msg$$4 = value$$2(nextMsg);\n\n        try {\n          const patternInput$$4 = program$$11.update(msg$$4, state$$3);\n          program$$11.setState(patternInput$$4[0], syncDispatch$$1);\n          Cmd$0024$0024$0024exec(syncDispatch$$1, patternInput$$4[1]);\n          state$$3 = patternInput$$4[0];\n        } catch (ex$$2) {\n          program$$11.onError([(clo1 = toText(printf(\"Unable to process the message: %A\")), clo1(msg$$4)), ex$$2]);\n        }\n\n        nextMsg = RingBuffer$002400601$0024$0024Pop(rb);\n      }\n\n      reentered = false;\n    }\n  };\n\n  const syncDispatch$$1 = partialApply(1, program$$11.syncDispatch, [dispatch]);\n  program$$11.setState(patternInput$$3[0], syncDispatch$$1);\n  let sub$$1;\n\n  try {\n    sub$$1 = program$$11.subscribe(patternInput$$3[0]);\n  } catch (ex$$3) {\n    program$$11.onError([\"Unable to subscribe:\", ex$$3]);\n    sub$$1 = Cmd$0024$0024$0024none();\n  }\n\n  const cmd$$5 = append(sub$$1, patternInput$$3[1]);\n  Cmd$0024$0024$0024exec(syncDispatch$$1, cmd$$5);\n}\nexport function ProgramModule$$$run(program$$12) {\n  ProgramModule$$$runWith(null, program$$12);\n}","import { Record, declare, Union } from \"../fable-library.2.4.13/Types\";\nimport { array, float64, int32, bool, obj, record, option, lambda, unit, type, union, string } from \"../fable-library.2.4.13/Reflection\";\nexport const FragmentProp = declare(function Fable_React_Props_FragmentProp(tag, name, ...fields) {\n  Union.call(this, tag, name, ...fields);\n}, Union);\nexport function FragmentProp$reflection() {\n  return union(\"Fable.React.Props.FragmentProp\", [], FragmentProp, () => [[\"Key\", [string]]]);\n}\nexport const Prop = declare(function Fable_React_Props_Prop(tag, name, ...fields) {\n  Union.call(this, tag, name, ...fields);\n}, Union);\nexport function Prop$reflection() {\n  return union(\"Fable.React.Props.Prop\", [], Prop, () => [[\"Key\", [string]], [\"Ref\", [lambda(type(\"Browser.Types.Element\"), unit)]], [\"ref\", [type(\"Fable.React.IRefValue`1\", [option(type(\"Browser.Types.Element\"))])]], [\"ref\", [type(\"Fable.React.IRefValue`1\", [option(type(\"Browser.Types.Element\"))])]]]);\n}\nexport const DangerousHtml = declare(function Fable_React_Props_DangerousHtml(arg1) {\n  this.__html = arg1;\n}, Record);\nexport function DangerousHtml$reflection() {\n  return record(\"Fable.React.Props.DangerousHtml\", [], DangerousHtml, () => [[\"__html\", string]]);\n}\nexport const DOMAttr = declare(function Fable_React_Props_DOMAttr(tag, name, ...fields) {\n  Union.call(this, tag, name, ...fields);\n}, Union);\nexport function DOMAttr$reflection() {\n  return union(\"Fable.React.Props.DOMAttr\", [], DOMAttr, () => [[\"DangerouslySetInnerHTML\", [DangerousHtml$reflection()]], [\"OnCut\", [lambda(type(\"Browser.Types.ClipboardEvent\"), unit)]], [\"OnPaste\", [lambda(type(\"Browser.Types.ClipboardEvent\"), unit)]], [\"OnCompositionEnd\", [lambda(type(\"Browser.Types.CompositionEvent\"), unit)]], [\"OnCompositionStart\", [lambda(type(\"Browser.Types.CompositionEvent\"), unit)]], [\"OnCopy\", [lambda(type(\"Browser.Types.ClipboardEvent\"), unit)]], [\"OnCompositionUpdate\", [lambda(type(\"Browser.Types.CompositionEvent\"), unit)]], [\"OnFocus\", [lambda(type(\"Browser.Types.FocusEvent\"), unit)]], [\"OnBlur\", [lambda(type(\"Browser.Types.FocusEvent\"), unit)]], [\"OnChange\", [lambda(type(\"Browser.Types.Event\"), unit)]], [\"OnInput\", [lambda(type(\"Browser.Types.Event\"), unit)]], [\"OnSubmit\", [lambda(type(\"Browser.Types.Event\"), unit)]], [\"OnReset\", [lambda(type(\"Browser.Types.Event\"), unit)]], [\"OnLoad\", [lambda(type(\"Browser.Types.Event\"), unit)]], [\"OnError\", [lambda(type(\"Browser.Types.Event\"), unit)]], [\"OnKeyDown\", [lambda(type(\"Browser.Types.KeyboardEvent\"), unit)]], [\"OnKeyPress\", [lambda(type(\"Browser.Types.KeyboardEvent\"), unit)]], [\"OnKeyUp\", [lambda(type(\"Browser.Types.KeyboardEvent\"), unit)]], [\"OnAbort\", [lambda(type(\"Browser.Types.Event\"), unit)]], [\"OnCanPlay\", [lambda(type(\"Browser.Types.Event\"), unit)]], [\"OnCanPlayThrough\", [lambda(type(\"Browser.Types.Event\"), unit)]], [\"OnDurationChange\", [lambda(type(\"Browser.Types.Event\"), unit)]], [\"OnEmptied\", [lambda(type(\"Browser.Types.Event\"), unit)]], [\"OnEncrypted\", [lambda(type(\"Browser.Types.Event\"), unit)]], [\"OnEnded\", [lambda(type(\"Browser.Types.Event\"), unit)]], [\"OnLoadedData\", [lambda(type(\"Browser.Types.Event\"), unit)]], [\"OnLoadedMetadata\", [lambda(type(\"Browser.Types.Event\"), unit)]], [\"OnLoadStart\", [lambda(type(\"Browser.Types.Event\"), unit)]], [\"OnPause\", [lambda(type(\"Browser.Types.Event\"), unit)]], [\"OnPlay\", [lambda(type(\"Browser.Types.Event\"), unit)]], [\"OnPlaying\", [lambda(type(\"Browser.Types.Event\"), unit)]], [\"OnProgress\", [lambda(type(\"Browser.Types.Event\"), unit)]], [\"OnRateChange\", [lambda(type(\"Browser.Types.Event\"), unit)]], [\"OnSeeked\", [lambda(type(\"Browser.Types.Event\"), unit)]], [\"OnSeeking\", [lambda(type(\"Browser.Types.Event\"), unit)]], [\"OnStalled\", [lambda(type(\"Browser.Types.Event\"), unit)]], [\"OnSuspend\", [lambda(type(\"Browser.Types.Event\"), unit)]], [\"OnTimeUpdate\", [lambda(type(\"Browser.Types.Event\"), unit)]], [\"OnVolumeChange\", [lambda(type(\"Browser.Types.Event\"), unit)]], [\"OnWaiting\", [lambda(type(\"Browser.Types.Event\"), unit)]], [\"OnClick\", [lambda(type(\"Browser.Types.MouseEvent\"), unit)]], [\"OnContextMenu\", [lambda(type(\"Browser.Types.MouseEvent\"), unit)]], [\"OnDoubleClick\", [lambda(type(\"Browser.Types.MouseEvent\"), unit)]], [\"OnDrag\", [lambda(type(\"Browser.Types.DragEvent\"), unit)]], [\"OnDragEnd\", [lambda(type(\"Browser.Types.DragEvent\"), unit)]], [\"OnDragEnter\", [lambda(type(\"Browser.Types.DragEvent\"), unit)]], [\"OnDragExit\", [lambda(type(\"Browser.Types.DragEvent\"), unit)]], [\"OnDragLeave\", [lambda(type(\"Browser.Types.DragEvent\"), unit)]], [\"OnDragOver\", [lambda(type(\"Browser.Types.DragEvent\"), unit)]], [\"OnDragStart\", [lambda(type(\"Browser.Types.DragEvent\"), unit)]], [\"OnDrop\", [lambda(type(\"Browser.Types.DragEvent\"), unit)]], [\"OnMouseDown\", [lambda(type(\"Browser.Types.MouseEvent\"), unit)]], [\"OnMouseEnter\", [lambda(type(\"Browser.Types.MouseEvent\"), unit)]], [\"OnMouseLeave\", [lambda(type(\"Browser.Types.MouseEvent\"), unit)]], [\"OnMouseMove\", [lambda(type(\"Browser.Types.MouseEvent\"), unit)]], [\"OnMouseOut\", [lambda(type(\"Browser.Types.MouseEvent\"), unit)]], [\"OnMouseOver\", [lambda(type(\"Browser.Types.MouseEvent\"), unit)]], [\"OnMouseUp\", [lambda(type(\"Browser.Types.MouseEvent\"), unit)]], [\"OnSelect\", [lambda(type(\"Browser.Types.Event\"), unit)]], [\"OnTouchCancel\", [lambda(type(\"Browser.Types.TouchEvent\"), unit)]], [\"OnTouchEnd\", [lambda(type(\"Browser.Types.TouchEvent\"), unit)]], [\"OnTouchMove\", [lambda(type(\"Browser.Types.TouchEvent\"), unit)]], [\"OnTouchStart\", [lambda(type(\"Browser.Types.TouchEvent\"), unit)]], [\"OnScroll\", [lambda(type(\"Browser.Types.UIEvent\"), unit)]], [\"OnWheel\", [lambda(type(\"Browser.Types.WheelEvent\"), unit)]], [\"OnAnimationStart\", [lambda(type(\"Browser.Types.AnimationEvent\"), unit)]], [\"OnAnimationEnd\", [lambda(type(\"Browser.Types.AnimationEvent\"), unit)]], [\"OnAnimationIteration\", [lambda(type(\"Browser.Types.AnimationEvent\"), unit)]], [\"OnTransitionEnd\", [lambda(type(\"Browser.Types.TransitionEvent\"), unit)]]]);\n}\nexport const SVGAttr = declare(function Fable_React_Props_SVGAttr(tag, name, ...fields) {\n  Union.call(this, tag, name, ...fields);\n}, Union);\nexport function SVGAttr$reflection() {\n  return union(\"Fable.React.Props.SVGAttr\", [], SVGAttr, () => [[\"ClipPath\", [string]], [\"Cx\", [obj]], [\"Cy\", [obj]], [\"D\", [string]], [\"Dx\", [obj]], [\"Dy\", [obj]], [\"Fill\", [string]], [\"FillOpacity\", [obj]], [\"FontFamily\", [string]], [\"FontSize\", [obj]], [\"Fx\", [obj]], [\"Fy\", [obj]], [\"GradientTransform\", [string]], [\"GradientUnits\", [string]], [\"Height\", [obj]], [\"MarkerEnd\", [string]], [\"MarkerMid\", [string]], [\"MarkerStart\", [string]], [\"Offset\", [obj]], [\"Opacity\", [obj]], [\"PatternContentUnits\", [string]], [\"PatternUnits\", [string]], [\"Points\", [string]], [\"PreserveAspectRatio\", [string]], [\"R\", [obj]], [\"Rx\", [obj]], [\"Ry\", [obj]], [\"SpreadMethod\", [string]], [\"StopColor\", [string]], [\"StopOpacity\", [obj]], [\"Stroke\", [string]], [\"StrokeDasharray\", [string]], [\"StrokeDashoffset\", [string]], [\"StrokeLinecap\", [string]], [\"StrokeMiterlimit\", [string]], [\"StrokeOpacity\", [obj]], [\"StrokeWidth\", [obj]], [\"TextAnchor\", [string]], [\"Transform\", [string]], [\"Version\", [string]], [\"ViewBox\", [string]], [\"Width\", [obj]], [\"X1\", [obj]], [\"X2\", [obj]], [\"X\", [obj]], [\"XlinkActuate\", [string]], [\"XlinkArcrole\", [string]], [\"XlinkHref\", [string]], [\"XlinkRole\", [string]], [\"XlinkShow\", [string]], [\"XlinkTitle\", [string]], [\"XlinkType\", [string]], [\"XmlBase\", [string]], [\"XmlLang\", [string]], [\"XmlSpace\", [string]], [\"Y1\", [obj]], [\"Y2\", [obj]], [\"Y\", [obj]], [\"Custom\", [string, obj]]]);\n}\nexport const HTMLAttr = declare(function Fable_React_Props_HTMLAttr(tag, name, ...fields) {\n  Union.call(this, tag, name, ...fields);\n}, Union);\nexport function HTMLAttr$reflection() {\n  return union(\"Fable.React.Props.HTMLAttr\", [], HTMLAttr, () => [[\"DefaultChecked\", [bool]], [\"DefaultValue\", [obj]], [\"Accept\", [string]], [\"AcceptCharset\", [string]], [\"AccessKey\", [string]], [\"Action\", [string]], [\"AllowFullScreen\", [bool]], [\"AllowTransparency\", [bool]], [\"Alt\", [string]], [\"aria-atomic\", [bool]], [\"aria-busy\", [bool]], [\"aria-checked\", [bool]], [\"aria-colcount\", [int32]], [\"aria-colindex\", [int32]], [\"aria-colspan\", [int32]], [\"aria-controls\", [string]], [\"aria-current\", [string]], [\"aria-describedby\", [string]], [\"aria-details\", [string]], [\"aria-disabled\", [bool]], [\"aria-errormessage\", [string]], [\"aria-expanded\", [bool]], [\"aria-flowto\", [string]], [\"aria-haspopup\", [bool]], [\"aria-hidden\", [bool]], [\"aria-invalid\", [string]], [\"aria-keyshortcuts\", [string]], [\"aria-label\", [string]], [\"aria-labelledby\", [string]], [\"aria-level\", [int32]], [\"aria-live\", [string]], [\"aria-modal\", [bool]], [\"aria-multiline\", [bool]], [\"aria-multiselectable\", [bool]], [\"aria-orientation\", [string]], [\"aria-owns\", [string]], [\"aria-placeholder\", [string]], [\"aria-posinset\", [int32]], [\"aria-pressed\", [bool]], [\"aria-readonly\", [bool]], [\"aria-relevant\", [string]], [\"aria-required\", [bool]], [\"aria-roledescription\", [string]], [\"aria-rowcount\", [int32]], [\"aria-rowindex\", [int32]], [\"aria-rowspan\", [int32]], [\"aria-selected\", [bool]], [\"aria-setsize\", [int32]], [\"aria-sort\", [string]], [\"aria-valuemax\", [float64]], [\"aria-valuemin\", [float64]], [\"aria-valuenow\", [float64]], [\"aria-valuetext\", [string]], [\"Async\", [bool]], [\"AutoComplete\", [string]], [\"AutoFocus\", [bool]], [\"AutoPlay\", [bool]], [\"Capture\", [bool]], [\"CellPadding\", [obj]], [\"CellSpacing\", [obj]], [\"CharSet\", [string]], [\"Challenge\", [string]], [\"Checked\", [bool]], [\"ClassID\", [string]], [\"ClassName\", [string]], [\"className\", [string]], [\"Cols\", [int32]], [\"ColSpan\", [int32]], [\"Content\", [string]], [\"ContentEditable\", [bool]], [\"ContextMenu\", [string]], [\"Controls\", [bool]], [\"Coords\", [string]], [\"CrossOrigin\", [string]], [\"data-toggle\", [string]], [\"DateTime\", [string]], [\"Default\", [bool]], [\"Defer\", [bool]], [\"Dir\", [string]], [\"Disabled\", [bool]], [\"Download\", [obj]], [\"Draggable\", [bool]], [\"EncType\", [string]], [\"Form\", [string]], [\"FormAction\", [string]], [\"FormEncType\", [string]], [\"FormMethod\", [string]], [\"FormNoValidate\", [bool]], [\"FormTarget\", [string]], [\"FrameBorder\", [obj]], [\"Headers\", [string]], [\"Height\", [obj]], [\"Hidden\", [bool]], [\"High\", [float64]], [\"Href\", [string]], [\"HrefLang\", [string]], [\"HtmlFor\", [string]], [\"HttpEquiv\", [string]], [\"Icon\", [string]], [\"Id\", [string]], [\"InputMode\", [string]], [\"Integrity\", [string]], [\"Is\", [string]], [\"KeyParams\", [string]], [\"KeyType\", [string]], [\"Kind\", [string]], [\"Label\", [string]], [\"Lang\", [string]], [\"List\", [string]], [\"Loop\", [bool]], [\"Low\", [float64]], [\"Manifest\", [string]], [\"MarginHeight\", [float64]], [\"MarginWidth\", [float64]], [\"Max\", [obj]], [\"MaxLength\", [float64]], [\"Media\", [string]], [\"MediaGroup\", [string]], [\"Method\", [string]], [\"Min\", [obj]], [\"MinLength\", [float64]], [\"Multiple\", [bool]], [\"Muted\", [bool]], [\"Name\", [string]], [\"NoValidate\", [bool]], [\"Open\", [bool]], [\"Optimum\", [float64]], [\"Pattern\", [string]], [\"Placeholder\", [string]], [\"Poster\", [string]], [\"Preload\", [string]], [\"RadioGroup\", [string]], [\"ReadOnly\", [bool]], [\"Rel\", [string]], [\"Required\", [bool]], [\"Role\", [string]], [\"Rows\", [int32]], [\"RowSpan\", [int32]], [\"Sandbox\", [string]], [\"Scope\", [string]], [\"Scoped\", [bool]], [\"Scrolling\", [string]], [\"Seamless\", [bool]], [\"Selected\", [bool]], [\"Shape\", [string]], [\"Size\", [float64]], [\"Sizes\", [string]], [\"Span\", [float64]], [\"SpellCheck\", [bool]], [\"Src\", [string]], [\"SrcDoc\", [string]], [\"SrcLang\", [string]], [\"SrcSet\", [string]], [\"Start\", [float64]], [\"Step\", [obj]], [\"Summary\", [string]], [\"TabIndex\", [int32]], [\"Target\", [string]], [\"Title\", [string]], [\"Type\", [string]], [\"UseMap\", [string]], [\"Value\", [obj]], [\"value\", [array(string)]], [\"Width\", [obj]], [\"Wmode\", [string]], [\"Wrap\", [string]], [\"About\", [string]], [\"Datatype\", [string]], [\"Inlist\", [obj]], [\"Prefix\", [string]], [\"Property\", [string]], [\"Resource\", [string]], [\"Typeof\", [string]], [\"Vocab\", [string]], [\"AutoCapitalize\", [string]], [\"AutoCorrect\", [string]], [\"AutoSave\", [string]], [\"ItemProp\", [string]], [\"ItemScope\", [bool]], [\"ItemType\", [string]], [\"ItemID\", [string]], [\"ItemRef\", [string]], [\"Results\", [float64]], [\"Security\", [string]], [\"Unselectable\", [bool]], [\"Custom\", [string, obj]]]);\n}\nexport const CSSProp = declare(function Fable_React_Props_CSSProp(tag, name, ...fields) {\n  Union.call(this, tag, name, ...fields);\n}, Union);\nexport function CSSProp$reflection() {\n  return union(\"Fable.React.Props.CSSProp\", [], CSSProp, () => [[\"AlignContent\", [string]], [\"AlignItems\", [string]], [\"AlignSelf\", [string]], [\"AlignmentAdjust\", [obj]], [\"AlignmentBaseline\", [string]], [\"All\", [string]], [\"Animation\", [obj]], [\"AnimationDelay\", [obj]], [\"AnimationDirection\", [string]], [\"AnimationDuration\", [obj]], [\"AnimationFillMode\", [string]], [\"AnimationIterationCount\", [obj]], [\"AnimationName\", [obj]], [\"AnimationPlayState\", [obj]], [\"AnimationTimingFunction\", [obj]], [\"Appearance\", [string]], [\"BackfaceVisibility\", [string]], [\"Background\", [obj]], [\"BackgroundAttachment\", [obj]], [\"BackgroundBlendMode\", [obj]], [\"BackgroundClip\", [obj]], [\"BackgroundColor\", [obj]], [\"BackgroundComposite\", [obj]], [\"BackgroundImage\", [obj]], [\"BackgroundOrigin\", [obj]], [\"BackgroundPosition\", [obj]], [\"BackgroundPositionX\", [obj]], [\"BackgroundPositionY\", [obj]], [\"BackgroundRepeat\", [obj]], [\"BackgroundSize\", [obj]], [\"BaselineShift\", [obj]], [\"Behavior\", [obj]], [\"BlockSize\", [obj]], [\"Border\", [obj]], [\"BorderBlockEnd\", [obj]], [\"BorderBlockEndColor\", [obj]], [\"BorderBlockEndStyle\", [obj]], [\"BorderBlockEndWidth\", [obj]], [\"BorderBlockStart\", [obj]], [\"BorderBlockStartColor\", [obj]], [\"BorderBlockStartStyle\", [obj]], [\"BorderBlockStartWidth\", [obj]], [\"BorderBottom\", [obj]], [\"BorderBottomColor\", [obj]], [\"BorderBottomLeftRadius\", [obj]], [\"BorderBottomRightRadius\", [obj]], [\"BorderBottomStyle\", [obj]], [\"BorderBottomWidth\", [obj]], [\"BorderCollapse\", [obj]], [\"BorderColor\", [obj]], [\"BorderCornerShape\", [obj]], [\"BorderImage\", [obj]], [\"BorderImageOutset\", [obj]], [\"BorderImageRepeat\", [obj]], [\"BorderImageSlice\", [obj]], [\"BorderImageSource\", [obj]], [\"BorderImageWidth\", [obj]], [\"BorderInlineEnd\", [obj]], [\"BorderInlineEndColor\", [obj]], [\"BorderInlineEndStyle\", [obj]], [\"BorderInlineEndWidth\", [obj]], [\"BorderInlineStart\", [obj]], [\"BorderInlineStartColor\", [obj]], [\"BorderInlineStartStyle\", [obj]], [\"BorderInlineStartWidth\", [obj]], [\"BorderLeft\", [obj]], [\"BorderLeftColor\", [obj]], [\"BorderLeftStyle\", [obj]], [\"BorderLeftWidth\", [obj]], [\"BorderRadius\", [obj]], [\"BorderRight\", [obj]], [\"BorderRightColor\", [obj]], [\"BorderRightStyle\", [obj]], [\"BorderRightWidth\", [obj]], [\"BorderSpacing\", [obj]], [\"BorderStyle\", [obj]], [\"BorderTop\", [obj]], [\"BorderTopColor\", [obj]], [\"BorderTopLeftRadius\", [obj]], [\"BorderTopRightRadius\", [obj]], [\"BorderTopStyle\", [obj]], [\"BorderTopWidth\", [obj]], [\"BorderWidth\", [obj]], [\"Bottom\", [obj]], [\"BoxAlign\", [string]], [\"BoxDecorationBreak\", [string]], [\"BoxDirection\", [string]], [\"BoxFlex\", [obj]], [\"BoxFlexGroup\", [obj]], [\"BoxLineProgression\", [obj]], [\"BoxLines\", [obj]], [\"BoxOrdinalGroup\", [obj]], [\"BoxShadow\", [obj]], [\"BoxSizing\", [string]], [\"BreakAfter\", [string]], [\"BreakBefore\", [string]], [\"BreakInside\", [string]], [\"CaptionSide\", [string]], [\"CaretColor\", [obj]], [\"Clear\", [string]], [\"Clip\", [obj]], [\"ClipPath\", [obj]], [\"ClipRule\", [obj]], [\"Color\", [obj]], [\"ColorInterpolation\", [obj]], [\"ColorInterpolationFilters\", [obj]], [\"ColorProfile\", [obj]], [\"ColorRendering\", [obj]], [\"ColumnCount\", [obj]], [\"ColumnFill\", [obj]], [\"ColumnGap\", [obj]], [\"ColumnRule\", [obj]], [\"ColumnRuleColor\", [obj]], [\"ColumnRuleStyle\", [obj]], [\"ColumnRuleWidth\", [obj]], [\"ColumnSpan\", [obj]], [\"ColumnWidth\", [obj]], [\"Columns\", [obj]], [\"Content\", [obj]], [\"CounterIncrement\", [obj]], [\"CounterReset\", [obj]], [\"Cue\", [obj]], [\"CueAfter\", [obj]], [\"Cursor\", [obj]], [\"Direction\", [string]], [\"Display\", [string]], [\"DominantBaseline\", [obj]], [\"EmptyCells\", [obj]], [\"EnableBackground\", [obj]], [\"Fill\", [obj]], [\"FillOpacity\", [obj]], [\"FillRule\", [obj]], [\"Filter\", [obj]], [\"Flex\", [obj]], [\"FlexAlign\", [obj]], [\"FlexBasis\", [obj]], [\"FlexDirection\", [obj]], [\"FlexFlow\", [obj]], [\"FlexGrow\", [obj]], [\"FlexItemAlign\", [obj]], [\"FlexLinePack\", [obj]], [\"FlexOrder\", [obj]], [\"FlexShrink\", [obj]], [\"FlexWrap\", [obj]], [\"Float\", [string]], [\"FloodColor\", [obj]], [\"FloodOpacity\", [obj]], [\"FlowFrom\", [obj]], [\"Font\", [obj]], [\"FontFamily\", [obj]], [\"FontFeatureSettings\", [obj]], [\"FontKerning\", [obj]], [\"FontLanguageOverride\", [obj]], [\"FontSize\", [obj]], [\"FontSizeAdjust\", [obj]], [\"FontStretch\", [obj]], [\"FontStyle\", [obj]], [\"FontSynthesis\", [obj]], [\"FontVariant\", [obj]], [\"FontVariantAlternates\", [obj]], [\"FontVariantCaps\", [obj]], [\"FontVariantEastAsian\", [obj]], [\"FontVariantLigatures\", [obj]], [\"FontVariantNumeric\", [obj]], [\"FontVariantPosition\", [obj]], [\"FontWeight\", [obj]], [\"GlyphOrientationHorizontal\", [obj]], [\"GlyphOrientationVertical\", [obj]], [\"Grid\", [obj]], [\"GridArea\", [obj]], [\"GridAutoColumns\", [obj]], [\"GridAutoFlow\", [obj]], [\"GridAutoRows\", [obj]], [\"GridColumn\", [obj]], [\"GridColumnEnd\", [obj]], [\"GridColumnGap\", [obj]], [\"GridColumnStart\", [obj]], [\"GridGap\", [obj]], [\"GridRow\", [obj]], [\"GridRowEnd\", [obj]], [\"GridRowGap\", [obj]], [\"GridRowPosition\", [obj]], [\"GridRowSpan\", [obj]], [\"GridRowStart\", [obj]], [\"GridTemplate\", [obj]], [\"GridTemplateAreas\", [obj]], [\"GridTemplateColumns\", [obj]], [\"GridTemplateRows\", [obj]], [\"HangingPunctuation\", [obj]], [\"Height\", [obj]], [\"HyphenateLimitChars\", [obj]], [\"HyphenateLimitLines\", [obj]], [\"HyphenateLimitZone\", [obj]], [\"Hyphens\", [obj]], [\"ImageOrientation\", [obj]], [\"ImageRendering\", [string]], [\"ImageResolution\", [obj]], [\"ImeMode\", [obj]], [\"InlineSize\", [obj]], [\"Isolation\", [obj]], [\"JustifyContent\", [obj]], [\"JustifySelf\", [string]], [\"Kerning\", [obj]], [\"LayoutGrid\", [obj]], [\"LayoutGridChar\", [obj]], [\"LayoutGridLine\", [obj]], [\"LayoutGridMode\", [obj]], [\"LayoutGridType\", [obj]], [\"Left\", [obj]], [\"LetterSpacing\", [obj]], [\"LightingColor\", [obj]], [\"LineBreak\", [obj]], [\"LineClamp\", [obj]], [\"LineHeight\", [obj]], [\"ListStyle\", [obj]], [\"ListStyleImage\", [obj]], [\"ListStylePosition\", [obj]], [\"ListStyleType\", [obj]], [\"Margin\", [obj]], [\"MarginBlockEnd\", [obj]], [\"MarginBlockStart\", [obj]], [\"MarginBottom\", [obj]], [\"MarginInlineEnd\", [obj]], [\"MarginInlineStart\", [obj]], [\"MarginLeft\", [obj]], [\"MarginRight\", [obj]], [\"MarginTop\", [obj]], [\"MarkerEnd\", [obj]], [\"MarkerMid\", [obj]], [\"MarkerStart\", [obj]], [\"MarqueeDirection\", [obj]], [\"MarqueeStyle\", [obj]], [\"Mask\", [obj]], [\"MaskBorder\", [obj]], [\"MaskBorderRepeat\", [obj]], [\"MaskBorderSlice\", [obj]], [\"MaskBorderSource\", [obj]], [\"MaskBorderWidth\", [obj]], [\"MaskClip\", [obj]], [\"MaskComposite\", [obj]], [\"MaskImage\", [obj]], [\"MaskMode\", [obj]], [\"MaskOrigin\", [obj]], [\"MaskPosition\", [obj]], [\"MaskRepeat\", [obj]], [\"MaskSize\", [obj]], [\"MaskType\", [obj]], [\"MaxFontSize\", [obj]], [\"MaxHeight\", [obj]], [\"MaxWidth\", [obj]], [\"MinBlockSize\", [obj]], [\"MinHeight\", [obj]], [\"MinInlineSize\", [obj]], [\"MinWidth\", [obj]], [\"MixBlendMode\", [obj]], [\"ObjectFit\", [obj]], [\"ObjectPosition\", [obj]], [\"OffsetBlockEnd\", [obj]], [\"OffsetBlockStart\", [obj]], [\"OffsetInlineEnd\", [obj]], [\"OffsetInlineStart\", [obj]], [\"Opacity\", [obj]], [\"Order\", [obj]], [\"Orphans\", [obj]], [\"Outline\", [obj]], [\"OutlineColor\", [obj]], [\"OutlineOffset\", [obj]], [\"OutlineStyle\", [obj]], [\"OutlineWidth\", [obj]], [\"OverflowStyle\", [obj]], [\"OverflowWrap\", [obj]], [\"OverflowX\", [string]], [\"OverflowY\", [string]], [\"Padding\", [obj]], [\"PaddingBlockEnd\", [obj]], [\"PaddingBlockStart\", [obj]], [\"PaddingBottom\", [obj]], [\"PaddingInlineEnd\", [obj]], [\"PaddingInlineStart\", [obj]], [\"PaddingLeft\", [obj]], [\"PaddingRight\", [obj]], [\"PaddingTop\", [obj]], [\"PageBreakAfter\", [obj]], [\"PageBreakBefore\", [obj]], [\"PageBreakInside\", [obj]], [\"Pause\", [obj]], [\"PauseAfter\", [obj]], [\"PauseBefore\", [obj]], [\"Perspective\", [obj]], [\"PerspectiveOrigin\", [obj]], [\"PointerEvents\", [obj]], [\"Position\", [string]], [\"PunctuationTrim\", [obj]], [\"Quotes\", [obj]], [\"RegionFragment\", [obj]], [\"Resize\", [obj]], [\"RestAfter\", [obj]], [\"RestBefore\", [obj]], [\"Right\", [obj]], [\"RubyAlign\", [obj]], [\"RubyMerge\", [obj]], [\"RubyPosition\", [obj]], [\"ScrollBehavior\", [obj]], [\"ScrollSnapCoordinate\", [obj]], [\"ScrollSnapDestination\", [obj]], [\"ScrollSnapType\", [obj]], [\"ShapeImageThreshold\", [obj]], [\"ShapeInside\", [obj]], [\"ShapeMargin\", [obj]], [\"ShapeOutside\", [obj]], [\"ShapeRendering\", [obj]], [\"Speak\", [obj]], [\"SpeakAs\", [obj]], [\"StopColor\", [obj]], [\"StopOpacity\", [obj]], [\"Stroke\", [obj]], [\"StrokeDasharray\", [obj]], [\"StrokeDashoffset\", [obj]], [\"StrokeLinecap\", [obj]], [\"StrokeLinejoin\", [obj]], [\"StrokeMiterlimit\", [obj]], [\"StrokeOpacity\", [obj]], [\"StrokeWidth\", [obj]], [\"TabSize\", [obj]], [\"TableLayout\", [obj]], [\"TextAlign\", [string]], [\"TextAlignLast\", [obj]], [\"TextAnchor\", [obj]], [\"TextCombineUpright\", [obj]], [\"TextDecoration\", [obj]], [\"TextDecorationColor\", [obj]], [\"TextDecorationLine\", [obj]], [\"TextDecorationLineThrough\", [obj]], [\"TextDecorationNone\", [obj]], [\"TextDecorationOverline\", [obj]], [\"TextDecorationSkip\", [obj]], [\"TextDecorationStyle\", [obj]], [\"TextDecorationUnderline\", [obj]], [\"TextEmphasis\", [obj]], [\"TextEmphasisColor\", [obj]], [\"TextEmphasisPosition\", [obj]], [\"TextEmphasisStyle\", [obj]], [\"TextHeight\", [obj]], [\"TextIndent\", [obj]], [\"TextJustify\", [obj]], [\"TextJustifyTrim\", [obj]], [\"TextKashidaSpace\", [obj]], [\"TextLineThrough\", [obj]], [\"TextLineThroughColor\", [obj]], [\"TextLineThroughMode\", [obj]], [\"TextLineThroughStyle\", [obj]], [\"TextLineThroughWidth\", [obj]], [\"TextOrientation\", [obj]], [\"TextOverflow\", [obj]], [\"TextOverline\", [obj]], [\"TextOverlineColor\", [obj]], [\"TextOverlineMode\", [obj]], [\"TextOverlineStyle\", [obj]], [\"TextOverlineWidth\", [obj]], [\"TextRendering\", [obj]], [\"TextScript\", [obj]], [\"TextShadow\", [obj]], [\"TextTransform\", [obj]], [\"TextUnderlinePosition\", [obj]], [\"TextUnderlineStyle\", [obj]], [\"Top\", [obj]], [\"TouchAction\", [obj]], [\"Transform\", [obj]], [\"TransformBox\", [obj]], [\"TransformOrigin\", [obj]], [\"TransformOriginZ\", [obj]], [\"TransformStyle\", [obj]], [\"Transition\", [obj]], [\"TransitionDelay\", [obj]], [\"TransitionDuration\", [obj]], [\"TransitionProperty\", [obj]], [\"TransitionTimingFunction\", [obj]], [\"UnicodeBidi\", [obj]], [\"UnicodeRange\", [obj]], [\"UserFocus\", [obj]], [\"UserInput\", [obj]], [\"UserSelect\", [string]], [\"VerticalAlign\", [obj]], [\"Visibility\", [obj]], [\"VoiceBalance\", [obj]], [\"VoiceDuration\", [obj]], [\"VoiceFamily\", [obj]], [\"VoicePitch\", [obj]], [\"VoiceRange\", [obj]], [\"VoiceRate\", [obj]], [\"VoiceStress\", [obj]], [\"VoiceVolume\", [obj]], [\"WhiteSpace\", [string]], [\"WhiteSpaceTreatment\", [obj]], [\"Widows\", [obj]], [\"Width\", [obj]], [\"WillChange\", [obj]], [\"WordBreak\", [obj]], [\"WordSpacing\", [obj]], [\"WordWrap\", [obj]], [\"WrapFlow\", [obj]], [\"WrapMargin\", [obj]], [\"WrapOption\", [obj]], [\"WritingMode\", [obj]], [\"ZIndex\", [obj]], [\"Zoom\", [obj]], [\"Custom\", [string, obj]]]);\n}\nexport function stringEnum(case$) {\n  return String(case$);\n}\nexport function CSSProp$$$Overflow$$25F0CD75(overflow, overflowY) {\n  if (overflowY == null) {\n    return [\"overflow\", stringEnum(overflow)];\n  } else {\n    const value = overflowY;\n    return [\"overflow\", stringEnum(overflow) + \" \" + stringEnum(value)];\n  }\n}","import { equals, uncurry } from \"../fable-library.2.4.13/Util\";\nimport * as react from \"react\";\nimport { isNullOrEmpty } from \"../fable-library.2.4.13/String\";\nimport { fold, choose } from \"../fable-library.2.4.13/Seq\";\nimport { HTMLAttr } from \"./Fable.React.Props\";\nexport function ReactElementTypeModule$$$memo(render) {\n  return react.memo(render, uncurry(2, null));\n}\nexport function ReactElementTypeModule$$$memoWith(areEqual, render$$1) {\n  return react.memo(render$$1, areEqual);\n}\nexport function Helpers$$$equalsButFunctions(x, y) {\n  if (x === y) {\n    return true;\n  } else if (typeof x === \"object\" && !x[Symbol.iterator] ? !(y == null) : false) {\n    const keys = Object.keys(x);\n    const length = keys.length | 0;\n    let i = 0;\n    let result = true;\n\n    while (i < length ? result : false) {\n      const key = keys[i];\n      i = i + 1;\n      const xValue = x[key];\n      result = typeof xValue === \"function\" ? true : equals(xValue, y[key]);\n    }\n\n    return result;\n  } else {\n    return equals(x, y);\n  }\n}\nexport function Helpers$$$memoEqualsButFunctions(x$$1, y$$1) {\n  if (x$$1 === y$$1) {\n    return true;\n  } else if (typeof x$$1 === \"object\" && !x$$1[Symbol.iterator] ? !(y$$1 == null) : false) {\n    const keys$$1 = Object.keys(x$$1);\n    const length$$1 = keys$$1.length | 0;\n    let i$$1 = 0;\n    let result$$1 = true;\n\n    while (i$$1 < length$$1 ? result$$1 : false) {\n      const key$$1 = keys$$1[i$$1];\n      i$$1 = i$$1 + 1;\n      const xValue$$1 = x$$1[key$$1];\n      result$$1 = typeof xValue$$1 === \"function\" ? true : xValue$$1 === y$$1[key$$1];\n    }\n\n    return result$$1;\n  } else {\n    return false;\n  }\n}\nexport function Helpers$$$memoBuilder(name, render$$2) {\n  render$$2.displayName = name;\n  const memoType = ReactElementTypeModule$$$memo(render$$2);\n  return function (props) {\n    const children = [];\n    return react.createElement(memoType, props, ...children);\n  };\n}\nexport function Helpers$$$memoBuilderWith(name$$1, areEqual$$1, render$$3) {\n  render$$3.displayName = name$$1;\n  const memoType$$1 = ReactElementTypeModule$$$memoWith(areEqual$$1, render$$3);\n  return function (props$$2) {\n    const children$$1 = [];\n    return react.createElement(memoType$$1, props$$2, ...children$$1);\n  };\n}\nexport function Helpers$$$opt(o) {\n  if (o == null) {\n    return null;\n  } else {\n    const o$$2 = o;\n    return o$$2;\n  }\n}\nexport const Helpers$$$nothing = null;\nexport function Helpers$$$classBaseList(baseClass, classes) {\n  let arg0;\n  let source$$1;\n  source$$1 = choose(function chooser(tupledArg) {\n    if (tupledArg[1] ? !isNullOrEmpty(tupledArg[0]) : false) {\n      return tupledArg[0];\n    } else {\n      return null;\n    }\n  }, classes);\n  arg0 = fold(function folder(state, name$$3) {\n    return state + \" \" + name$$3;\n  }, baseClass, source$$1);\n  return new HTMLAttr(64, \"ClassName\", arg0);\n}\nexport function Helpers$$$classList(classes$$1) {\n  return Helpers$$$classBaseList(\"\", classes$$1);\n}","import { declare } from \"../fable-library.2.4.13/Types\";\nimport { type } from \"../fable-library.2.4.13/Reflection\";\nimport { curry } from \"../fable-library.2.4.13/Util\";\nimport { ReactElementTypeModule$$$memoWith as ReactElementTypeModule$0024$0024$0024memoWith } from \"./Fable.React.Helpers\";\nimport * as react from \"react\";\nexport const FunctionComponent = declare(function Fable_React_FunctionComponent() {});\nexport function FunctionComponent$reflection() {\n  return type(\"Fable.React.FunctionComponent\");\n}\nexport function FunctionComponent$$$Of$$Z603636D8(render, displayName, memoizeWith, withKey) {\n  if (displayName == null) {} else {\n    const name = displayName;\n    render.displayName = name;\n  }\n\n  let elemType;\n\n  if (curry(2, memoizeWith) == null) {\n    elemType = render;\n  } else {\n    const areEqual = memoizeWith;\n    const memoElement = ReactElementTypeModule$0024$0024$0024memoWith(areEqual, render);\n\n    if (displayName == null) {} else {\n      const name$$1 = displayName;\n      memoElement.displayName = \"Memo(\" + name$$1 + \")\";\n    }\n\n    elemType = memoElement;\n  }\n\n  return function (props) {\n    let props$$1;\n\n    if (withKey == null) {\n      props$$1 = props;\n    } else {\n      const f$$1 = withKey;\n      props.key = f$$1(props);\n      props$$1 = props;\n    }\n\n    const children = [];\n    return react.createElement(elemType, props$$1, ...children);\n  };\n}","import { declare, Record } from \"./fable-library.2.4.13/Types\";\nimport { Msg$reflection as Msg$0024reflection, Model$reflection as Model$0024reflection } from \"./Model\";\nimport { record, lambda, unit } from \"./fable-library.2.4.13/Reflection\";\nimport * as react from \"react\";\nimport { update, init, initialState } from \"./State\";\nimport { ProgramModule$$$run as ProgramModule$0024$0024$0024run, ProgramModule$$$mkProgram as ProgramModule$0024$0024$0024mkProgram } from \"./Fable.Elmish.3.0.6/program\";\nimport { Helpers$$$memoEqualsButFunctions as Helpers$0024$0024$0024memoEqualsButFunctions } from \"./Fable.React.5.3.6/Fable.React.Helpers\";\nimport { FunctionComponent$$$Of$$Z603636D8 as FunctionComponent$0024$0024$0024Of$0024$0024Z603636D8 } from \"./Fable.React.5.3.6/Fable.React.FunctionComponent\";\nexport const AppContext = declare(function Ronnies_Client_View_AppContext(arg1, arg2) {\n  this.Model = arg1;\n  this.Dispatch = arg2;\n}, Record);\nexport function AppContext$reflection() {\n  return record(\"Ronnies.Client.View.AppContext\", [], AppContext, () => [[\"Model\", Model$0024reflection()], [\"Dispatch\", lambda(Msg$0024reflection(), unit)]]);\n}\nconst defaultContextValue = void 0;\nexport const appContext = react.createContext(defaultContextValue);\nexport const ElmishCapture = FunctionComponent$0024$0024$0024Of$0024$0024Z603636D8(function (props) {\n  const state = react.useState(new AppContext(initialState, function (value) {\n    void value;\n  }));\n  react.useEffect(function () {\n    const program = ProgramModule$0024$0024$0024mkProgram(function () {\n      return init();\n    }, update, function view(model, dispatch) {\n      state[1](new AppContext(model, dispatch));\n    });\n    ProgramModule$0024$0024$0024run(program);\n  }, new Array(0));\n  const value$$1 = state[0];\n  const children = [props.children];\n  return react.createElement(appContext.Provider, {\n    value: value$$1\n  }, ...children);\n}, \"ElmishCapture\", Helpers$0024$0024$0024memoEqualsButFunctions);","import { appContext } from \"./View\";\nimport * as react from \"react\";\nimport { Msg } from \"./Model\";\nimport { uncurry } from \"./fable-library.2.4.13/Util\";\nimport { some } from \"./fable-library.2.4.13/Option\";\n\nfunction f(g) {\n  return function (delegateArg0) {\n    return g(delegateArg0);\n  };\n}\n\nfunction useModel() {\n  const patternInput = react.useContext(appContext);\n  return patternInput.Model;\n}\n\nfunction useDispatch() {\n  const patternInput$$1 = react.useContext(appContext);\n  return patternInput$$1.Dispatch;\n}\n\nexport function useSetToken() {\n  const dispatch$$1 = useDispatch();\n  return f(function (token) {\n    dispatch$$1(new Msg(0, \"SetToken\", token));\n  });\n}\nexport function useDump() {\n  const model$$1 = useModel();\n  return JSON.stringify(model$$1, uncurry(2, null), some(4));\n}","import React from 'react';\r\nimport {useDump} from \"../bin/Hooks\";\r\n\r\nconst Home = () => {\r\n    const model = useDump();\r\n    return (\r\n        <div>\r\n            Home<br />\r\n            <code>{model}</code>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default Home;","import React from 'react';\r\n\r\nconst NotFound = () => {\r\n    return (\r\n        <div>\r\n            Page not found\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default NotFound;","import React from \"react\";\r\nimport { useForm } from \"react-hook-form\";\r\nimport { Button, Form, FormGroup, Input, Label } from \"reactstrap\";\r\n\r\nconst AddLocation = () => {\r\n  const { register, handleSubmit, errors, watch } = useForm({\r\n    name: \"\",\r\n    location: [0, 0],\r\n    price: 0,\r\n    isDraft: false,\r\n    remark: \"\"\r\n  });\r\n\r\n  const onSubmit = values => {};\r\n\r\n  console.log(watch(\"name\"));\r\n\r\n  return (\r\n    <div className={\"h-100 bg-white pt-2\"}>\r\n      <div className=\"container\">\r\n        <h1>E nieuwen toevoegen</h1>\r\n        <Form onSubmit={handleSubmit(onSubmit)}>\r\n          <FormGroup>\r\n            <Label for=\"name\">Naam*</Label>\r\n            <Input\r\n              type=\"text\"\r\n              name=\"name\"\r\n              autoComplete=\"off\"\r\n              innerRef={register}\r\n              invalid={errors.name}\r\n              placeholder=\"Officiele name van de plekke woa daj zit\"\r\n            />\r\n          </FormGroup>\r\n          <div className=\"text-right\">\r\n            <Button type=\"submit\" color=\"primary\">\r\n              Save!\r\n            </Button>\r\n          </div>\r\n        </Form>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default AddLocation;\r\n","import { navigate } from \"hookrouter\";\r\n// eslint-disable-next-line no-restricted-globals\r\nconst currentDomain = `${location.protocol}//${location.host}`;\r\n\r\nconst auth0Config = {\r\n  domain: process.env.REACT_APP_AUTH0_DOMAIN,\r\n  client_id: process.env.REACT_APP_AUTH0_CIENT_ID,\r\n  audience: process.env.REACT_APP_AUTH0_AUDIENCE,\r\n  redirect_uri: `${currentDomain}/oauth`,\r\n  scope: process.env.REACT_APP_AUTH0_SCOPE,\r\n  onRedirectCallback: () => navigate(\"/\")\r\n};\r\n\r\nexport default auth0Config;\r\n","import React, { useState, useEffect, useContext } from \"react\";\r\nimport createAuth0Client from \"@auth0/auth0-spa-js\";\r\n\r\nconst DEFAULT_REDIRECT_CALLBACK = () =>\r\n  window.history.replaceState({}, document.title, window.location.pathname);\r\n\r\nexport const Auth0Context = React.createContext();\r\nexport const useAuth0 = () => useContext(Auth0Context);\r\nexport const Auth0Provider = ({\r\n  children,\r\n  onRedirectCallback = DEFAULT_REDIRECT_CALLBACK,\r\n  ...initOptions\r\n}) => {\r\n  const [isAuthenticated, setIsAuthenticated] = useState();\r\n  const [user, setUser] = useState();\r\n  const [auth0Client, setAuth0] = useState();\r\n  const [loading, setLoading] = useState(true);\r\n  const [popupOpen, setPopupOpen] = useState(false);\r\n\r\n  useEffect(() => {\r\n    const initAuth0 = async () => {\r\n      const auth0FromHook = await createAuth0Client(initOptions);\r\n      setAuth0(auth0FromHook);\r\n\r\n      if (window.location.search.includes(\"code=\")) {\r\n        const { appState } = await auth0FromHook.handleRedirectCallback();\r\n        onRedirectCallback(appState);\r\n      }\r\n\r\n      const isAuthenticated = await auth0FromHook.isAuthenticated();\r\n\r\n      setIsAuthenticated(isAuthenticated);\r\n\r\n      if (isAuthenticated) {\r\n        const user = await auth0FromHook.getUser();\r\n        setUser(user);\r\n      }\r\n\r\n      setLoading(false);\r\n    };\r\n    initAuth0();\r\n    // eslint-disable-next-line\r\n  }, []);\r\n\r\n  const loginWithPopup = async (params = {}) => {\r\n    setPopupOpen(true);\r\n    try {\r\n      await auth0Client.loginWithPopup(params);\r\n    } catch (error) {\r\n      console.error(error);\r\n    } finally {\r\n      setPopupOpen(false);\r\n    }\r\n    const user = await auth0Client.getUser();\r\n    setUser(user);\r\n    setIsAuthenticated(true);\r\n  };\r\n\r\n  const handleRedirectCallback = async () => {\r\n    setLoading(true);\r\n    await auth0Client.handleRedirectCallback();\r\n    const user = await auth0Client.getUser();\r\n    setLoading(false);\r\n    setIsAuthenticated(true);\r\n    setUser(user);\r\n  };\r\n\r\n  return (\r\n    <Auth0Context.Provider\r\n      value={{\r\n        isAuthenticated,\r\n        user,\r\n        loading,\r\n        popupOpen,\r\n        loginWithPopup,\r\n        handleRedirectCallback,\r\n        getIdTokenClaims: (...p) => auth0Client.getIdTokenClaims(...p),\r\n        loginWithRedirect: (...p) => auth0Client.loginWithRedirect(...p),\r\n        getTokenSilently: (...p) => auth0Client.getTokenSilently(...p),\r\n        getTokenWithPopup: (...p) => auth0Client.getTokenWithPopup(...p),\r\n        logout: (...p) => auth0Client.logout(...p)\r\n      }}\r\n    >\r\n      {children}\r\n    </Auth0Context.Provider>\r\n  );\r\n};\r\n","import auth0Config from \"./config\";\r\nexport { Auth0Provider, useAuth0 } from \"./react-auth0-wrapper\";\r\nexport const config = auth0Config;\r\nexport const redirectUri = auth0Config.redirect_uri;\r\n","import React, { useEffect, useState } from \"react\";\r\nimport { useAuth0 } from \"../Auth\";\r\n\r\nconst TokenPage = () => {\r\n  const { getTokenSilently } = useAuth0();\r\n  const [token, setToken] = useState();\r\n  useEffect(() => {\r\n    getTokenSilently().then(token => {\r\n      setToken(token);\r\n    });\r\n  }, [getTokenSilently, token]);\r\n\r\n  return <div>{token}</div>;\r\n};\r\n\r\nexport default TokenPage;\r\n","import React from \"react\";\r\nimport { Home, TokenPage, AddLocation } from \"../Pages\";\r\n\r\nexport default {\r\n  \"/\": () => <Home />,\r\n  \"/token\": () => <TokenPage />,\r\n  \"/add-location\": () => <AddLocation />\r\n};\r\n","import React, { useState } from \"react\";\r\nimport PropTypes from 'prop-types'\r\nimport { redirectUri, useAuth0 } from \"../Auth\";\r\nimport { A, usePath } from \"hookrouter\";\r\nimport {\r\n  Navbar,\r\n  NavItem,\r\n  NavLink,\r\n  NavbarBrand,\r\n  NavbarToggler\r\n} from \"reactstrap\";\r\nimport Collapse from \"reactstrap/es/Collapse\";\r\nimport Nav from \"reactstrap/es/Nav\";\r\n\r\nconst Navigation = ({ role }) => {\r\n  const [collapsed, setCollapsed] = useState(true);\r\n  const { loginWithRedirect, logout, isAuthenticated, user } = useAuth0();\r\n\r\n  const path = usePath();\r\n  const loginHandler = ev => {\r\n    ev.preventDefault();\r\n    loginWithRedirect({ redirect_uri: redirectUri });\r\n  };\r\n  const logoutHandler = ev => {\r\n    ev.preventDefault();\r\n    logout();\r\n  };\r\n  let loginButton = isAuthenticated ? (\r\n    <NavItem onClick={logoutHandler}>\r\n      <NavLink href={\"#\"}>Uitloggen</NavLink>\r\n    </NavItem>\r\n  ) : (\r\n    <NavItem onClick={loginHandler}>\r\n      <NavLink href={\"#\"}>Inloggen</NavLink>\r\n    </NavItem>\r\n  );\r\n\r\n  const userElement = user && (\r\n    <span className={\"navbar-text d-flex align-items-center\"}>\r\n      <img src={user.picture} className={\"avatar\"} alt={\"user avatar\"} />\r\n      {user.nickname}\r\n    </span>\r\n  );\r\n\r\n  const navLink = (link, name) => {\r\n    const isActive = link === path;\r\n    return (\r\n      <NavItem key={link}>\r\n        <NavLink href={link} tag={A} active={isActive}>\r\n          {name}\r\n        </NavLink>\r\n      </NavItem>\r\n    );\r\n  };\r\n\r\n  const extraMenuItems = (() => {\r\n    if (!isAuthenticated) {\r\n      return [navLink(\"/\")];\r\n    } else {\r\n      switch (role) {\r\n        case \"Admin\":\r\n        case \"Editor\":\r\n          return [\r\n            navLink(\"/\", \"Koarte\"),\r\n            navLink(\"/add-location\", \"E nieuwen toevoegen\"),\r\n            navLink(\"/user-scores\", \"Klassement\"),\r\n            navLink(\"/rules\", \"Reglement\"),\r\n            navLink(\"/settings\", \"Instellingen\")\r\n          ];\r\n        default:\r\n          return [navLink(\"/\", \"Koarte\"), navLink(\"/settings\", \"Instellingen\")];\r\n      }\r\n    }\r\n  })();\r\n\r\n  return (\r\n    <Navbar color=\"primary\" dark expand={\"md\"}>\r\n      <NavbarBrand href={\"/\"}>\r\n        <img src={\"assets/r-white.png\"} alt={\"Logo ronnies.be\"} />\r\n      </NavbarBrand>\r\n      <NavbarToggler onClick={() => setCollapsed(!collapsed)} />\r\n      <Collapse isOpen={!collapsed} navbar>\r\n        <Nav navbar className=\"mr-auto\">\r\n          {extraMenuItems}\r\n          {loginButton}\r\n        </Nav>\r\n        {userElement}\r\n      </Collapse>\r\n    </Navbar>\r\n  );\r\n};\r\n\r\nNavigation.propTypes = {\r\n  role: PropTypes.string.isRequired\r\n};\r\n\r\nexport default Navigation;\r\n","import React from 'react';\r\nimport PropTypes from 'prop-types'\r\n\r\nconst Loading = ({info}) => {\r\n    return (\r\n        <div id={'preloader'}>\r\n            <div id=\"loader\">{info}</div>\r\n        </div>\r\n    );\r\n};\r\n\r\nLoading.propTypes = {\r\n    info: PropTypes.string\r\n}\r\n\r\nexport default Loading;","import React, { useEffect } from \"react\";\r\nimport { useRoutes, navigate } from \"hookrouter\";\r\nimport routes from \"../Routes\";\r\nimport { NotFound } from \"../Pages\";\r\nimport Navigation from \"./Navigation\";\r\nimport { useAuth0 } from \"../Auth\";\r\nimport Loading from \"./Loading\";\r\nimport { useSetToken } from \"../bin/Hooks\"\r\n\r\nconst Layout = () => {\r\n  const routeResult = useRoutes(routes);\r\n  let { loading, user, getTokenSilently } = useAuth0();\r\n  // Redirect from the 404 page.\r\n  useEffect(() => {\r\n    const path = localStorage.getItem(\"path\");\r\n    if (path) {\r\n      localStorage.removeItem(\"path\");\r\n      navigate(path);\r\n    }\r\n  }, []);\r\n\r\n  const setToken = useSetToken();\r\n  useEffect(function () {\r\n    if(!loading && user){\r\n      getTokenSilently().then(setToken);\r\n    }\r\n  }, [loading, user, getTokenSilently, setToken]);\r\n\r\n  const showLoading = loading;\r\n\r\n  return showLoading ? (\r\n    <Loading />\r\n  ) : (\r\n    <main>\r\n      <Navigation role={\"admin\"} />\r\n      {routeResult || <NotFound />}\r\n    </main>\r\n  );\r\n};\r\n\r\nexport default Layout;\r\n","import React from \"react\";\nimport { Layout } from \"./Components\";\nimport { Auth0Provider, config } from \"./Auth\";\nimport { ElmishCapture } from \"./bin/View\";\n\nfunction App() {\n  return (\n    <Auth0Provider {...config}>\n      <ElmishCapture>\n        <Layout />\n      </ElmishCapture>\n    </Auth0Provider>\n  );\n}\n\nexport default App;\n\n// florian.verdonck@outlook.com\n// f6rNDkBssQoEUd\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./style.sass\";\nimport \"mapbox-gl/dist/mapbox-gl.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"app\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}